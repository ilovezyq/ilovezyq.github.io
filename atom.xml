<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cry On My Shoulder</title>
  <subtitle>居心久已忘，何事惊麋鹿？　</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ucasfl.me/"/>
  <updated>2017-09-23T04:51:21.162Z</updated>
  <id>http://ucasfl.me/</id>
  
  <author>
    <name>Flynn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 文件系统概览</title>
    <link href="http://ucasfl.me/2017/09/23/Introduction-to-Linux-FileSystem/"/>
    <id>http://ucasfl.me/2017/09/23/Introduction-to-Linux-FileSystem/</id>
    <published>2017-09-23T04:48:42.000Z</published>
    <updated>2017-09-23T04:51:21.162Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/community-penguins-osdc-lead.png?itok=BmqsAF4A" alt="Introduction to Linux filesystems" title="Introduction to Linux filesystems"></p>
<p>本文旨在高屋建瓴地来讨论 Linux 文件系统概念，而不是对某种特定的文件系统，比如 EXT4 是如何工作的进行具体的描述。另外，本文也不是一个文件系统命令的教程。</p>
<p>每台通用计算机都需要将各种数据存储在硬盘驱动器（HDD）或其他类似设备上，比如 USB 存储器。这样做有两个原因。首先，当计算机关闭以后，内存（RAM）会失去存于它里面的内容。尽管存在非易失类型的 RAM，在计算机断电以后还能把数据存储下来（比如采用 USB 闪存和固态硬盘的闪存），但是，闪存和标准的、易失性的 RAM，比如 DDR3 以及其他相似类型的 RAM 相比，要贵很多。</p>
<p>数据需要存储在硬盘驱动上的另一个原因是，即使是标准的 RAM 也要比普通硬盘贵得多。尽管 RAM 和硬盘的价格都在迅速下降，但是 RAM 的价格依旧在以字节为单位来计算。让我们进行一个以字节为单位的快速计算：基于 16 GB 大的 RAM 的价格和 2 TB 大的硬盘驱动的价格。计算显示 RAM 的价格大约比硬盘驱动贵 71 倍。今天，一个典型的 RAM 的价格大约是 0.000000004373750 美元/每字节。</p>
<p>直观的展示一下在很久以前 RAM 的价格，在计算机发展的非常早的时期，其中一种类型的 RAM 是基于在 CRT 屏幕上的点。这种 RAM 非常昂贵，大约 1 美元/每字节。</p>
<a id="more"></a>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>你可能听过其他人以各种不同和令人迷惑的方式谈论过文件系统。文件系统这个单词本身有多重含义，你需要从一个讨论或文件的上下文中理解它的正确含义。</p>
<p>我将根据我所观察到的在不同情况下使用“文件系统”这个词来定义它的不同含义。注意，尽管我试图遵循标准的“官方”含义，但是我打算基于它的不同用法来定义这个术语（如下）。这就是说我将在本文的后续章节中进行更详细的探讨。</p>
<ol>
<li>始于顶层 root（/）目录的整个 Linux 目录结构。</li>
<li>特定类型的数据存储格式，比如 EXT3、EXT4、BTRFS 以及 XFS 等等。Linux 支持近百种类型的文件系统，包括一些非常老的以及一些最新的。每一种文件系统类型都使用它自己独特的元数据结构来定义数据是如何存储和访问的。</li>
<li>用特定类型的文件系统格式化后的分区或逻辑卷，可以挂载到 Linux 文件系统的指定挂载点上。</li>
</ol>
<h3 id="文件系统的基本功能"><a href="#文件系统的基本功能" class="headerlink" title="文件系统的基本功能"></a>文件系统的基本功能</h3><p>磁盘存储是文件系统必须的功能，它与之伴生的有一些有趣而且不可或缺的细节。很明显，文件系统是用来为非易失数据的存储提供空间，这是它的基本功能。然而，它还有许多从需求出发的重要功能。</p>
<p>所有文件系统都需要提供一个名字空间，这是一种命名和组织方法。它定义了文件应该如何命名、文件名的最大长度，以及所有可用字符集中可用于文件名中字符集子集。它也定义了一个磁盘上数据的逻辑结构，比如使用目录来组织文件而不是把所有文件聚集成一个单一的、巨大的文件混合体。</p>
<p>定义名字空间以后，元数据结构是为该名字空间提供逻辑基础所必须的。这包括所需数据结构要能够支持分层目录结构，同时能够通过结构来确定硬盘空间中的块是已用的或可用的，支持修改文件或目录的名字，提供关于文件大小、创建时间、最后访问或修改时间等信息，以及位置或数据所属的文件在磁盘空间中的位置。其他的元数据用来存储关于磁盘细分的高级信息，比如逻辑卷和分区。这种更高层次的元数据以及它所代表的结构包含描述文件系统存储在驱动器或分区中的信息，但与文件系统元数据无关，与之独立。</p>
<p>文件系统也需要一个应用程序接口（API），从而提供了对文件系统对象，比如文件和目录进行操作的系统功能调用的访问。API 也提供了诸如创建、移动和删除文件的功能。它也提供了算法来确定某些信息，比如文件存于文件系统中的位置。这样的算法可以用来解释诸如磁盘速度和最小化磁盘碎片等术语。</p>
<p>现代文件系统还提供一个安全模型，这是一个定义文件和目录的访问权限的方案。Linux 文件系统安全模型确保用户只能访问自己的文件，而不能访问其他用户的文件或操作系统本身。</p>
<p>最后一块组成部分是实现这些所有功能所需要的软件。Linux 使用两层软件实现的方式来提高系统和程序员的效率。</p>
<p><img src="https://opensource.com/sites/default/files/filesystem_diagram.png" alt=""></p>
<p><em>图片 1：Linux 两层文件系统软件实现。</em></p>
<p>这两层中的第一层是 Linux 虚拟文件系统。虚拟文件系统提供了内核和开发者访问所有类型文件系统的的单一命令集。虚拟文件系统软件通过调用特殊设备驱动来和不同类型的文件系统进行交互。特定文件系统的设备驱动是第二层实现。设备驱动程序将文件系统命令的标准集解释为在分区或逻辑卷上的特定类型文件系统命令。</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>作为一个通常来说非常有条理的处女座，我喜欢将东西存储在更小的、有组织的小容器中，而不是存于同一个大容器中。目录的使用使我能够存储文件并在我想要查看这些文件的时候也能够找到它们。目录也被称为文件夹，之所以被称为文件夹，是因为其中的文件被类比存放于物理桌面上。</p>
<p>在 Linux 和其他许多操作系统中，目录可以被组织成树状的分层结构。在 <a href="http://www.pathname.com/fhs/" target="_blank" rel="external">Linux 文件系统层次标准</a>中定义了 Linux 的目录结构（LCTT 译注：可参阅<a href="https://linux.cn/article-6132-1.html" target="_blank" rel="external">这篇</a>）。当通过目录引用来访问目录时，更深层目录名字是通过正斜杠（/）来连接，从而形成一个序列，比如 <code>/var/log</code> 和 <code>/var/spool/mail</code> 。这些被称为路径。</p>
<p>下表提供了标准的、众所周知的、预定义的顶层 Linux 目录及其用途的简要清单。</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>/ (root 文件系统)</strong></td>
<td>root 文件系统是文件系统的顶级目录。它必须包含在挂载其它文件系统前需要用来启动 Linux 系统的全部文件。它必须包含需要用来启动剩余文件系统的全部可执行文件和库。文件系统启动以后，所有其他文件系统作为 root 文件系统的子目录挂载到标准的、预定义好的挂载点上。</td>
</tr>
<tr>
<td><strong>/bin</strong></td>
<td><code>/bin</code> 目录包含用户的可执行文件。</td>
</tr>
<tr>
<td>/boot</td>
<td>包含启动 Linux 系统所需要的静态引导程序和内核可执行文件以及配置文件。</td>
</tr>
<tr>
<td><strong>/dev</strong></td>
<td>该目录包含每一个连接到系统的硬件设备的设备文件。这些文件不是设备驱动，而是代表计算机上的每一个计算机能够访问的设备。</td>
</tr>
<tr>
<td><strong>/etc</strong></td>
<td>包含主机计算机的本地系统配置文件。</td>
</tr>
<tr>
<td>/home</td>
<td>主目录存储用户文件，每一个用户都有一个位于 <code>/home</code> 目录中的子目录（作为其主目录）。</td>
</tr>
<tr>
<td><strong>/lib</strong></td>
<td>包含启动系统所需要的共享库文件。</td>
</tr>
<tr>
<td>/media</td>
<td>一个挂载外部可移动设备的地方，比如主机可能连接了一个 USB 驱动器。</td>
</tr>
<tr>
<td>/mnt</td>
<td>一个普通文件系统的临时挂载点（如不可移动的介质），当管理员对一个文件系统进行修复或在其上工作时可以使用。</td>
</tr>
<tr>
<td>/opt</td>
<td>可选文件，比如供应商提供的应用程序应该安装在这儿。</td>
</tr>
<tr>
<td><strong>/root</strong></td>
<td>这不是 root（<code>/</code>）文件系统。它是 root 用户的主目录。</td>
</tr>
<tr>
<td><strong>/sbin</strong></td>
<td>系统二进制文件。这些是用于系统管理的可执行文件。</td>
</tr>
<tr>
<td>/tmp</td>
<td>临时目录。被操作系统和许多程序用来存储临时文件。用户也可能临时在这儿存储文件。注意，存储在这儿的文件可能在任何时候在没有通知的情况下被删除。</td>
</tr>
<tr>
<td>/usr</td>
<td>该目录里面包含可共享的、只读的文件，包括可执行二进制文件和库、man 文件以及其他类型的文档。</td>
</tr>
<tr>
<td>/var</td>
<td>可变数据文件存储在这儿。这些文件包括日志文件、MySQL 和其他数据库的文件、Web 服务器的数据文件、邮件以及更多。</td>
</tr>
</tbody>
</table>
<p><em>表 1：Linux 文件系统层次结构的顶层</em></p>
<p>这些目录以及它们的子目录如表 1 所示，在所有子目录中，粗体的目录组成了 root 文件系统的必需部分。也就是说，它们不能创建为一个分离的文件系统并且在开机时进行挂载。这是因为它们（特别是它们包含的内容）必须在系统启动的时候出现，从而系统才能正确启动。</p>
<p><code>/media</code> 目录和 <code>/mnt</code> 目录是 root 文件系统的一部分，但是它们从来不包含任何数据，因为它们只是一个临时挂载点。</p>
<p>表 1 中剩下的非粗体的目录不需要在系统启动过程中出现，但会在之后挂载到 root 文件系统上，在开机阶段，它们为主机进行准备，从而执行有用的工作。</p>
<p>请参考官方 <a href="http://www.pathname.com/fhs/" target="_blank" rel="external">Linux 文件系统层次标准</a>（FHS）网页来了解这些每一个目录以及它们的子目录的更多细节。维基百科上也有关于 <a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard" target="_blank" rel="external">FHS</a> 的一个很好的介绍。应该尽可能的遵循这些标准，从而确保操作和功能的一致性。无论在主机上使用什么类型的文件系统，该层次目录结构都是相同的。</p>
<h3 id="Linux-统一目录结构"><a href="#Linux-统一目录结构" class="headerlink" title="Linux 统一目录结构"></a>Linux 统一目录结构</h3><p>在一些非 Linux 操作系统的个人电脑上，如果有多个物理硬盘驱动器或多个分区，每一个硬盘或分区都会分配一个驱动器号。知道文件或程序位于哪一个硬盘驱动器上是很有必要的，比如 <code>C:</code> 或 <code>D:</code> 。然后，你可以在命令中使用驱动器号，以 <code>D:</code> 为例，为了进入 <code>D:</code> 驱动器，你可以使用 <code>cd</code> 命令来更改工作目录为正确的目录，从而定位需要的文件。每一个硬盘驱动器都有自己单独的、完整的目录树。</p>
<p>Linux 文件系统将所有物理硬盘驱动器和分区统一为一个目录结构。它们均从顶层 root 目录（<code>/</code>）开始。所有其它目录以及它们的子目录均位于单一的 Linux 根目录下。这意味着只有一棵目录树来搜索文件和程序。</p>
<p>因为只有一个文件系统，所以 <code>/home</code>、<code>/tmp</code>、<code>/var</code>、<code>/opt</code> 或 <code>/usr</code> 能够创建在和 root（<code>/</code>）文件系统不同的物理硬盘驱动器、分区或逻辑分区上，然后挂载到一个挂载点（目录）上，从而作为 root 文件系统树的一部分。甚至可移动驱动器，比如 USB 驱动器或一个外接的 USB 或 ESATA 硬盘驱动器均可以挂载到 root 文件系统上，成为目录树不可或缺的部分。</p>
<p>当从 Linux 发行版的一个版本升级到另一个版本或从一个发行版更改到另一个发行版的时候，就会很清楚地看到这样创建到不同分区的好处。通常情况下，除了任何像 Fedora 中的 <code>dnf-upgrade</code> 之类的升级工具，会明智地在升级过程中偶尔重新格式化包含操作系统的硬盘驱动来删除那些长期积累的垃圾。如果 <code>/home</code> 目录是 root 文件系统的一部分（位于同一个硬盘驱动器），那么它也会被格式化，然后需要通过之前的备份恢复。如果 /home 目录作为一个分离的文件系统，那么安装程序将会识别到，并跳过它的格式化。对于存储数据库、邮箱、网页和其它可变的用户以及系统数据的 <code>/var</code> 目录也是这样的。</p>
<p>将 Linux 系统目录树的某些部分作为一个分离的文件系统还有一些其他原因。比如，在很久以前，我还不知道将所有需要的 Linux 目录均作为 root（<code>/</code>）文件系统的一部分可能存在的问题，于是，一些非常大的文件填满了 <code>/home</code> 目录。因为 <code>/home</code> 目录和 <code>/tmp</code> 目录均不是分离的文件系统，而是 root 文件系统的简单子目录，整个 root 文件系统就被填满了。于是就不再有剩余空间可以让操作系统用来存储临时文件或扩展已存在数据文件。首先，应用程序开始抱怨没有空间来保存文件，然后，操作系统也开始异常行动。启动到单用户模式，并清除了 <code>/home</code> 目录中的多余文件之后，终于又能够重新工作了。然后，我使用非常标准的多重文件系统设置来重新安装 Linux 系统，从而避免了系统崩溃的再次发生。</p>
<p>我曾经遇到一个情况，Linux 主机还在运行，但是却不允许用户通过 GUI 桌面登录。我可以通过使用<a href="https://en.wikipedia.org/wiki/Virtual_console" target="_blank" rel="external">虚拟控制台</a>之一，通过命令行界面（CLI）本地登录，然后远程使用 SSH 。问题的原因是因为 <code>/tmp</code> 文件系统满了，因此 GUI 桌面登录时所需要的一些临时文件不能被创建。因为命令行界面登录不需要在 <code>/tmp</code> 目录中创建文件，所以无可用空间并不会阻止我使用命令行界面来登录。在这种情况下，<code>/tmp</code> 目录是一个分离的文件系统，在 <code>/tmp</code> 所位于的逻辑卷上还有大量的可用空间。我简单地<a href="https://opensource.com/business/16/9/linux-users-guide-lvm" target="_blank" rel="external">扩展了 /tmp 逻辑卷</a>的容量到能够容纳主机所需要的临时文件，于是问题便解决了。注意，这个解决方法不需要重启，当 <code>/tmp</code> 文件系统扩大以后，用户就可以登录到桌面了。</p>
<p>当我在一家很大的科技公司当实验室管理员的时候，遇到过另外一个故障。开发者将一个应用程序安装到了一个错误的位置（<code>/var</code>）。结果该应用程序崩溃了，因为 <code>/var</code> 文件系统满了，由于缺乏空间，存储于 <code>/var/log</code> 中的日志文件无法附加新的日志消息。然而，系统仍然在运行，因为 root 文件系统和 <code>/tmp</code> 文件系统还没有被填满。删除了该应用程序并重新安装在 <code>/opt</code> 文件系统后，问题便解决了。</p>
<h3 id="文件系统类型"><a href="#文件系统类型" class="headerlink" title="文件系统类型"></a>文件系统类型</h3><p>Linux 系统支持大约 100 种分区类型的读取，但是只能对很少的一些进行创建和写操作。但是，可以挂载不同类型的文件系统在同一个 root 文件系统上，并且是很常见的。在这样的背景下，我们所说的文件系统一词是指在硬盘驱动器或逻辑卷上的一个分区中存储和管理用户数据所需要的结构和元数据。能够被 Linux 系统的 <code>fdisk</code> 命令识别的文件系统类型的完整列表<a href="https://www.win.tue.nl/~aeb/partitions/partition_types-1.html" target="_blank" rel="external">在此</a>，你可以感受一下 Linux 系统对许多类型的系统的高度兼容性。David Both 居住在美国北卡罗纳州的首府罗利，是一个 Linux 开源贡献者。他已经从事 IT 行业 40 余年，在 IBM 教授 OS/2 20 余年。1981 年，他在 IBM 开发了第一个关于最初的 IBM 个人电脑的培训课程。他也曾在 Red Hat 教授 RHCE 课程，也曾供职于 MCI worldcom，Cico 以及北卡罗纳州等。他已经为 Linux 开源社区工作近 20 年。</p>
<p>Linux 支持读取这么多类型的分区系统的主要目的是为了提高兼容性，从而至少能够与一些其他计算机系统的文件系统进行交互。下面列出了在 Fedora 中创建一个新的文件系统时的所有可选类型：</p>
<ul>
<li>btrfs</li>
<li><strong>cramfs</strong></li>
<li><strong>ext2</strong></li>
<li><strong>ext3</strong></li>
<li><strong>ext4</strong></li>
<li>fat</li>
<li>gfs2</li>
<li>hfsplus</li>
<li>minix</li>
<li><strong>msdos</strong></li>
<li>ntfs</li>
<li>reiserfs</li>
<li><strong>vfat</strong></li>
<li>xfs</li>
</ul>
<p>其他发行版支持创建的文件系统类型不同。比如，CentOS 6 只支持创建上表中标为黑体的文件系统类型。</p>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>在 Linux 系统上“<ruby>挂载<rt>mount</rt></ruby>”文件系统的术语是指在计算机发展的早期，磁带或可移动的磁盘组需要需要物理地挂载到一个合适的驱动器设备上。当通过物理的方式放置到驱动器上以后，操作系统会逻辑地挂载位于磁盘上的文件系统，从而操作系统、应用程序和用户才能够访问文件系统中的内容。</p>
<p>一个挂载点简单的来说就是一个目录，就像任何其它目录一样，是作为 root 文件系统的一部分创建的。所以，比如，home 文件系统是挂载在目录 <code>/home</code> 下。文件系统可以被挂载到其他非 root 文件系统的挂载点上，但是这并不常见。</p>
<p>在 Linux 系统启动阶段的最初阶段，root 文件系统就会被挂载到 root 目录下（<code>/</code>）。其它文件系统在之后通过 SystemV 下的 <code>rc</code> 或更新一些的 Linux 发行版中的 <code>systemd</code> 等 Linux 启动程序挂载。在启动进程中文件系统的挂载是由 <code>/etc/fstab</code> 配置文件管理的。一个简单的记忆方法是，fstab 代表“<ruby>文件系统表<rt>file system table</rt></ruby>”，它包含了需要挂载的文件系统的列表，这些文件系统均指定了挂载点，以及针对特定文件系统可能需要的选项。</p>
<p>使用 <code>mount</code> 命令可以把文件系统挂载到一个已有的目录/挂载点上。通常情况下，任何作为挂载点的目录都应该是空的且不包含任何其他文件。Linux 系统不会阻止用户挂载一个已被挂载了文件系统的目录或将文件系统挂载到一个包含文件的目录上。如果你将文件系统挂载到一个已有的目录或文件系统上，那么其原始内容将会被隐藏，只有新挂载的文件系统的内容是可见的。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我希望通过这篇文章，阐明了围绕文件系统这个术语的一些可能的模糊之处。我花费了很长的时间，以及在一个良师的帮助下才真正理解和欣赏到 Linux 文件系统的复杂性、优雅性和功能以及它的全部含义。</p>
<p>如果你有任何问题，请写到下面的评论中，我会尽力来回答它们。</p>
<h3 id="下个月"><a href="#下个月" class="headerlink" title="下个月"></a>下个月</h3><p>Linux 的另一个重要概念是：<a href="https://opensource.com/life/15/9/everything-is-a-file" target="_blank" rel="external">万物皆为文件</a>。这个概念对用户和系统管理员来说有一些有趣和重要的实际应用。当我说完这个理由之后，你可能会想阅读我的文章：<a href="https://opensource.com/life/15/9/everything-is-a-file" target="_blank" rel="external">万物皆为文件</a>，这篇文章会在我下个月计划写的关于 <code>/dev</code> 目录的文章之前写完。（LCTT 译注，也可参阅<a href="https://linux.cn/article-7669-1.html" target="_blank" rel="external">这篇</a>）</p>
<p>（题图 : 原始图片来自 Rikki Endsley. <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="external">CC BY-SA 4.0</a>）</p>
<hr>
<p>via: <a href="https://opensource.com/life/16/10/introduction-linux-filesystems" target="_blank" rel="external">https://opensource.com/life/16/10/introduction-linux-filesystems</a></p>
<p>作者：<a href="https://opensource.com/users/dboth" target="_blank" rel="external">David Both</a><br>译者：<a href="https://github.com/ucasFL" target="_blank" rel="external">ucasFL</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/community-penguins-osdc-lead.png?itok=BmqsAF4A&quot; alt=&quot;Introduction to Linux filesystems&quot; title=&quot;Introduction to Linux filesystems&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文旨在高屋建瓴地来讨论 Linux 文件系统概念，而不是对某种特定的文件系统，比如 EXT4 是如何工作的进行具体的描述。另外，本文也不是一个文件系统命令的教程。&lt;/p&gt;
&lt;p&gt;每台通用计算机都需要将各种数据存储在硬盘驱动器（HDD）或其他类似设备上，比如 USB 存储器。这样做有两个原因。首先，当计算机关闭以后，内存（RAM）会失去存于它里面的内容。尽管存在非易失类型的 RAM，在计算机断电以后还能把数据存储下来（比如采用 USB 闪存和固态硬盘的闪存），但是，闪存和标准的、易失性的 RAM，比如 DDR3 以及其他相似类型的 RAM 相比，要贵很多。&lt;/p&gt;
&lt;p&gt;数据需要存储在硬盘驱动上的另一个原因是，即使是标准的 RAM 也要比普通硬盘贵得多。尽管 RAM 和硬盘的价格都在迅速下降，但是 RAM 的价格依旧在以字节为单位来计算。让我们进行一个以字节为单位的快速计算：基于 16 GB 大的 RAM 的价格和 2 TB 大的硬盘驱动的价格。计算显示 RAM 的价格大约比硬盘驱动贵 71 倍。今天，一个典型的 RAM 的价格大约是 0.000000004373750 美元/每字节。&lt;/p&gt;
&lt;p&gt;直观的展示一下在很久以前 RAM 的价格，在计算机发展的非常早的时期，其中一种类型的 RAM 是基于在 CRT 屏幕上的点。这种 RAM 非常昂贵，大约 1 美元/每字节。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ucasfl.me/categories/Linux/"/>
    
    
      <category term="FileSystem Linux" scheme="http://ucasfl.me/tags/FileSystem-Linux/"/>
    
  </entry>
  
  <entry>
    <title>C 语言中变量的段</title>
    <link href="http://ucasfl.me/2017/09/12/the-Section-of-Variables/"/>
    <id>http://ucasfl.me/2017/09/12/the-Section-of-Variables/</id>
    <published>2017-09-12T02:16:42.000Z</published>
    <updated>2017-09-12T02:27:19.318Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 C 语言中，不同的变量位于不同的段，下面进行简单分析。</p>
<p>看下面一个简单的 C 程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">char</span> *myname=<span class="string">"Bao Yungang"</span>;</div><div class="line"><span class="keyword">char</span> gdata[<span class="number">128</span>];</div><div class="line"><span class="keyword">char</span> bdata[<span class="number">16</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</div><div class="line">main() &#123;</div><div class="line">	<span class="keyword">char</span> * ldata[<span class="number">16</span>];	</div><div class="line">	<span class="keyword">char</span> * ddata;</div><div class="line"></div><div class="line">	ddata = <span class="built_in">malloc</span>(<span class="number">16</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"myname:%llX\n"</span>, myname);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"main: %llX\n"</span>, main);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"gdata: %llX\nbdata:%llX\nldata:%llx\n&amp;ddata:%llx\nddata: %llx\n"</span>,</div><div class="line">		gdata,bdata,ldata,&amp;ddata,ddata);</div><div class="line">	<span class="built_in">free</span>(ddata);</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们分析一下程序中出现的变量所位于的段。</p>
<a id="more"></a>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先，根据所学知识进行分析：</p>
<ul>
<li><code>myname</code> 变量是一个全局变量，并且进行了初始化，指向一个字符串常量。因此，<code>myname</code> 变量本身位于<em>数据段：</em><code>.data</code></li>
<li><code>myname</code>所<strong>指向的字符串</strong>是一个字符串常量，根据 C 语言知识，是只读的，所以应位于<em>只读数据段：</em><code>.rodata</code></li>
<li><code>gdata</code>是一个为进行初始化的全局变量，因此位于<em>BSS段（Block Started by Symbol）</em>。</li>
<li><code>bdata</code>和<code>myname</code>一样是初始化了的全局变量，因此位于数据段。</li>
<li><code>ldata</code>是一个<code>main</code>函数中的局部变量，因此位于<em>栈中。</em></li>
<li><code>ddata</code>变量自身也是<code>main</code>函数中的一个局部变量，因此也位于<em>栈中。</em></li>
<li><code>ddata</code>所<strong>指向的内存空间</strong>是通过<code>malloc</code>函数动态分配的，因此位于<em>堆中。</em></li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>下面，通过<code>objdump</code>来进行验证：</p>
<p>首先，使用<code>gcc</code>来编译源程序(Ubuntu 16.04.4 + gcc  5.4.0)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -save-temps addr_space.c</div></pre></td></tr></table></figure>
<p>通过添加 <code>-save-temps</code>选项来生成中间文件。</p>
<p>下面，使用 <code>objdump</code> 来查看段信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objdump -D ./a.out</div></pre></td></tr></table></figure>
<p>通过<code>-D</code>选项显示出所有段的内容。</p>
<ul>
<li>首先看<code>bdata</code> 和<code>myname</code> ，我们可以直接在 <code>.data</code> 段看到：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Disassembly of section .data:</div><div class="line"></div><div class="line">0000000000601040 &lt;__data_start&gt;:</div><div class="line">	...</div><div class="line"></div><div class="line">0000000000601048 &lt;__dso_handle&gt;:</div><div class="line">	...</div><div class="line"></div><div class="line">0000000000601050 &lt;myname&gt;:</div><div class="line">  601050:	68 07 40 00 00       	pushq  $0x4007</div><div class="line">	...</div><div class="line"></div><div class="line">0000000000601060 &lt;bdata&gt;:</div><div class="line">  601060:	01 02                	add    %eax,(%rdx)</div><div class="line">  601062:	03 04 00             	add    (%rax,%rax,1),%eax</div><div class="line">	...</div></pre></td></tr></table></figure>
<ul>
<li>对于 <code>gdata</code> ，也可以直接在 <code>.bss</code> 段看到：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Disassembly of section .bss:</div><div class="line"></div><div class="line">0000000000601080 &lt;completed.7585&gt;:</div><div class="line">	...</div><div class="line"></div><div class="line">00000000006010a0 &lt;gdata&gt;:</div><div class="line">	...</div></pre></td></tr></table></figure>
<ul>
<li>下面看<code>myname</code> 所指向的字符串常量。</li>
</ul>
<p>首先，运行程序，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">myname:400768</div><div class="line">main: 400626</div><div class="line">gdata: 6010A0</div><div class="line">bdata:601060</div><div class="line">ldata:7ffc84068960</div><div class="line">ddata:1490010</div></pre></td></tr></table></figure>
<p>由运行结果知，<code>myname</code>的值为 400768，它即为 <code>myname</code>所指向的字符串常量的地址。然后我们在 <code>objdump</code>的输出内容中搜索该地址，得到它位于 <code>.rodata</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">Disassembly of section .rodata:</div><div class="line"></div><div class="line">0000000000400760 &lt;_IO_stdin_used&gt;:</div><div class="line">  400760:	01 00                	add    %eax,(%rax)</div><div class="line">  400762:	02 00                	add    (%rax),%al</div><div class="line">  400764:	00 00                	add    %al,(%rax)</div><div class="line">  400766:	00 00                	add    %al,(%rax)</div><div class="line">  400768:	42 61                	rex.X (bad) </div><div class="line">  40076a:	6f                   	outsl  %ds:(%rsi),(%dx)</div><div class="line">  40076b:	20 59 75             	and    %bl,0x75(%rcx)</div><div class="line">  40076e:	6e                   	outsb  %ds:(%rsi),(%dx)</div><div class="line">  40076f:	67 61                	addr32 (bad) </div><div class="line">  400771:	6e                   	outsb  %ds:(%rsi),(%dx)</div><div class="line">  400772:	67 00 6d 79          	add    %ch,0x79(%ebp)</div><div class="line">  400776:	6e                   	outsb  %ds:(%rsi),(%dx)</div><div class="line">  400777:	61                   	(bad)  </div><div class="line">  400778:	6d                   	insl   (%dx),%es:(%rdi)</div><div class="line">  400779:	65 3a 25 6c 6c 58 0a 	cmp    %gs:0xa586c6c(%rip),%ah        # a9873ec &lt;_end+0xa3862cc&gt;</div><div class="line">  400780:	00 6d 61             	add    %ch,0x61(%rbp)</div><div class="line">  400783:	69 6e 3a 20 25 6c 6c 	imul   $0x6c6c2520,0x3a(%rsi),%ebp</div><div class="line">  40078a:	58                   	pop    %rax</div><div class="line">  40078b:	0a 00                	or     (%rax),%al</div><div class="line">  40078d:	00 00                	add    %al,(%rax)</div><div class="line">  40078f:	00 67 64             	add    %ah,0x64(%rdi)</div><div class="line">  400792:	61                   	(bad)  </div><div class="line">  400793:	74 61                	je     4007f6 &lt;__GNU_EH_FRAME_HDR+0x36&gt;</div><div class="line">  400795:	3a 20                	cmp    (%rax),%ah</div><div class="line">  400797:	25 6c 6c 58 0a       	and    $0xa586c6c,%eax</div><div class="line">  40079c:	62                   	(bad)  </div><div class="line">  40079d:	64 61                	fs (bad) </div><div class="line">  40079f:	74 61                	je     400802 &lt;__GNU_EH_FRAME_HDR+0x42&gt;</div><div class="line">  4007a1:	3a 25 6c 6c 58 0a    	cmp    0xa586c6c(%rip),%ah        # a987413 &lt;_end+0xa3862f3&gt;</div><div class="line">  4007a7:	6c                   	insb   (%dx),%es:(%rdi)</div><div class="line">  4007a8:	64 61                	fs (bad) </div><div class="line">  4007aa:	74 61                	je     40080d &lt;__GNU_EH_FRAME_HDR+0x4d&gt;</div><div class="line">  4007ac:	3a 25 6c 6c 78 0a    	cmp    0xa786c6c(%rip),%ah        # ab8741e &lt;_end+0xa5862fe&gt;</div><div class="line">  4007b2:	64 64 61             	fs fs (bad) </div><div class="line">  4007b5:	74 61                	je     400818 &lt;__GNU_EH_FRAME_HDR+0x58&gt;</div><div class="line">  4007b7:	3a 25 6c 6c 78 0a    	cmp    0xa786c6c(%rip),%ah        # ab87429 &lt;_end+0xa586309&gt;</div><div class="line">	...</div></pre></td></tr></table></figure>
<p>因此，说明 <code>myname</code>指向的字符串常量位于 <code>.rodata</code> 中。事实上，看中间一栏，从 400768 开始，到 400772 的第一个数结束，其中的内容 <code>42 61 6f 20 59 75 6e 67 61 6e 67</code>对应的 ASCII 码就是字符串 “Bao Yungang” 。</p>
<ul>
<li>对于 <code>ldata</code> 和 <code>ddata</code> 以及 <code>ddata</code> 所指向的分配空间，很难直接从 <code>objdump</code> 的输出中看出来。我们再把 <code>ddata</code>变量本身的地址也打印出来：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">myname:400768</div><div class="line">main: 400626</div><div class="line">gdata: 6010A0</div><div class="line">bdata:601060</div><div class="line">ldata:7ffe92607930</div><div class="line">&amp;ddata:7ffe92607928</div><div class="line">ddata: 221a010</div></pre></td></tr></table></figure>
<p>我们看到，<code>ldata</code>和<code>ddata</code>的地址非常大，而 <code>ddata</code>所指向的分配空间的地址相对来说要小很多，这其实也一定程度上验证了我们的结论，根据我们已知的结论，在程序执行过程中，函数中的局部变量是在函数压栈以后，在栈中分配的，而 <code>malloc</code> 函数分配的空间则是在堆中进行分配的，而栈是从上往下长（高地址到低地址），堆则相反，是从下往上长（低地址到高地址），因此，栈中的变量地址较大，而堆中的则较小，所以，程序运行结果与之相符。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在 C 语言中，不同的变量位于不同的段，下面进行简单分析。&lt;/p&gt;
&lt;p&gt;看下面一个简单的 C 程序：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *myname=&lt;span class=&quot;string&quot;&gt;&quot;Bao Yungang&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; gdata[&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; bdata[&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;main() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * ldata[&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;];	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * ddata;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	ddata = &lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;myname:%llX\n&quot;&lt;/span&gt;, myname);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;main: %llX\n&quot;&lt;/span&gt;, main);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;gdata: %llX\nbdata:%llX\nldata:%llx\n&amp;amp;ddata:%llx\nddata: %llx\n&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		gdata,bdata,ldata,&amp;amp;ddata,ddata);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(ddata);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们分析一下程序中出现的变量所位于的段。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://ucasfl.me/categories/C-C/"/>
    
    
      <category term="C Section" scheme="http://ucasfl.me/tags/C-Section/"/>
    
  </entry>
  
  <entry>
    <title>编译器简介： 在 Siri 前时代如何与计算机对话</title>
    <link href="http://ucasfl.me/2017/09/12/Introduction-to-Compiler/"/>
    <id>http://ucasfl.me/2017/09/12/Introduction-to-Compiler/</id>
    <published>2017-09-12T02:16:15.000Z</published>
    <updated>2017-09-12T02:25:39.505Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pbs.twimg.com/media/C_5qf8aXkAAvSXC.jpg" alt="了解在编译器的世界里前端和后端的新意义"></p>
<p>简单说来，一个<ruby>编译器<rt>compiler</rt></ruby>不过是一个可以翻译其他程序的程序。传统的编译器可以把源代码翻译成你的计算机能够理解的可执行机器代码。（一些编译器将源代码翻译成别的程序语言，这样的编译器称为源到源翻译器或<ruby>转化器<rt>transpilers</rt></ruby>。）<a href="http://llvm.org/" target="_blank" rel="external">LLVM</a> 是一个广泛使用的编译器项目，包含许多模块化的编译工具。</p>
<p>传统的编译器设计包含三个部分：</p>
<p><img src="https://nicoleorchard.com/img/blog/compilers/compiler1.jpg" alt=""></p>
<ul>
<li><ruby>前端<rt>Frontend</rt></ruby>将源代码翻译为<ruby>中间表示<rt>intermediate representation </rt></ruby> (IR)* 。<a href="http://clang.llvm.org/" target="_blank" rel="external">clang</a> 是 LLVM 中用于 C 家族语言的前端工具。</li>
<li><ruby>优化器<rt>Optimizer</rt></ruby>分析 IR 然后将其转化为更高效的形式。<a href="http://llvm.org/docs/CommandGuide/opt.html" target="_blank" rel="external">opt</a> 是 LLVM 的优化工具。</li>
<li><ruby>后端<rt>Backend</rt></ruby>通过将 IR 映射到目标硬件指令集从而生成机器代码。<a href="http://llvm.org/docs/CommandGuide/llc.html" target="_blank" rel="external">llc</a> 是 LLVM 的后端工具。</li>
</ul>
<p>注：LLVM 的 IR 是一种和汇编类似的低级语言。然而，它抽离了特定硬件信息。</p>
<a id="more"></a>
<h3 id="Hello-Compiler"><a href="#Hello-Compiler" class="headerlink" title="Hello, Compiler"></a>Hello, Compiler</h3><p>下面是一个打印 “Hello, Compiler!” 到标准输出的简单 C 程序。C 语法是人类可读的，但是计算机却不能理解，不知道该程序要干什么。我将通过三个编译阶段使该程序变成机器可执行的程序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// compile_me.c</span></div><div class="line"><span class="comment">// Wave to the compiler. The world can wait.</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Hello, Compiler!\n"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>正如我在上面所提到的，<code>clang</code> 是 LLVM 中用于 C 家族语言的前端工具。Clang 包含 <ruby>C 预处理器<rt>C preprocessor</rt></ruby>、<ruby>词法分析器<rt>lexer</rt></ruby>、<ruby>语法解析器<rt>parser</rt></ruby>、<ruby>语义分析器<rt>semantic analyzer</rt></ruby>和 <ruby>IR 生成器<rt>IR generator</rt></ruby>。</p>
<p><strong>C 预处理器</strong>在将源程序翻译成 IR 前修改源程序。预处理器处理外部包含文件，比如上面的 <code>#include &lt;stdio.h&gt;</code>。 它将会把这一行替换为 <code>stdio.h</code> C 标准库文件的完整内容，其中包含 <code>printf</code> 函数的声明。</p>
<p>通过运行下面的命令来查看预处理步骤的输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">clang</span> <span class="selector-tag">-E</span> <span class="selector-tag">compile_me</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">preprocessed</span><span class="selector-class">.i</span></div></pre></td></tr></table></figure>
<p><strong>词法分析器</strong>（或<ruby>扫描器<rt>scanner</rt></ruby>或<ruby>分词器<rt>tokenizer</rt></ruby>）将一串字符转化为一串单词。每一个单词或<ruby>记号<rt>token</rt></ruby>，被归并到五种语法类别之一：标点符号、关键字、标识符、文字或注释。</p>
<p>compile_me.c 的分词过程：</p>
<p><img src="https://nicoleorchard.com/img/blog/compilers/lexer.jpg" alt=""></p>
<p><strong>语法分析器</strong>确定源程序中的单词流是否组成了合法的句子。在分析记号流的语法后，它会输出一个<ruby>抽象语法树<rt>abstract syntax tree</rt></ruby>（AST）。Clang 的 AST 中的节点表示声明、语句和类型。</p>
<p>compile_me.c 的语法树：</p>
<p><img src="https://nicoleorchard.com/img/blog/compilers/tree.jpg" alt=""></p>
<p><strong>语义分析器</strong>会遍历抽象语法树，从而确定代码语句是否有正确意义。这个阶段会检查类型错误。如果 <code>compile_me.c</code> 的 main 函数返回 <code>&quot;zero&quot;</code>而不是 <code>0</code>， 那么语义分析器将会抛出一个错误，因为 <code>&quot;zero&quot;</code> 不是 <code>int</code> 类型。</p>
<p><strong>IR 生成器</strong>将抽象语法树翻译为 IR。</p>
<p>对 compile_me.c 运行 clang 来生成 LLVM IR：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">clang</span> <span class="selector-tag">-S</span> <span class="selector-tag">-emit-llvm</span> <span class="selector-tag">-o</span> <span class="selector-tag">llvm_ir</span><span class="selector-class">.ll</span> <span class="selector-tag">compile_me</span><span class="selector-class">.c</span></div></pre></td></tr></table></figure>
<p>在 <code>llvm_ir.ll</code> 中的 main 函数：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">; llvm_ir.ll</span></div><div class="line"><span class="title">@.str</span> = <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">18</span> <span class="keyword">x</span> <span class="keyword">i8</span>] <span class="keyword">c</span><span class="string">"Hello, Compiler!\0A\00"</span>, <span class="keyword">align</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">define</span> <span class="keyword">i32</span> <span class="title">@main</span>() &#123;</div><div class="line">  <span class="symbol">%1</span> = <span class="keyword">alloca</span> <span class="keyword">i32</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- memory allocated on the stack</span></div><div class="line">  <span class="keyword">store</span> <span class="keyword">i32</span> <span class="number">0</span>, <span class="keyword">i32</span>* <span class="symbol">%1</span>, <span class="keyword">align</span> <span class="number">4</span></div><div class="line">  <span class="symbol">%2</span> = <span class="keyword">call</span> <span class="keyword">i32</span> (<span class="keyword">i8</span>*, ...) <span class="title">@printf</span>(<span class="keyword">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">18</span> <span class="keyword">x</span> <span class="keyword">i8</span>], [<span class="number">18</span> <span class="keyword">x</span> <span class="keyword">i8</span>]* <span class="title">@.str</span>, <span class="keyword">i32</span> <span class="number">0</span>, <span class="keyword">i32</span> <span class="number">0</span>))</div><div class="line">  <span class="keyword">ret</span> <span class="keyword">i32</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">declare</span> <span class="keyword">i32</span> <span class="title">@printf</span>(<span class="keyword">i8</span>*, ...)</div></pre></td></tr></table></figure>
<h4 id="优化程序"><a href="#优化程序" class="headerlink" title="优化程序"></a>优化程序</h4><p>优化程序的工作是基于其对程序的运行时行为的理解来提高代码效率。优化程序将 IR 作为输入，然后生成改进后的 IR 作为输出。LLVM 的优化工具 <code>opt</code> 将会通过标记 <code>-O2</code>（大写字母 <code>o</code>，数字 2）来优化处理器速度，通过标记 <code>Os</code>（大写字母 <code>o</code>，小写字母 <code>s</code>）来减少指令数目。</p>
<p>看一看上面的前端工具生成的 LLVM IR 代码和运行下面的命令生成的结果之间的区别：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">opt</span> -O2 -S llvm_ir.<span class="keyword">ll</span> -<span class="keyword">o</span> optimized.<span class="keyword">ll</span></div></pre></td></tr></table></figure>
<p>在 <code>optimized.ll</code> 中的 main 函数：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">optimized.ll</div><div class="line"></div><div class="line"><span class="title">@str</span> = <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">17</span> <span class="keyword">x</span> <span class="keyword">i8</span>] <span class="keyword">c</span><span class="string">"Hello, Compiler!\00"</span></div><div class="line"></div><div class="line"><span class="keyword">define</span> <span class="keyword">i32</span> <span class="title">@main</span>() &#123;</div><div class="line">  <span class="symbol">%puts</span> = <span class="keyword">tail</span> <span class="keyword">call</span> <span class="keyword">i32</span> <span class="title">@puts</span>(<span class="keyword">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">17</span> <span class="keyword">x</span> <span class="keyword">i8</span>], [<span class="number">17</span> <span class="keyword">x</span> <span class="keyword">i8</span>]* <span class="title">@str</span>, <span class="keyword">i64</span> <span class="number">0</span>, <span class="keyword">i64</span> <span class="number">0</span>))</div><div class="line">  <span class="keyword">ret</span> <span class="keyword">i32</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">declare</span> <span class="keyword">i32</span> <span class="title">@puts</span>(<span class="keyword">i8</span>* <span class="keyword">nocapture</span> <span class="keyword">readonly</span>)</div></pre></td></tr></table></figure>
<p>优化后的版本中， main 函数没有在栈中分配内存，因为它不使用任何内存。优化后的代码中调用 <code>puts</code> 函数而不是 <code>printf</code> 函数，因为程序中并没有使用 <code>printf</code> 函数的格式化功能。</p>
<p>当然，优化程序不仅仅知道何时可以把 <code>printf</code> 函数用 <code>puts</code> 函数代替。优化程序也能展开循环并内联简单计算的结果。考虑下面的程序，它将两个整数相加并打印出结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// add.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>, c = a + b;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%i + %i = %i\n"</span>, a, b, c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是未优化的 LLVM IR：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="title">@.str</span> = <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">14</span> <span class="keyword">x</span> <span class="keyword">i8</span>] <span class="keyword">c</span><span class="string">"%i + %i = %i\0A\00"</span>, <span class="keyword">align</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">define</span> <span class="keyword">i32</span> <span class="title">@main</span>() &#123;</div><div class="line">  <span class="symbol">%1</span> = <span class="keyword">alloca</span> <span class="keyword">i32</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- allocate stack space for var a</span></div><div class="line">  <span class="symbol">%2</span> = <span class="keyword">alloca</span> <span class="keyword">i32</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- allocate stack space for var b</span></div><div class="line">  <span class="symbol">%3</span> = <span class="keyword">alloca</span> <span class="keyword">i32</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- allocate stack space for var c</span></div><div class="line">  <span class="keyword">store</span> <span class="keyword">i32</span> <span class="number">5</span>, <span class="keyword">i32</span>* <span class="symbol">%1</span>, <span class="keyword">align</span> <span class="number">4</span>  <span class="comment">; &lt;- store 5 at memory location %1</span></div><div class="line">  <span class="keyword">store</span> <span class="keyword">i32</span> <span class="number">10</span>, <span class="keyword">i32</span>* <span class="symbol">%2</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- store 10 at memory location %2</span></div><div class="line">  <span class="symbol">%4</span> = <span class="keyword">load</span> <span class="keyword">i32</span>, <span class="keyword">i32</span>* <span class="symbol">%1</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- load the value at memory address %1 into register %4</span></div><div class="line">  <span class="symbol">%5</span> = <span class="keyword">load</span> <span class="keyword">i32</span>, <span class="keyword">i32</span>* <span class="symbol">%2</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- load the value at memory address %2 into register %5</span></div><div class="line">  <span class="symbol">%6</span> = <span class="keyword">add</span> <span class="keyword">nsw</span> <span class="keyword">i32</span> <span class="symbol">%4</span>, <span class="symbol">%5</span> <span class="comment">; &lt;- add the values in registers %4 and %5\. put the result in register %6</span></div><div class="line">  <span class="keyword">store</span> <span class="keyword">i32</span> <span class="symbol">%6</span>, <span class="keyword">i32</span>* <span class="symbol">%3</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- put the value of register %6 into memory address %3</span></div><div class="line">  <span class="symbol">%7</span> = <span class="keyword">load</span> <span class="keyword">i32</span>, <span class="keyword">i32</span>* <span class="symbol">%1</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- load the value at memory address %1 into register %7</span></div><div class="line">  <span class="symbol">%8</span> = <span class="keyword">load</span> <span class="keyword">i32</span>, <span class="keyword">i32</span>* <span class="symbol">%2</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- load the value at memory address %2 into register %8</span></div><div class="line">  <span class="symbol">%9</span> = <span class="keyword">load</span> <span class="keyword">i32</span>, <span class="keyword">i32</span>* <span class="symbol">%3</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- load the value at memory address %3 into register %9</span></div><div class="line">  <span class="symbol">%10</span> = <span class="keyword">call</span> <span class="keyword">i32</span> (<span class="keyword">i8</span>*, ...) <span class="title">@printf</span>(<span class="keyword">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">14</span> <span class="keyword">x</span> <span class="keyword">i8</span>], [<span class="number">14</span> <span class="keyword">x</span> <span class="keyword">i8</span>]* <span class="title">@.str</span>, <span class="keyword">i32</span> <span class="number">0</span>, <span class="keyword">i32</span> <span class="number">0</span>), <span class="keyword">i32</span> <span class="symbol">%7</span>, <span class="keyword">i32</span> <span class="symbol">%8</span>, <span class="keyword">i32</span> <span class="symbol">%9</span>)</div><div class="line">  <span class="keyword">ret</span> <span class="keyword">i32</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">declare</span> <span class="keyword">i32</span> <span class="title">@printf</span>(<span class="keyword">i8</span>*, ...)</div></pre></td></tr></table></figure>
<p>下面是优化后的 LLVM IR：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="title">@.str</span> = <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">14</span> <span class="keyword">x</span> <span class="keyword">i8</span>] <span class="keyword">c</span><span class="string">"%i + %i = %i\0A\00"</span>, <span class="keyword">align</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">define</span> <span class="keyword">i32</span> <span class="title">@main</span>() &#123;</div><div class="line">  <span class="symbol">%1</span> = <span class="keyword">tail</span> <span class="keyword">call</span> <span class="keyword">i32</span> (<span class="keyword">i8</span>*, ...) <span class="title">@printf</span>(<span class="keyword">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">14</span> <span class="keyword">x</span> <span class="keyword">i8</span>], [<span class="number">14</span> <span class="keyword">x</span> <span class="keyword">i8</span>]* <span class="title">@.str</span>, <span class="keyword">i64</span> <span class="number">0</span>, <span class="keyword">i64</span> <span class="number">0</span>), <span class="keyword">i32</span> <span class="number">5</span>, <span class="keyword">i32</span> <span class="number">10</span>, <span class="keyword">i32</span> <span class="number">15</span>)</div><div class="line">  <span class="keyword">ret</span> <span class="keyword">i32</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">declare</span> <span class="keyword">i32</span> <span class="title">@printf</span>(<span class="keyword">i8</span>* <span class="keyword">nocapture</span> <span class="keyword">readonly</span>, ...)</div></pre></td></tr></table></figure>
<p>优化后的 main 函数本质上是未优化版本的第 17 行和 18 行，伴有变量值内联。<code>opt</code> 计算加法，因为所有的变量都是常数。很酷吧，对不对？</p>
<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>LLVM 的后端工具是 <code>llc</code>。它分三个阶段将 LLVM IR 作为输入生成机器代码。</p>
<ul>
<li><strong>指令选择</strong>是将 IR 指令映射到目标机器的指令集。这个步骤使用虚拟寄存器的无限名字空间。</li>
<li><strong>寄存器分配</strong>是将虚拟寄存器映射到目标体系结构的实际寄存器。我的 CPU 是 x86 结构，它只有 16 个寄存器。然而，编译器将会尽可能少的使用寄存器。</li>
<li><strong>指令安排</strong>是重排操作，从而反映出目标机器的性能约束。</li>
</ul>
<p>运行下面这个命令将会产生一些机器代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">llc</span> <span class="selector-tag">-o</span> <span class="selector-tag">compiled-assembly</span><span class="selector-class">.s</span> <span class="selector-tag">optimized</span><span class="selector-class">.ll</span></div></pre></td></tr></table></figure>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">_main:</div><div class="line">	pushq	<span class="built_in">%rbp</span></div><div class="line">	movq	<span class="built_in">%rsp</span>, <span class="built_in">%rbp</span></div><div class="line">	leaq	L_str(<span class="built_in">%rip</span>), <span class="built_in">%rdi</span></div><div class="line">	callq	_puts</div><div class="line">	xorl	<span class="built_in">%eax</span>, <span class="built_in">%eax</span></div><div class="line">	popq	<span class="built_in">%rbp</span></div><div class="line">	retq</div><div class="line">L_str:</div><div class="line">	.asciz	<span class="string">"Hello, Compiler!"</span></div></pre></td></tr></table></figure>
<p>这个程序是 x86 汇编语言，它是计算机所说的语言，并具有人类可读语法。某些人最后也许能理解我。</p>
<hr>
<p>相关资源：</p>
<ol>
<li><a href="https://www.amazon.com/Engineering-Compiler-Second-Keith-Cooper/dp/012088478X" target="_blank" rel="external">设计一个编译器</a></li>
<li><a href="https://www.amazon.com/Getting-Started-LLVM-Core-Libraries/dp/1782166920" target="_blank" rel="external">开始探索 LLVM 核心库</a></li>
</ol>
<hr>
<p>via: <a href="https://nicoleorchard.com/blog/compilers" target="_blank" rel="external">https://nicoleorchard.com/blog/compilers</a></p>
<p>作者：<a href="https://nicoleorchard.com/" target="_blank" rel="external">Nicole Orchard</a><br>译者：<a href="https://github.com/ucasFL" target="_blank" rel="external">ucasFL</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://pbs.twimg.com/media/C_5qf8aXkAAvSXC.jpg&quot; alt=&quot;了解在编译器的世界里前端和后端的新意义&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单说来，一个&lt;ruby&gt;编译器&lt;rt&gt;compiler&lt;/rt&gt;&lt;/ruby&gt;不过是一个可以翻译其他程序的程序。传统的编译器可以把源代码翻译成你的计算机能够理解的可执行机器代码。（一些编译器将源代码翻译成别的程序语言，这样的编译器称为源到源翻译器或&lt;ruby&gt;转化器&lt;rt&gt;transpilers&lt;/rt&gt;&lt;/ruby&gt;。）&lt;a href=&quot;http://llvm.org/&quot;&gt;LLVM&lt;/a&gt; 是一个广泛使用的编译器项目，包含许多模块化的编译工具。&lt;/p&gt;
&lt;p&gt;传统的编译器设计包含三个部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nicoleorchard.com/img/blog/compilers/compiler1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ruby&gt;前端&lt;rt&gt;Frontend&lt;/rt&gt;&lt;/ruby&gt;将源代码翻译为&lt;ruby&gt;中间表示&lt;rt&gt;intermediate representation &lt;/rt&gt;&lt;/ruby&gt; (IR)* 。&lt;a href=&quot;http://clang.llvm.org/&quot;&gt;clang&lt;/a&gt; 是 LLVM 中用于 C 家族语言的前端工具。&lt;/li&gt;
&lt;li&gt;&lt;ruby&gt;优化器&lt;rt&gt;Optimizer&lt;/rt&gt;&lt;/ruby&gt;分析 IR 然后将其转化为更高效的形式。&lt;a href=&quot;http://llvm.org/docs/CommandGuide/opt.html&quot;&gt;opt&lt;/a&gt; 是 LLVM 的优化工具。&lt;/li&gt;
&lt;li&gt;&lt;ruby&gt;后端&lt;rt&gt;Backend&lt;/rt&gt;&lt;/ruby&gt;通过将 IR 映射到目标硬件指令集从而生成机器代码。&lt;a href=&quot;http://llvm.org/docs/CommandGuide/llc.html&quot;&gt;llc&lt;/a&gt; 是 LLVM 的后端工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：LLVM 的 IR 是一种和汇编类似的低级语言。然而，它抽离了特定硬件信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Compiler" scheme="http://ucasfl.me/categories/Compiler/"/>
    
    
      <category term="Compiler LLVM" scheme="http://ucasfl.me/tags/Compiler-LLVM/"/>
    
  </entry>
  
  <entry>
    <title>Npm 安装 Hexo 失败的解决办法</title>
    <link href="http://ucasfl.me/2017/09/02/Fix-Error-With-Install-Hexo/"/>
    <id>http://ucasfl.me/2017/09/02/Fix-Error-With-Install-Hexo/</id>
    <published>2017-09-02T05:12:32.000Z</published>
    <updated>2017-09-04T08:28:14.369Z</updated>
    
    <content type="html"><![CDATA[<p>用 npm 安装 Hexo 时候出现错误，使用 sudo 安装依旧不行。</p>
<p>错误如下：</p>
<a id="more"></a>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/usr/local/bin/hexo<span class="function"> -&gt;</span> /usr/local/lib/node_modules/hexo-cli/bin/hexo</div><div class="line"></div><div class="line">&gt; dtrace-provider@<span class="number">0.8</span>.<span class="number">5</span> install /usr/local/lib/node_modules/hexo-cli/node_modules/dtrace-provider</div><div class="line">&gt; node scripts/install.js</div><div class="line"></div><div class="line"></div><div class="line">&gt; hexo-util@<span class="number">0.6</span>.<span class="number">1</span> postinstall /usr/local/lib/node_modules/hexo-cli/node_modules/hexo-util</div><div class="line">&gt; <span class="built_in">npm</span> run build:highlight</div><div class="line"></div><div class="line"></div><div class="line">&gt; hexo-util@<span class="number">0.6</span>.<span class="number">1</span> build:highlight /usr/local/lib/node_modules/hexo-cli/node_modules/hexo-util</div><div class="line">&gt; node scripts/build_highlight_alias.js &gt; highlight_alias.json</div><div class="line"></div><div class="line">sh: <span class="number">1</span>: cannot create highlight_alias.json: Permission denied</div><div class="line"><span class="built_in">npm</span> ERR! code ELIFECYCLE</div><div class="line"><span class="built_in">npm</span> ERR! errno <span class="number">2</span></div><div class="line"><span class="built_in">npm</span> ERR! hexo-util@<span class="number">0.6</span>.<span class="number">1</span> build:highlight: `node scripts/build_highlight_alias.js &gt; highlight_alias.json`</div><div class="line"><span class="built_in">npm</span> ERR! Exit status <span class="number">2</span></div><div class="line"><span class="built_in">npm</span> ERR! </div><div class="line"><span class="built_in">npm</span> ERR! Failed at the hexo-util@<span class="number">0.6</span>.<span class="number">1</span> build:highlight script.</div><div class="line"><span class="built_in">npm</span> ERR! This <span class="keyword">is</span> probably <span class="keyword">not</span> a problem <span class="keyword">with</span> <span class="built_in">npm</span>. There <span class="keyword">is</span> likely additional logging output above.</div><div class="line"></div><div class="line">┌──────────────────────────────────────────────────────────┐</div><div class="line">│                 <span class="built_in">npm</span> update check failed                  │</div><div class="line">│           Try running <span class="keyword">with</span> sudo <span class="keyword">or</span> get access            │</div><div class="line">│           <span class="keyword">to</span> the local update config store via           │</div><div class="line">│ sudo chown -R $USER:$(id -gn $USER) <span class="regexp">/home/fenglv/</span>.config │</div><div class="line">└──────────────────────────────────────────────────────────┘</div><div class="line"></div><div class="line"><span class="built_in">npm</span> ERR! A complete log <span class="keyword">of</span> <span class="keyword">this</span> run can be found in:</div><div class="line"><span class="built_in">npm</span> ERR!     <span class="regexp">/home/fenglv/</span>.<span class="built_in">npm</span>/_logs/<span class="number">2017</span>-<span class="number">09</span>-<span class="number">02</span>T05_00_49_566Z-debug.log</div><div class="line"><span class="built_in">npm</span> WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@<span class="number">1.1</span>.<span class="number">2</span> (node_modules/hexo-cli/node_modules/fsevents):</div><div class="line"><span class="built_in">npm</span> WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform <span class="keyword">for</span> fsevents@<span class="number">1.1</span>.<span class="number">2</span>: wanted &#123;<span class="string">"os"</span>:<span class="string">"darwin"</span>,<span class="string">"arch"</span>:<span class="string">"any"</span>&#125; (current: &#123;<span class="string">"os"</span>:<span class="string">"linux"</span>,<span class="string">"arch"</span>:<span class="string">"x64"</span>&#125;)</div><div class="line"></div><div class="line"><span class="built_in">npm</span> ERR! code ELIFECYCLE</div><div class="line"><span class="built_in">npm</span> ERR! errno <span class="number">2</span></div><div class="line"><span class="built_in">npm</span> ERR! hexo-util@<span class="number">0.6</span>.<span class="number">1</span> postinstall: `<span class="built_in">npm</span> run build:highlight`</div><div class="line"><span class="built_in">npm</span> ERR! Exit status <span class="number">2</span></div><div class="line"><span class="built_in">npm</span> ERR! </div><div class="line"><span class="built_in">npm</span> ERR! Failed at the hexo-util@<span class="number">0.6</span>.<span class="number">1</span> postinstall script.</div><div class="line"><span class="built_in">npm</span> ERR! This <span class="keyword">is</span> probably <span class="keyword">not</span> a problem <span class="keyword">with</span> <span class="built_in">npm</span>. There <span class="keyword">is</span> likely additional logging output above.</div><div class="line"></div><div class="line"><span class="built_in">npm</span> ERR! A complete log <span class="keyword">of</span> <span class="keyword">this</span> run can be found in:</div><div class="line"><span class="built_in">npm</span> ERR!     <span class="regexp">/home/fenglv/</span>.<span class="built_in">npm</span>/_logs/<span class="number">2017</span>-<span class="number">09</span>-<span class="number">02</span>T05_00_53_335Z-debug.log</div></pre></td></tr></table></figure>
<p>解决办法：参见<a href="https://docs.npmjs.com/getting-started/fixing-npm-permissions" target="_blank" rel="external">npm 官网</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chown -R <span class="variable">$USER</span> $(npm config get prefix)/&#123;lib/node_modules,bin,share&#125;</div></pre></td></tr></table></figure>
<p>问题解决。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 npm 安装 Hexo 时候出现错误，使用 sudo 安装依旧不行。&lt;/p&gt;
&lt;p&gt;错误如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://ucasfl.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://ucasfl.me/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>听说过时间表，但是你是否知道“哈希表”</title>
    <link href="http://ucasfl.me/2017/09/02/Hash-Tables/"/>
    <id>http://ucasfl.me/2017/09/02/Hash-Tables/</id>
    <published>2017-09-02T04:44:26.000Z</published>
    <updated>2017-09-02T04:55:22.911Z</updated>
    
    <content type="html"><![CDATA[<p>探索<ruby>哈希表<rt>hash table</rt></ruby>的世界并理解其底层的机制是非常有趣的，并且将会受益匪浅。所以，让我们了解它，并从头开始探索吧。</p>
<p>哈希表是许多现代软件应用程序中一种常见的数据结构。它提供了类似字典的功能，使你能够在其中执行插入、删除和删除等操作。这么说吧，比如我想找出“苹果”的定义是什么，并且我知道该定义被存储在了我定义的哈希表中。我将查询我的哈希表来得到定义。它在哈希表内的记录看起来可能像：<code>&quot;苹果&quot; =&gt; &quot;一种拥有水果之王之称的绿色水果&quot;</code>。这里，“苹果”是我的关键字，而“一种拥有水果之王之称的水果”是与之关联的值。</p>
<a id="more"></a>
<p>还有一个例子可以让我们更清楚，哈希表的内容如下：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"面包"</span> =&gt; <span class="string">"固体"</span></div><div class="line"><span class="string">"水"</span> =&gt; <span class="string">"液体"</span></div><div class="line"><span class="string">"汤"</span> =&gt; <span class="string">"液体"</span></div><div class="line"><span class="string">"玉米片"</span> =&gt; <span class="string">"固体"</span></div></pre></td></tr></table></figure>
<p>我想知道<em>面包</em>是固体还是液体，所以我将查询哈希表来获取与之相关的值，该哈希表将返回“固体”给我。现在，我们大致了解了哈希表是如何工作的。使用哈希表需要注意的另一个重要概念是每一个关键字都是唯一的。如果到了明天，我拥有一个面包奶昔（它是液体），那么我们需要更新哈希表，把“固体”改为“液体”来反映哈希表的改变。所以，我们需要添加一条记录到字典中：关键字为“面包”，对应的值为“液体”。你能发现下面的表发生了什么变化吗？（LCTT 译注：不知道这个“面包奶昔”是一种什么食物，大约是一种面包做的奶昔，总之你就理解成作者把液体的“面包奶昔”当成一种面包吧。）</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"面包"</span> =&gt; <span class="string">"液体"</span></div><div class="line"><span class="string">"水"</span> =&gt; <span class="string">"液体"</span></div><div class="line"><span class="string">"汤"</span> =&gt; <span class="string">"液体"</span></div><div class="line"><span class="string">"玉米片"</span> =&gt; <span class="string">"固体"</span></div></pre></td></tr></table></figure>
<p>没错，“面包”对应的值被更新为了“液体”。</p>
<p><strong>关键字是唯一的</strong>，我的面包不能既是液体又是固体。但是，是什么使得该数据结构与其他数据结构相比如此特殊呢？为什么不使用一个<a href="https://en.wikipedia.org/wiki/Array_data_type" target="_blank" rel="external">数组</a>来代替呢？它取决于问题的本质。对于某一个特定的问题，使用数组来描述可能会更好，因此，我们需要注意的关键点就是，<strong>我们应该选择最适合问题的数据结构</strong>。例如，如果你需要做的只是存储一个简单的杂货列表，那么使用数组会很适合。考虑下面的两个问题，两个问题的本质完全不同。</p>
<ol>
<li>我需要一个水果的列表</li>
<li>我需要一个水果的列表以及各种水果的价格（每千克）</li>
</ol>
<p>正如你在下面所看到的，用数组来存储水果的列表可能是更好的选择。但是，用哈希表来存储每一种水果的价格看起来是更好的选择。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//示例数组</div><div class="line">[<span class="string">"苹果"</span>, <span class="string">"桔子"</span>, <span class="string">"梨子"</span>, <span class="string">"葡萄"</span>]   </div><div class="line">//示例哈希表  </div><div class="line">&#123; <span class="string">"苹果"</span> : 3.05,</div><div class="line">  <span class="string">"桔子"</span> : 5.5,</div><div class="line">  <span class="string">"梨子"</span> : 8.4,</div><div class="line">  <span class="string">"葡萄"</span> : 12.4  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，有许多的机会需要<a href="https://en.wikipedia.org/wiki/Hash_table#Uses" target="_blank" rel="external">使用</a>哈希表。</p>
<h3 id="时间以及它对你的意义"><a href="#时间以及它对你的意义" class="headerlink" title="时间以及它对你的意义"></a>时间以及它对你的意义</h3><p><a href="https://www.hackerearth.com/practice/basic-programming/complexity-analysis/time-and-space-complexity/tutorial/" target="_blank" rel="external">这是对时间复杂度和空间复杂度的一个复习</a>。</p>
<p>平均情况下，在哈希表中进行搜索、插入和删除记录的时间复杂度均为 <code>O(1)</code> 。实际上，<code>O(1)</code> 读作“大 O 1”，表示常数时间。这意味着执行每一种操作的运行时间不依赖于数据集中数据的数量。我可以保证，查找、插入和删除项目均只花费常数时间，“当且仅当”哈希表的实现方式正确时。如果实现不正确，可能需要花费很慢的 <code>O(n)</code> 时间，尤其是当所有的数据都映射到了哈希表中的同一位置/点。</p>
<h3 id="构建一个好的哈希表"><a href="#构建一个好的哈希表" class="headerlink" title="构建一个好的哈希表"></a>构建一个好的哈希表</h3><p>到目前为止，我们已经知道如何使用哈希表了，但是如果我们想<strong>构建</strong>一个哈希表呢？本质上我们需要做的就是把一个字符串（比如 “狗”）映射到一个哈希代码（一个生成的数），即映射到一个数组的索引。你可能会问，为什么不直接使用索引呢？为什么要这么麻烦呢？因为通过这种方式我们可以直接查询 “狗” 并立即得到 “狗” 所在的位置，<code>String name = Array[&quot;狗&quot;] // 名字叫拉斯</code>。而使用索引查询名称时，可能出现的情况是我们不知道名称所在的索引。比如，<code>String name = Array[10] // 该名字现在叫鲍勃</code> - 那不是我的狗的名字。这就是把一个字符串映射到一个哈希代码的益处（对应于一个数组的索引而言）。我们可以通过使用模运算符和哈希表的大小来计算出数组的索引：<code>index = hash_code % table_size</code>。 </p>
<p>我们需要避免的另一种情况是两个关键字映射到同一个索引，这叫做<strong>哈希碰撞</strong>，如果哈希函数实现的不好，这很容易发生。实际上，每一个输入比输出多的哈希函数都有可能发生碰撞。通过下面的同一个函数的两个输出来展示一个简单的碰撞：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> cat_idx = hashCode(<span class="string">"猫"</span>) % table_size; <span class="comment">//cat_idx 现在等于 1</span></div><div class="line"><span class="keyword">int</span> dog_idx = hashCode(<span class="string">"狗"</span>) % table_size; <span class="comment">//dog_idx 也等于 1</span></div></pre></td></tr></table></figure>
<p>我们可以看到，现在两个数组的索引均是 1 。这样将会出现两个值相互覆盖，因为它们被写到了相同的索引中。如果我们查找 “猫” 的值，将会返回 “拉斯” ，但是这并不是我们想要的。有许多可以<a href="https://en.wikipedia.org/wiki/Hash_table#Collision_resolution" target="_blank" rel="external">解决哈希碰撞</a>的方法，但是更受欢迎的一种方法叫做<strong>链接</strong>。链接的想法就是对于数组的每一个索引位置都有一个链表，如果碰撞发生，值就被存到链表中。因此，在前面的例子中，我们将会得到我们需要的值，但是我们需要搜索数组中索引为 1 的位置上的链表。伴有链接的哈希实现需要 <code>O(1 + α)</code> 时间，其中 α 是装载因子，它可以表示为 n/k，其中 n 是哈希表中的记录数目，k 是哈希表中可用位置的数目。但是请记住，只有当你给出的关键字非常随机时，这一结论才正确（依赖于 <a href="https://en.wikipedia.org/wiki/SUHA_(computer_science" target="_blank" rel="external">SUHA</a>）。</p>
<p>这是做了一个很大的假设，因为总是有可能任何不相等的关键字都散列到同一点。这一问题的一个解决方法是去除哈希表中关键字对随机性的依赖，转而把随机性集中于关键字是如何被散列的，从而减少矛盾发生的可能性。这被称为……</p>
<h3 id="通用散列"><a href="#通用散列" class="headerlink" title="通用散列"></a>通用散列</h3><p>这个观念很简单，从<ruby>通用散列<rt>universal hash</rt></ruby>家族集合随机选择一个哈希函数 h 来计算哈希代码。换句话来说，就是选择任何一个随机的哈希函数来散列关键字。通过这种方法，两个不同的关键字的散列结果相同的可能性将非常低（LCTT 译注：原文是“not be the same”，应是笔误）。我只是简单的提一下，如果不相信我那么请相信<a href="https://en.wikipedia.org/wiki/Universal_hashing#Mathematical_guarantees" target="_blank" rel="external">数学</a>。实现这一方法时需要注意的另一件事是如果选择了一个不好的通用散列家族，它会把时间和空间复杂度拖到 <code>O(U)</code>，其中 U 是散列家族的大小。而其中的挑战就是找到一个不需要太多时间来计算，也不需要太多空间来存储的哈希家族。</p>
<h3 id="上帝哈希函数"><a href="#上帝哈希函数" class="headerlink" title="上帝哈希函数"></a>上帝哈希函数</h3><p>追求完美是人的天性。我们是否能够构建一个<em>完美的哈希函数</em>，从而能够把关键字映射到整数集中，并且几乎<em>没有碰撞</em>。好消息是我们能够在一定程度上做到，但是我们的数据必须是静态的（这意味着在一定时间内没有插入/删除/更新）。一个实现完美哈希函数的方法就是使用 <ruby>2 级哈希<rt>2-Level Hashing</rt></ruby>，它基本上是我们前面讨论过的两种方法的组合。它使用<em>通用散列</em>来选择使用哪个哈希函数，然后通过<em>链接</em>组合起来，但是这次不是使用链表数据结构，而是使用另一个哈希表。让我们看一看下面它是怎么实现的： </p>
<p><a href="http://www.zeroequalsfalse.press/2017/02/20/hashtables/Diagram.png" target="_blank" rel="external"><img src="http://www.zeroequalsfalse.press/2017/02/20/hashtables/Diagram.png" alt="2-Level Hashing" title="2-Level Hashing"></a> </p>
<p><strong>但是这是如何工作的以及我们如何能够确保无需关心碰撞？</strong></p>
<p>它的工作方式与<a href="https://en.wikipedia.org/wiki/Birthday_problem" target="_blank" rel="external">生日悖论</a>相反。它指出，在随机选择的一堆人中，会有一些人生日相同。但是如果一年中的天数远远大于人数（平方以上），那么有极大的可能性所有人的生日都不相同。所以这二者是如何相关的？对于每一个链接哈希表，其大小均为第一级哈希表大小的平方。那就是说，如果有两个元素被散列到同一个点，那么链接哈希表的大小将为 4 。大多数时候，链接哈希表将会非常稀疏/空。</p>
<p>重复下面两步来确保无需担心碰撞：</p>
<ul>
<li>从通用散列家族中选择一个哈希函数来计算</li>
<li>如果发生碰撞，那么继续从通用散列家族中选择另一个哈希函数来计算</li>
</ul>
<p>字面上看就是这样（这是一个 <code>O(n^2)</code> 空间的解）。如果需要考虑空间问题，那么显然需要另一个不同的方法。但是值得庆幸的是，该过程平均只需要进行<strong>两次</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>只有具有一个好的哈希函数才能算得上是一个好的哈希表。在同时保证功能实现、时间和空间的提前下构建一个完美的哈希函数是一件很困难的事。我推荐你在解决问题的时候首先考虑哈希表，因为它能够为你提供巨大的性能优势，而且它能够对应用程序的可用性产生显著差异。哈希表和完美哈希函数常被用于实时编程应用中，并且在各种算法中都得到了广泛应用。你见或者不见，哈希表就在这儿。</p>
<hr>
<p>via: <a href="http://www.zeroequalsfalse.press/2017/02/20/hashtables/" target="_blank" rel="external">http://www.zeroequalsfalse.press/2017/02/20/hashtables/</a></p>
<p>作者：<a href="http://www.zeroequalsfalse.press/about" target="_blank" rel="external">Marty Jacobs</a><br>译者：<a href="https://github.com/ucasFL" target="_blank" rel="external">ucasFL</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;探索&lt;ruby&gt;哈希表&lt;rt&gt;hash table&lt;/rt&gt;&lt;/ruby&gt;的世界并理解其底层的机制是非常有趣的，并且将会受益匪浅。所以，让我们了解它，并从头开始探索吧。&lt;/p&gt;
&lt;p&gt;哈希表是许多现代软件应用程序中一种常见的数据结构。它提供了类似字典的功能，使你能够在其中执行插入、删除和删除等操作。这么说吧，比如我想找出“苹果”的定义是什么，并且我知道该定义被存储在了我定义的哈希表中。我将查询我的哈希表来得到定义。它在哈希表内的记录看起来可能像：&lt;code&gt;&amp;quot;苹果&amp;quot; =&amp;gt; &amp;quot;一种拥有水果之王之称的绿色水果&amp;quot;&lt;/code&gt;。这里，“苹果”是我的关键字，而“一种拥有水果之王之称的水果”是与之关联的值。&lt;/p&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Hash-table" scheme="http://ucasfl.me/tags/Hash-table/"/>
    
  </entry>
  
  <entry>
    <title>通过开源书籍学习 Ruby 编程</title>
    <link href="http://ucasfl.me/2017/09/02/Open-Source-Ruby-Books/"/>
    <id>http://ucasfl.me/2017/09/02/Open-Source-Ruby-Books/</id>
    <published>2017-09-02T04:44:13.000Z</published>
    <updated>2017-09-02T04:55:43.099Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/Ruby-Montage.png?w=565&amp;ssl=1" alt=""></p>
<h3 id="开源的-Ruby-书籍"><a href="#开源的-Ruby-书籍" class="headerlink" title="开源的 Ruby 书籍"></a>开源的 Ruby 书籍</h3><p>Ruby 是由 Yukihiro “Matz” Matsumoto 开发的一门通用目的、脚本化、结构化、灵活且完全面向对象的编程语言。它具有一个完全动态类型系统，这意味着它的大多数类型检查是在运行的时候进行，而非编译的时候。因此程序员不必过分担心是整数类型还是字符串类型。Ruby 会自动进行内存管理，它具有许多和 Python、Perl、Lisp、Ada、Eiffel 和 Smalltalk 相同的特性。</p>
<p>Ruby on Rails 框架对于 Ruby 的流行起到了重要作用，它是一个全栈 Web 框架，目前已被用来创建许多受欢迎的应用，包括 Basecamp、GitHub、Shopify、Airbnb、Twitch、SoundCloud、Hulu、Zendesk、Square 和 Highise 。</p>
<p>Ruby 具有很高的可移植性性，在 Linux、Windows、Mac OS X、Cygwin、FreeBSD、NetBSD、OpenBSD、BSD/OS、Solaris、Tru64 UNIX、HP-UX 以及其他许多系统上均可运行。目前，Ruby 在 TIOBE 编程社区排名 12 。</p>
<p>这篇文章有 9 本很优秀的推荐书籍，有针对包括初学者、中级程序员和高级程序员的书籍。当然，所有的书籍都是在开源许可下发布的。</p>
<a id="more"></a>
<p>这篇文章是<a href="https://www.ossblog.org/opensourcebooks/" target="_blank" rel="external"> OSSBlog 的系列文章开源编程书籍</a>的一部分。</p>
<h3 id="《Ruby-Best-Practices》"><a href="#《Ruby-Best-Practices》" class="headerlink" title="《Ruby Best Practices》"></a>《<a href="https://github.com/practicingruby/rbp-book/tree/gh-pages/pdfs" target="_blank" rel="external">Ruby Best Practices</a>》</h3><p><img src="https://i0.wp.com/www.ossblog.org/wp-content/uploads/2017/03/RubyBestPractices.jpg?resize=200%2C262&amp;ssl=1" alt="Ruby Best Practices"> </p>
<p>作者： Gregory Brown (328 页)</p>
<p>《Ruby Best Practices》适合那些希望像有经验的 Ruby 专家一样使用 Ruby 的程序员。本书是由 Ruby 项目 Prawn 的开发者所撰写的，它阐述了如何使用 Ruby 设计美丽的 API 和特定领域语言，以及如何利用函数式编程想法和技术，从而简化代码，提高效率。</p>
<p>《Ruby Best Practices》 更多的内容是关于如何使用 Ruby 来解决问题，它阐述的是你应该使用的最佳解决方案。这本书不是针对 Ruby 初学者的，所以对于编程新手也不会有太多帮助。这本书的假想读者应该对 Ruby 的相应技术有一定理解，并且拥有一些使用 Ruby 来开发软件的经验。</p>
<p>这本书分为两部分，前八章组成本书的核心部分，后三章附录作为补充材料。</p>
<p>这本书提供了大量的信息：</p>
<ul>
<li>通过测试驱动代码 - 涉及了大量的测试哲学和技术。使用 mocks 和 stubs</li>
<li>通过利用 Ruby 神秘的力量来设计漂亮的 API：灵活的参数处理和代码块</li>
<li>利用动态工具包向开发者展示如何构建灵活的界面，实现单对象行为，扩展和修改已有代码，以及程序化地构建类和模块</li>
<li>文本处理和文件管理集中于正则表达式，文件、临时文件标准库以及文本处理策略实战</li>
<li>函数式编程技术优化了模块代码组织、存储、无穷目录以及更高顺序程序。</li>
<li>理解代码如何出错以及为什么会出错，阐述如何处理日志记录</li>
<li>通过利用 Ruby 的多语言能力削弱文化屏障</li>
<li>熟练的项目维护</li>
</ul>
<p>本书为开源书籍，在 CC NC-SA 许可证下发布。</p>
<p><a href="https://github.com/practicingruby/rbp-book/tree/gh-pages/pdfs" target="_blank" rel="external">在此下载《Ruby Best Practices》</a>。 </p>
<h3 id="《I-Love-Ruby》"><a href="#《I-Love-Ruby》" class="headerlink" title="《I Love Ruby》"></a>《<a href="https://mindaslab.github.io/I-Love-Ruby/" target="_blank" rel="external">I Love Ruby</a>》</h3><p> <img src="https://i2.wp.com/www.ossblog.org/wp-content/uploads/2017/03/LoveRuby.png?resize=200%2C282&amp;ssl=1" alt="I Love Ruby"></p>
<p>作者： Karthikeyan A K (246 页)</p>
<p>《I Love Ruby》以比传统的介绍更高的深度阐述了基本概念和技术。该方法为编写有用、正确、易维护和高效的 Ruby 代码提供了一个坚实的基础。</p>
<p>章节内容涵盖：</p>
<ul>
<li>变量</li>
<li>字符串</li>
<li>比较和逻辑</li>
<li>循环</li>
<li>数组</li>
<li>哈希和符号</li>
<li>Ranges</li>
<li>函数</li>
<li>变量作用域</li>
<li>类 &amp; 对象</li>
<li>Rdoc</li>
<li>模块和 Mixins</li>
<li>日期和时间</li>
<li>文件</li>
<li>Proc、匿名 和 块</li>
<li>多线程</li>
<li>异常处理</li>
<li>正则表达式</li>
<li>Gems</li>
<li>元编程</li>
</ul>
<p>在 GNU 自由文档许可证之下，你可以复制、发布和修改本书，1.3 或任何之后版本由自由软件基金会发布。</p>
<p><a href="https://mindaslab.github.io/I-Love-Ruby/" target="_blank" rel="external">点此下载《I Love Ruby》</a>。</p>
<h3 id="Programming-Ruby-–-The-Pragmatic-Programmer’s-Guide"><a href="#Programming-Ruby-–-The-Pragmatic-Programmer’s-Guide" class="headerlink" title="Programming Ruby – The Pragmatic Programmer’s Guide"></a><a href="http://ruby-doc.com/docs/ProgrammingRuby/" target="_blank" rel="external">Programming Ruby – The Pragmatic Programmer’s Guide</a></h3><p><img src="https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/ProgrammingRuby.jpeg?resize=200%2C248&amp;ssl=1" alt="Programming Ruby - The Pragmatic Programmer&#39;s Guide"> </p>
<p>作者： David Thomas, Andrew Hunt (HTML)</p>
<p>《Programming Ruby – The Pragmatic Programmer’s Guide》是一本 Ruby 编程语言的教程和参考书。使用 Ruby，你将能够写出更好的代码，更加有效率，并且使编程变成更加享受的体验。</p>
<p>内容涵盖以下部分：</p>
<ul>
<li>类、对象和变量</li>
<li>容器、块和迭代器</li>
<li>标准类型</li>
<li>更多方法</li>
<li>表达式</li>
<li>异常、捕获和抛出</li>
<li>模块</li>
<li>基本输入和输出</li>
<li>线程和进程</li>
<li>何时抓取问题</li>
<li>Ruby 和它的世界、Web、Tk 和 微软 Windows</li>
<li>扩展 Ruby</li>
<li>映像、对象空间和分布式 Ruby</li>
<li>标准库</li>
<li>面向对象设计库</li>
<li>网络和 Web 库</li>
<li>嵌入式文件</li>
<li>交互式 Ruby shell</li>
</ul>
<p>这本书的第一版在开放发布许可证 1.0 版或更新版的许可下发布。本书更新后的第二版涉及 Ruby 1.8 ，并且包括所有可用新库的描述，但是它不是在免费发行许可证下发布的。</p>
<p><a href="http://ruby-doc.com/docs/ProgrammingRuby/" target="_blank" rel="external">点此下载《Programming Ruby – The Pragmatic Programmer’s Guide》</a>。</p>
<h3 id="《Why’s-Poignant-Guide-to-Ruby》"><a href="#《Why’s-Poignant-Guide-to-Ruby》" class="headerlink" title="《Why’s (Poignant) Guide to Ruby》"></a>《<a href="http://poignant.guide/" target="_blank" rel="external">Why’s (Poignant) Guide to Ruby</a>》</h3><p><img src="https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/WhysGuideRuby.jpg?resize=200%2C218&amp;ssl=1" alt="Why’s (Poignant) Guide to Ruby"> </p>
<p>作者：why the lucky stiff (176 页)</p>
<p>《Why’s (poignant) Guide to Ruby》是一本 Ruby 编程语言的介绍书籍。该书包含一些冷幽默，偶尔也会出现一些和主题无关的内容。本书包含的笑话在 Ruby 社区和卡通角色中都很出名。</p>
<p>本书的内容包括：</p>
<ul>
<li>关于本书</li>
<li>Kon’nichi wa, Ruby</li>
<li>一个快速（希望是无痛苦的）的 Ruby 浏览（伴随卡通角色）：Ruby 核心概念的基本介绍</li>
<li>代码浮动小叶：评估和值，哈希和列表</li>
<li>组成规则的核心部分：case/when、while/until、变量作用域、块、方法、类定义、类属性、对象、模块、IRB 中的内省、dup、self 和 rbconfig 模块</li>
<li>中心：元编程、正则表达式</li>
<li>当你打算靠近胡须时：在已存在类中发送一个新方法</li>
<li>天堂演奏</li>
</ul>
<p>本书在 CC-SA 许可证许可下可用。</p>
<p><a href="http://poignant.guide/" target="_blank" rel="external">点此下载《Why’s (poignant) Guide to Ruby》</a>。</p>
<h3 id="《Ruby-Hacking-Guide》"><a href="#《Ruby-Hacking-Guide》" class="headerlink" title="《Ruby Hacking Guide》"></a>《<a href="http://ruby-hacking-guide.github.io/" target="_blank" rel="external">Ruby Hacking Guide</a>》</h3><p><img src="https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/RubyHackingGuide.png?resize=200%2C250&amp;ssl=1" alt="Ruby Hacking Guide"> </p>
<p>作者： Minero Aoki ，翻译自 Vincent Isambart 和 Clifford Escobar Caoille (HTML)</p>
<p>通过阅读本书可以达成下面的目标：</p>
<ul>
<li>拥有关于 Ruby 结构的知识</li>
<li>掌握一般语言处理的知识</li>
<li>收获阅读源代码的技能</li>
</ul>
<p>本书分为四个部分：</p>
<ul>
<li>对象</li>
<li>动态分析</li>
<li>评估</li>
<li>外部评估</li>
</ul>
<p>要想从本书中收获最多的东西，需要具备一定 C 语言的知识和基本的面向对象编程知识。本书在 CC-NC-SA 许可证许可下发布。</p>
<p>原书的官方支持网站为 <a href="http://i.loveruby.net/ja/rhg/" target="_blank" rel="external">i.loveruby.net/ja/rhg/</a></p>
<p><a href="http://ruby-hacking-guide.github.io/" target="_blank" rel="external">点此下载《Ruby Hacking Guide》</a></p>
<h3 id="《The-Book-Of-Ruby》"><a href="#《The-Book-Of-Ruby》" class="headerlink" title="《The Book Of Ruby》"></a>《<a href="http://www.sapphiresteel.com/ruby-programming/The-Book-Of-Ruby.html" target="_blank" rel="external">The Book Of Ruby</a>》</h3><p><img src="https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/BookRuby.jpg?resize=200%2C270&amp;ssl=1" alt="The Book Of Ruby"> </p>
<p>作者： How Collingbourne (425 页)</p>
<p>《The Book Of Ruby》是一本免费的 Ruby 编程高级教程。</p>
<p>《The Book Of Ruby》以 PDF 文件格式提供，并且每一个章节的所有例子都伴有可运行的源代码。同时，也有一个介绍来阐述如何在 Steel 或其他任何你喜欢的编辑器/IDE 中运行这些 Ruby 代码。它主要集中于 Ruby 语言的 1.8.x 版本。</p>
<p>本书被分成很小的块。每一个章节介绍一个主题，并且分成几个不同的子话题。每一个编程主题由一个或多个小的自包含、可运行的 Ruby 程序构成。</p>
<ul>
<li>字符串、数字、类和对象 - 获取输入和输出、字符串和外部评估、数字和条件测试：if … then、局部变量和全局变量、类和对象、实例变量、消息、方法、多态性、构造器和检属性和类变量 - 超类和子类，超类传参，访问器方法，’set‘ 访问器，属性读写器、超类的方法调用，以及类变量</li>
<li>类等级、属性和类变量 - 超类和子类，超类传参，访问器方法，’set‘ 访问器，属性读写器、超类的方法调用，以及类变量</li>
<li>字符串和 Ranges - 用户自定义字符串定界符、引号等更多</li>
<li>数组和哈希 - 展示如何创建一系列对象</li>
<li>循环和迭代器 - for 循环、代码块、while 循环、while 修改器以及 until 循环</li>
<li>条件语句 - If..Then..Else、And..Or..Not、If..Elsif、unless、if 和 unless 修改器、以及 case 语句</li>
<li>方法 - 类方法、类变量、类方法是用来干什么的、Ruby 构造器、单例方法、单例类、重载方法以及更多</li>
<li>传递参数和返回值 - 实例方法、类方法、单例方法、返回值、返回多重值、默认参数和多重参数、赋值和常量传递以及更多</li>
<li>异常处理 - 涉及 rescue、ensure、else、错误数量、retry 和 raise</li>
<li>块、Procs 和 匿名 - 阐述为什么它们对 Ruby 来说很特殊</li>
<li>符号 - 符号和字符串、符号和变量以及为什么应该使用符号</li>
<li>模块和 Mixins</li>
<li>文件和 IO - 打开和关闭文件、文件和目录、复制文件、目录询问、一个关于递归的讨论以及按大小排序</li>
<li>YAML - 包括嵌套序列，保存 YAML 数据以及更多</li>
<li>Marshal - 提供一个保存和加载数据的可选择方式</li>
<li>正则表达式 - 进行匹配、匹配群组以及更多</li>
<li>线程 - 向你展示如何同时运行多个任务</li>
<li>调试和测试 - 涉及交互式 Ruby shell（IRB.exe）、debugging 和 单元测试</li>
<li>Ruby on Rails - 浏览一个创建博客的实践指南</li>
<li>动态编程 - 自修改程序、重运算魔法、特殊类型的运算、添加变量和方法以及更多</li>
</ul>
<p>本书由 SapphireSteel Software 发布，SapphireSteel Software 是用于 Visual Studio 的 Ruby In Steel 集成开发环境的开发者。读者可以复制和发布本书的文本和代码（免费版）</p>
<p><a href="http://www.sapphiresteel.com/ruby-programming/The-Book-Of-Ruby.html" target="_blank" rel="external">点此下载《The Book Of Ruby》</a></p>
<h3 id="《The-Little-Book-Of-Ruby》"><a href="#《The-Little-Book-Of-Ruby》" class="headerlink" title="《The Little Book Of Ruby》"></a>《<a href="http://www.sapphiresteel.com/ruby-programming/The-Book-Of-Ruby.html" target="_blank" rel="external">The Little Book Of Ruby</a>》</h3><p> <img src="https://i0.wp.com/www.ossblog.org/wp-content/uploads/2017/03/TheLittleBookRuby.png?resize=200%2C259&amp;ssl=1" alt="The Little Book of Ruby"> </p>
<p>作者： Huw Collingbourne (87 页)</p>
<p>《The Little Book of Ruby》是一本一步接一步的 Ruby 编程教程。它指导读者浏览 Ruby 的基础。另外，它分享了《The Book of Ruby》一书的内容，但是它旨在作为一个简化的教程来阐述 Ruby 的主要特性。</p>
<p>章节内容涵盖：</p>
<ul>
<li>字符串和方法 - 包括外部评估。详细描述了 Ruby 方法的语法</li>
<li>类和对象 - 阐述如何创建一个新类型的对象</li>
<li>类等级 - 一个特殊类型的类，其为一些其他类的简化并且继承了其他一些类的特性</li>
<li>访问器、属性、类变量 - 访问器方法，属性读写器，属性创建变量，调用超类方法以及类变量探索</li>
<li>数组 - 学习如何创建一系列对象：数组包括多维数组</li>
<li>哈希 - 涉及创建哈希表，为哈希表建立索引以及哈希操作等</li>
<li>循环和迭代器 - for 循环、块、while 循环、while 修饰器以及 until 循环</li>
<li>条件语句 - If..Then..Else、And..Or..Not、If..Elsif、unless、if 和 unless 修饰器以及 case 语句</li>
<li>模块和 Mixins - 包括模块方法、模块作为名字空间模块实例方法、模块或 ‘mixins’、来自文件的模块和预定义模块</li>
<li>保存文件以及更多内容</li>
</ul>
<p>本书可免费复制和发布，只需保留原始文本且注明版权信息。</p>
<p><a href="http://www.sapphiresteel.com/ruby-programming/The-Book-Of-Ruby.html" target="_blank" rel="external">点此下载《The Little Book of Ruby》</a></p>
<h3 id="《Kestrels-Quirky-Birds-and-Hopeless-Egocentricity》"><a href="#《Kestrels-Quirky-Birds-and-Hopeless-Egocentricity》" class="headerlink" title="《Kestrels, Quirky Birds, and Hopeless Egocentricity》"></a>《<a href="https://leanpub.com/combinators" target="_blank" rel="external">Kestrels, Quirky Birds, and Hopeless Egocentricity</a>》</h3><p> <img src="https://i2.wp.com/www.ossblog.org/wp-content/uploads/2017/03/KestrelsQuirkyBirds.jpeg?resize=200%2C259&amp;ssl=1" alt="Kestrels, Quirky Birds, and Hopeless Egocentricity"> </p>
<p>作者： Reg “raganwald” Braithwaite (123 页)</p>
<p>《Kestrels, Quirky Birds, and Hopeless Egocentricity》是通过收集 “Raganwald” Braithwaite 的关于组合逻辑、Method Combinators 以及 Ruby 元编程的系列文章而形成的一本方便的电子书。</p>
<p>本书提供了通过使用 Ruby 编程语言来应用组合逻辑的一个基本介绍。组合逻辑是一种数学表示方法，它足够强大，从而用于解决集合论问题以及计算中的问题。</p>
<p>在这本书中，读者会会探讨到一些标准的 Combinators，并且对于每一个 Combinators，书中都用 Ruby 编程语言写程序探讨了它的一些结果。在组合逻辑上，Combinators 之间组合并相互改变，书中的 Ruby 例子注重组合和修改 Ruby 代码。通过像 K Combinator 和 .tap 方法这样的简单例子，本书阐述了元编程的理念和递归 Combinators 。</p>
<p>本书在 MIT 许可证许可下发布。</p>
<p><a href="https://leanpub.com/combinators" target="_blank" rel="external">点此下载《Kestrels, Quirky Birds, and Hopeless Egocentricity》</a></p>
<h3 id="《Ruby-Programming》"><a href="#《Ruby-Programming》" class="headerlink" title="《Ruby Programming》"></a>《<a href="https://en.wikibooks.org/wiki/Ruby_Programming" target="_blank" rel="external">Ruby Programming</a>》</h3><p> <img src="https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/RubyProgrammingWikibooks.png?resize=200%2C285&amp;ssl=1" alt="Ruby Programming"> </p>
<p>作者： Wikibooks.org (261 页)</p>
<p>Ruby 是一种解释性、面向对象的编程语言。</p>
<p>本书被分为几个部分，从而方便按顺序阅读。</p>
<ul>
<li>开始 - 向读者展示如何在其中一个操作系统环境中安装并开始使用 Ruby </li>
<li>Ruby 基础 - 阐述 Ruby 语法的主要特性。它涵盖了字符串、编码、写方法、类和对象以及异常等内容</li>
<li>Ruby 语义参考</li>
<li>内建类</li>
<li>可用模块，涵盖一些标准库</li>
<li>中级 Ruby 涉及一些稍微高级的话题</li>
</ul>
<p>本书在 CC-SA 3.0 本地化许可证许可下发布。</p>
<p><a href="https://en.wikibooks.org/wiki/Ruby_Programming" target="_blank" rel="external">点此下载《Ruby Programming》</a></p>
<hr>
<p>无特定顺序，我将在结束前推荐一些没有在开源许可证下发布但可以免费下载的 Ruby 编程书籍。</p>
<ul>
<li><a href="http://www.humblelittlerubybook.com/" target="_blank" rel="external">Mr. Neighborly 的 Humble Little Ruby Book</a> – 一个易读易学的 Ruby 完全指南。</li>
<li><a href="https://launchschool.com/books/ruby" target="_blank" rel="external">Introduction to Programming with Ruby</a> – 学习编程的基础知识，一切从零开始。</li>
<li><a href="https://launchschool.com/books/oo_ruby" target="_blank" rel="external">Object Oriented Programming with Ruby</a> – 学习编程的基础知识，一切从零开始。</li>
<li><a href="https://launchschool.com/books/core_ruby_tools" target="_blank" rel="external">Core Ruby Tools</a> – 对 Ruby 的四个核心工具 Gems、Ruby Version Managers、Bundler 和 Rake 进行了简短的概述。</li>
<li><a href="https://learnrubythehardway.org/book/" target="_blank" rel="external">Learn Ruby the Hard Way, 3rd Edition</a> – 一本适合初学者的入门书籍。</li>
<li><a href="https://pine.fm/LearnToProgram" target="_blank" rel="external">Learn to Program</a> – 来自 Chris Pine。</li>
<li><a href="http://www.techotopia.com/index.php/Ruby_Essentials" target="_blank" rel="external">Ruby Essentials</a> – 一个准确且简单易学的 Ruby 学习指南。</li>
</ul>
<hr>
<p>via: <a href="https://www.ossblog.org/study-ruby-programming-with-open-source-books/" target="_blank" rel="external">https://www.ossblog.org/study-ruby-programming-with-open-source-books/</a></p>
<p>作者：<a href="https://www.ossblog.org/author/steve/" target="_blank" rel="external">Steve Emms</a><br>译者：<a href="https://github.com/ucasFL" target="_blank" rel="external">ucasFL</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/Ruby-Montage.png?w=565&amp;amp;ssl=1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;开源的-Ruby-书籍&quot;&gt;&lt;a href=&quot;#开源的-Ruby-书籍&quot; class=&quot;headerlink&quot; title=&quot;开源的 Ruby 书籍&quot;&gt;&lt;/a&gt;开源的 Ruby 书籍&lt;/h3&gt;&lt;p&gt;Ruby 是由 Yukihiro “Matz” Matsumoto 开发的一门通用目的、脚本化、结构化、灵活且完全面向对象的编程语言。它具有一个完全动态类型系统，这意味着它的大多数类型检查是在运行的时候进行，而非编译的时候。因此程序员不必过分担心是整数类型还是字符串类型。Ruby 会自动进行内存管理，它具有许多和 Python、Perl、Lisp、Ada、Eiffel 和 Smalltalk 相同的特性。&lt;/p&gt;
&lt;p&gt;Ruby on Rails 框架对于 Ruby 的流行起到了重要作用，它是一个全栈 Web 框架，目前已被用来创建许多受欢迎的应用，包括 Basecamp、GitHub、Shopify、Airbnb、Twitch、SoundCloud、Hulu、Zendesk、Square 和 Highise 。&lt;/p&gt;
&lt;p&gt;Ruby 具有很高的可移植性性，在 Linux、Windows、Mac OS X、Cygwin、FreeBSD、NetBSD、OpenBSD、BSD/OS、Solaris、Tru64 UNIX、HP-UX 以及其他许多系统上均可运行。目前，Ruby 在 TIOBE 编程社区排名 12 。&lt;/p&gt;
&lt;p&gt;这篇文章有 9 本很优秀的推荐书籍，有针对包括初学者、中级程序员和高级程序员的书籍。当然，所有的书籍都是在开源许可下发布的。&lt;/p&gt;
    
    </summary>
    
      <category term="Ruby" scheme="http://ucasfl.me/categories/Ruby/"/>
    
    
      <category term="Ruby" scheme="http://ucasfl.me/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>外部排序</title>
    <link href="http://ucasfl.me/2017/08/08/External-Sort/"/>
    <id>http://ucasfl.me/2017/08/08/External-Sort/</id>
    <published>2017-08-08T04:53:19.000Z</published>
    <updated>2017-09-02T04:38:29.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主存储器与外部存储器"><a href="#主存储器与外部存储器" class="headerlink" title="主存储器与外部存储器"></a>主存储器与外部存储器</h3><p>外存储器与内存储器相比,优点是:</p>
<ul>
<li>价格较低</li>
<li>永久的存储能力</li>
</ul>
<p>缺点:</p>
<ul>
<li>访问外存储器上的数据比访问内存要慢5 ~ 6 个数量级</li>
</ul>
<p>因此，要求我们在开发系统时必须考虑如何使外存访<br>问次数达到最少。</p>
<a id="more"></a>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><ul>
<li>磁盘存储器通常称为直接存取设备,或随机存取设备,它访问外存上文件的任一记录的时间几乎相同。</li>
<li>磁盘存储器可以顺序存取,也可以随机存取。</li>
<li>每个记录盘面上有很多磁道,数据就存放在这些磁道上。它们在记录盘面上形成一个个同心圆。</li>
<li>每个记录盘面都有一个读写磁头。所有记录盘面的读写磁头都安装在同一个动臂上,随动臂向内或向外做径向移动,从一个磁道移到另一个磁道。</li>
<li>任一时刻,所有记录盘面的读写磁头停留在各个记录盘面的半径相同的磁道上。</li>
<li>各个记录盘面上半径相同的磁道合在一起称为柱面。一个磁道可以划分为若干段,称为扇区,一个扇区就是一次读写的最小数据量。这样,对磁盘存储器来说,从大到小的存储单位是:柱面号、盘片号、磁道号和扇区。</li>
<li>在磁盘组上一次读写的时间主要为:</li>
</ul>
<p>$$t<em>{io} = t</em>{seek} + t<em>{latency} +n\cdot t</em>{wm}$$<br>其中, $t<em>{seek}$ 平均寻查时间,是把磁头定位到要求柱面所需时间。$t</em>{latency}$ 平均等待时间,是将磁头定位到指定块所需时间。$t_{wm}$ 是传输一个扇区数据所需的时间。</p>
<ul>
<li>在磁盘组上一次读 / 写的时间主要花在寻找时间上。因此,在磁盘上存放信息时应将相关信息放在同一柱面或邻近柱面上,以求在读 / 写信息时尽量减少磁头来回移动的次数,以避免不必要的寻找时间。</li>
</ul>
<h3 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h3><p>当待排序的记录数目特别多时,在内存中不能一次处理,必须把它们以文件的形式存放于外存,排序时再把它们一部分一部分调入内存进行处理。这样,在排序过程中必须不断地在内存与外存之间传送数据。这种基于外部存储设备(或文件)的排序技术就是外排序。</p>
<h4 id="外排序的基本过程"><a href="#外排序的基本过程" class="headerlink" title="外排序的基本过程"></a>外排序的基本过程</h4><p>基于磁盘进行的排序多使用归并排序方法。其排序过程主要分为两个阶段:</p>
<ol>
<li>按可用内存大小,将外存上含 n 个记录的文件划分为若干长度为 $l$ 的段 , 用某种内排序方法对各段进行排序。经过排序的段叫做归并段 (Run) 。当它们生成后就被写到外存中去。</li>
<li>把1生成的初始归并段加以归并 , 一趟趟扩大归并段和减少归并段数 , 直至得到整个有序文件为止。</li>
</ol>
<ul>
<li><p>归并排序时间$t_{ES}$为：</p>
<p>$t<em>{ES}=m\times t</em>{IS}+d\times t<em>{IO}+S\times n\cdot t</em>{mg}$</p>
<p>其中，$t_{IS}$是得到一个初始段需要的内部排序时间；$m$为初始归并段的个数；</p>
<p>$t<em>{IO}$是进行一次外存读/写时间的均值；$d$为总的读/写次数；$n\cdot t</em>{mg}$是对$n$个记录进行内部归并所需时间；$S$为归并的趟数。</p>
</li>
<li><p>$t<em>{IO}$远远大于$t</em>{IS}$和$t_{mg}$，因此，要加快外排序的速度，应着眼于减小$d$ 。</p>
</li>
<li><p>增大归并路数 , 可减少归并趟数 , 从而减少总读写磁盘次数 d 。</p>
</li>
</ul>
<h3 id="K-路平衡归并"><a href="#K-路平衡归并" class="headerlink" title="K-路平衡归并"></a>K-路平衡归并</h3><p>做K-路平衡归并时，如果有m个初始归并段，相应的归并树有logkm+1(logkm上取整)层，需要归并logkm(上取整)趟。</p>
<h4 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h4><p>败者树是一棵正则的完全二叉树。其中</p>
<ul>
<li>每个叶结点存放各归并段在归并过程中当前参加比较的记录;</li>
<li>每个非叶结点记忆它两个子女结点中记录排序码大的结点 ( 即败者 ) ;</li>
</ul>
<p>因此,根结点中记忆树中当前记录排序码最小的结点 ( 最小记录 ) 。</p>
<ul>
<li>败者树与胜者树的区别在于一个选择了败者 ( 排序码大者)，一个选择了胜者(排序码小者)</li>
</ul>
<p><strong>K-路平衡归并排序算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxValue = ;	<span class="comment">//当作无穷大值使用</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kwaymerge</span><span class="params">(Element *r, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, q; </div><div class="line">  r = <span class="keyword">new</span> Element[k];		<span class="comment">//败者树中的k个记录</span></div><div class="line">  <span class="keyword">int</span> *key = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];	<span class="comment">//记录的排序码	</span></div><div class="line">  <span class="keyword">int</span> *loser = <span class="keyword">new</span> <span class="keyword">int</span>[k];	<span class="comment">//存放败者树</span></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) &#123;           <span class="comment">//叶结点的值</span></div><div class="line">    InputRecord(r[i]);  key[i] = r[i].key; &#125;;</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) loser[i] = k;</div><div class="line">  key[k] = -Maxvalue;		<span class="comment">//初始化	</span></div><div class="line">  <span class="keyword">for</span> (i = k<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) </div><div class="line">    adjust (key, loser, k, i);    <span class="comment">//从key[k-1]到key[0]调整形成败者树</span></div><div class="line">  <span class="keyword">while</span> (key[loser[<span class="number">0</span>]] != MaxValue) &#123;      <span class="comment">//选冠军</span></div><div class="line">    q = loser[<span class="number">0</span>];			 <span class="comment">//取当前最小记录</span></div><div class="line">    OutputRecord(r[q]);		 <span class="comment">//写到输出归并段</span></div><div class="line">    InputRecord(r[q]);		 <span class="comment">//读入下一个记录</span></div><div class="line">    key[q] = r[q].key;</div><div class="line">    adjust (key, loser, k, q); 	 <span class="comment">//从key[q]起调整</span></div><div class="line">  &#125;</div><div class="line">  Output end of run marker; 	 <span class="comment">//输出段结束标志</span></div><div class="line">  <span class="keyword">delete</span> []r;  </div><div class="line">  <span class="keyword">delete</span> []key;</div><div class="line">  <span class="keyword">delete</span> []loser;</div><div class="line">&#125;; </div><div class="line"><span class="comment">//败者树的调整算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span> <span class="params">(<span class="keyword">int</span> key[]; <span class="keyword">int</span> loser[]; <span class="keyword">int</span> k; <span class="keyword">int</span> q)</span> </span>&#123;</div><div class="line"><span class="comment">// 从败者树某叶结点 key[q] 起到根进行比较 , 将最小</span></div><div class="line"><span class="comment">// key 记录所在归并段的段号记入 loser[0] 。</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> t = (k+q)/<span class="number">2</span>; t &gt; <span class="number">0</span>; t /= <span class="number">2</span>)</div><div class="line"><span class="comment">//t 是 q 的双亲</span></div><div class="line">    <span class="keyword">if</span> (key[loser[t]] &lt; key[q]) &#123;</div><div class="line"><span class="comment">// 败者记入 loser[t] ,胜者记入 q</span></div><div class="line">      <span class="keyword">int</span> temp = q; q = loser[t]; loser[t] = temp;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//q 与 loser[t] 交换</span></div><div class="line">  loser[<span class="number">0</span>] = q;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>每选出一个当前排序码最小的记录 , 就需要在将它送入输出缓冲区之后 , 从相应归并段的输入缓冲区中取出下一个参加归并的记录 , 替换已经取走的最小记录 , 再从叶结点到根结点 , 沿某一特定路径进行调整 , 将下一个排序码最小记录的归并段号调整到 loser[0] 中。</li>
<li>段结束标志 MaxNum 升入 loser[0], 排序完成。</li>
<li>归并路数 k 不是越大越好。归并路数 k 增大 , 相应需增加输入缓冲区个数。如果可供使用的内存空间不变 , 势必要减少每个输入缓冲区的容量 , 使内外存交换数据的次数增大。</li>
</ul>
<p><strong>初始归并段的生成</strong></p>
<ul>
<li>为减少读写磁盘次数 , 除增加归并路数 k 外 ,还可减少初始归并段个数 m 。在总记录数 n一定时 , 要减少 m , 必须增大初始归并段长度。</li>
<li>如果规定每个初始归并段等长 , 则此长度应根据生成它的内存工作区空间大小而定 , 因而 m的减少也就受到了限制。</li>
<li>为了突破这个限制 , 可采用败者树来生成初始归并段。在使用同样大内存工作区的情况下 ,可以生成平均比原来等长情况下大一倍的初始归并段 , 从而减少初始归并段个数。</li>
</ul>
<h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><p>归并树是描述归并过程的 m 叉树。因为每一次做 m路归并都需要有 m 个归并段参加 , 因此 , 归并树是只有度为 0 和度为 m 的结点的正则 m 叉树。</p>
<p>在归并树中：</p>
<ul>
<li>各叶结点代表参加归并的各初始归并段</li>
<li>叶结点上的权值即为该初始归并段中的记录个数</li>
<li>根结点代表最终生成的归并段</li>
<li>叶结点到根结点的路径长度表示在归并过程中的读记录次数</li>
<li>各非叶结点代表归并出来的新归并段</li>
<li>归并树的带权路径长度 WPL 即为归并过程中的总读记录数。因而,在归并过程中总的读写记录次数为 2*WPL 。</li>
</ul>
<p>不同的归并方案所对应的归并树的带权路径长度各不相同。为了使得总的读写次数达到最少 , 需要改变归并方案 , 重新组织归并树。可将 Huffman 树的思想扩充到 m 叉树的情形。在归并树中 , 让记录个数少的初始归并段最先归并 , 记录个数多的初始归并段最晚归并 , 就可建立总读写次数达到最少的最佳归并树。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主存储器与外部存储器&quot;&gt;&lt;a href=&quot;#主存储器与外部存储器&quot; class=&quot;headerlink&quot; title=&quot;主存储器与外部存储器&quot;&gt;&lt;/a&gt;主存储器与外部存储器&lt;/h3&gt;&lt;p&gt;外存储器与内存储器相比,优点是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;价格较低&lt;/li&gt;
&lt;li&gt;永久的存储能力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问外存储器上的数据比访问内存要慢5 ~ 6 个数量级&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，要求我们在开发系统时必须考虑如何使外存访&lt;br&gt;问次数达到最少。&lt;/p&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Data-Structures" scheme="http://ucasfl.me/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>内部排序</title>
    <link href="http://ucasfl.me/2017/08/08/Inner-Sort/"/>
    <id>http://ucasfl.me/2017/08/08/Inner-Sort/</id>
    <published>2017-08-08T04:51:50.000Z</published>
    <updated>2017-09-02T04:38:29.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>排序:将一组杂乱无章的数据按一定的规律顺次排列起来。</li>
</ul>
<p>假设含 n 个记录的序列为 { R1, R2, … , Rn }其相应的关键字序列为 { K1, K2, … , Kn }这些关键字相互之间可以进行比较,即在它们之间存在着这样一个关系 :</p>
<p>Kp1≤Kp2≤…≤Kpn<br>按此固有关系将上式记录序列重新排列,即使序列成为一个按关键字排序的 序列:{ Rp1, Rp2, … , Rpn }的操作称作排序。</p>
<ul>
<li>排序算法的稳定性 : 当输入含重复关键字时,重复元素在输入、输出序列中的相对次序是否保持不变。</li>
<li>内排序与外排序 : 内排序是指在 整个排序过程 数据元素全部存放在内存、 不需要访问外存便能完成 的排序, 称此类排序为内部排序 ; 反之,若参加排序的记录数量很大 ,不能同时存放在内存,必须根据排序过程的要求,不断在内、外存之间移动的排序, 称为外部排序。</li>
<li>排序算法的分类 :内部排序算法很多。但就其全面性能而言,很难认为哪种方法是最好的。没一种方法都有各自的优缺点,适合在不同环境下使用。插入排序、交换排序、选择排序、归并排序、计数排序等等 &lt; 按排序过程中依据的不同原则 &gt;</li>
</ul>
<a id="more"></a>
<p><strong>待排记录数据类型定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//待排记录的数据类型定义如下 :</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000 <span class="comment">// 待排顺序表最大长度</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType; <span class="comment">// 关键字类型为整数类型</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  KeyType key;<span class="comment">// 关键字项</span></div><div class="line">  InfoType otherinfo; <span class="comment">// 其它数据项</span></div><div class="line">&#125; RcdType;<span class="comment">// 记录类型</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  RcdType r[MAXSIZE+<span class="number">1</span>]; <span class="comment">// r[0] 闲置</span></div><div class="line">  <span class="keyword">int</span> length;<span class="comment">// 顺序表长度</span></div><div class="line">&#125; SqList;<span class="comment">// 顺序表类型</span></div></pre></td></tr></table></figure>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>基于交换的排序方法。</p>
<ul>
<li>观察：有序/无序序列中，任意/总有一对相邻元素顺序/逆序</li>
<li>扫描交换：依次比较每一对相邻元素，如有必要，交换之</li>
</ul>
<p>经一轮扫描交换后，最大元素必然就位；经一轮扫描交换后，问题的规模缩减至n-1。</p>
<ul>
<li>若整趟扫描都没有进行交换，则排序完成。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(Elem R[ ], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">   i = n;<span class="comment">//首先从n位置排序</span></div><div class="line">   <span class="keyword">bool</span> sorted = <span class="literal">false</span>;</div><div class="line">   <span class="keyword">while</span> (!sorted) &#123;<span class="comment">//第[i..n]大元素已排序，寻找 第i-1大元素</span></div><div class="line">         sorted = <span class="literal">true</span>;</div><div class="line">         <span class="keyword">for</span> (j = <span class="number">1</span>;  j &lt; i;  j++) <span class="comment">//从[1..i-1]寻找第i-1大元素</span></div><div class="line">             <span class="keyword">if</span> (R[j+<span class="number">1</span>].key &lt; R[j].key) &#123; <span class="comment">//将大的记录向后移</span></div><div class="line">                  Swap(R[j], R[j+<span class="number">1</span>]);</div><div class="line">                  sorted = <span class="literal">false</span>;  <span class="comment">//记下进行交换的记录位置</span></div><div class="line">             &#125; <span class="comment">//if</span></div><div class="line">         i -= <span class="number">1</span>;</div><div class="line">   &#125; <span class="comment">// while</span></div><div class="line">&#125; <span class="comment">// BubbleSort</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(Elem R[ ], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> i = n;<span class="comment">//首先从n位置排序</span></div><div class="line">   <span class="keyword">while</span> (i &gt;<span class="number">1</span>) &#123;<span class="comment">//第[i..n]大元素已排序，寻找 第i-1大元素</span></div><div class="line">         <span class="keyword">int</span>  lastExchangeIndex = <span class="number">1</span>;</div><div class="line">         <span class="keyword">for</span> (j = <span class="number">1</span>;  j &lt; i;  j++) <span class="comment">//从[1..i-1]寻找第i-1大元素</span></div><div class="line">             <span class="keyword">if</span> (R[j+<span class="number">1</span>].key &lt; R[j].key) &#123; <span class="comment">//将大的记录向后移</span></div><div class="line">                  Swap(R[j], R[j+<span class="number">1</span>]);</div><div class="line">                  lastExchangeIndex = j;  <span class="comment">//记下进行交换的记录位置</span></div><div class="line">             &#125; <span class="comment">//if</span></div><div class="line">         i = lastExchangeIndex; <span class="comment">//本趟进行过交换的最后一个记录的位置</span></div><div class="line">   &#125; <span class="comment">// while</span></div><div class="line">&#125; <span class="comment">// BubbleSort</span></div></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong></p>
<ul>
<li>最好情况：O(n)；最坏情况：O(n^2)</li>
</ul>
<p><strong>稳定性</strong></p>
<ul>
<li>稳定</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul>
<li>基本方法:分而治之，序列一分为二 //O(1)；子序列递归排序 //2×T(n/2)；合并有序子序列 //O(n)</li>
<li>归并排序算法的复杂度为 O(nlogn)</li>
<li>关键在于 merge 的实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span> <span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> hi )</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (hi-lo&lt;<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span>; <span class="comment">// 单个元素区间自然有序</span></div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    mi = (low+hi)/<span class="number">2</span>; <span class="comment">// 以中点为界</span></div><div class="line">    mergesort (low, mi); <span class="comment">// 将前半段排序</span></div><div class="line">    mergesort (mi+<span class="number">1</span>, hi); <span class="comment">// 对后半段排序</span></div><div class="line">    Merge (low, mi, hi); <span class="comment">// 归并</span></div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">// Msort</span></div><div class="line"></div><div class="line"><span class="comment">//二路归并算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span> <span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">  RcdType *A = elements+low;</div><div class="line">  <span class="keyword">int</span> lb = mi-low; </div><div class="line">  RcdType *B = <span class="keyword">new</span> RcdType[<span class="number">1b</span>];</div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;lb; B[i] = A[i++]);</div><div class="line">  <span class="keyword">int</span> lc = hi-mi;</div><div class="line">  RcdType *C = elements+mi;</div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>; j&lt;lb || k&lt;lc; ) &#123;</div><div class="line">    <span class="keyword">if</span> ( (j&lt;lb) &amp;&amp; (lc&lt;=k || B[j].key&lt;=C[k].key) )</div><div class="line">      A[i++] = B[j++];</div><div class="line">    <span class="keyword">if</span> ( (k&lt;lc) &amp;&amp; (lb&lt;=j || C[k].key&lt;B[j].key) )</div><div class="line">      A[i++] =C[k++];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">delete</span>(B);</div><div class="line">&#125;<span class="comment">//Merge</span></div></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<p>优点：</p>
<ul>
<li>最坏情况下最优 O(nlogn) 性能的第一个排序算法</li>
<li>不需要随机读写,完全顺序访问 - 尤其适用于列表之类的序列，磁带之类的设备</li>
<li>只要实现恰当,可保证稳定</li>
<li>可扩展性极佳,十分适宜于外部排序 - 海量网页搜索结果的归并易于并行化</li>
<li>稳定的排序算法。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要对等规模的辅助空间</li>
<li>即便输入完全(或者接近)有序,仍需 O(nlogn) 时</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>基本方法: 始终将序列看作两部分sorted + unsorted，L[0, r]+L[r, n}</li>
</ul>
<ul>
<li>初始条件：r=0;</li>
</ul>
<ul>
<li>迭代: 处理 e=L[r]，在 sorted 中确定当前元素 e 的适当位置,插入 e ,得到有序的 L[0, r]</li>
<li>不变性:随着 r 的递增, L[0, r) 始终有序,直到 r =n, L 即为整体有序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span> <span class="params">( SqList &amp;L )</span> </span>&#123;</div><div class="line"><span class="comment">// 对顺序表 L 作插入排序</span></div><div class="line">  <span class="keyword">for</span> ( i=<span class="number">2</span>; i&lt;=L.length; ++i ) <span class="comment">// 逐个将 i 插入已排好 [1..i-1] 中</span></div><div class="line">    <span class="keyword">if</span> (L.r[i].key &lt; L.r[i<span class="number">-1</span>].key) &#123; <span class="comment">// 只有小于时需要改变位置</span></div><div class="line">      p = search(L.r[i], i, L);</div><div class="line">      L.r[p] = L.r[i];</div><div class="line">    &#125;</div><div class="line">&#125; <span class="comment">// InsertSort</span></div></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<p>最坏情况：O(n)；</p>
<p>最好情况：O(n^2)；</p>
<p>稳定的排序算法。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li>起泡排序之所以需要O(n2)时间，是因为为挑选每个当前最大的元素M，需做O(n)次比较和O(n)次交换</li>
<li>实际上经过O(n)次比较确定M后，一次交换足矣</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span> <span class="params">(Elem R[], <span class="keyword">int</span> n )</span> </span>&#123;</div><div class="line">   <span class="comment">// 对记录序列R[1..n]作简单选择排序。</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;n; ++i) &#123;</div><div class="line">        <span class="comment">// 选择第 i 小的记录，并交换到位</span></div><div class="line">       j = SelectMinKey(R, i); </div><div class="line">        <span class="comment">// 与第 i 个记录交换</span></div><div class="line">       <span class="keyword">if</span> (i!=j)</div><div class="line">         <span class="keyword">int</span> t = R[i];</div><div class="line">         R[i] = R[j];</div><div class="line">         R[j] = t;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">// SelectSort</span></div></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<ul>
<li>共迭代n次，在第k次迭代中SelectMinKey的复杂度O(n-k)</li>
<li>SelectMinKey的复杂度可以降至O(logn)</li>
</ul>
<h4 id="树形选择排序-锦标赛排序"><a href="#树形选择排序-锦标赛排序" class="headerlink" title="树形选择排序/锦标赛排序"></a>树形选择排序/锦标赛排序</h4><ul>
<li>一种按照锦标赛思想进行选择排序的方法。这个过程可以用一棵有 n 个叶子结点的完全二叉树表示：叶节点:待排序元素(选手)；内部节点:孩子中的胜者；</li>
</ul>
<p>这种比赛树又称为胜者树。</p>
<ul>
<li>锦标赛选择</li>
</ul>
<p>更新:唯上一优胜者的祖先,才有必要重新参加比赛，只需从其所在叶节点出发,逐层上溯直到树根。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆是满足下列性质的数列：${r_1, r_2, …, r_n}$</p>
<p>$$\text{小顶堆}=\begin{cases} r<em>i\le r</em>{2i}\r<em>i \le r</em>{2i+1}\end{cases}$$</p>
<p>$$\text{大顶堆}=\begin{cases}r<em>i \ge r</em>{2i}\r<em>i \ge r</em>{2i+1}\end{cases}$$</p>
<p>堆的结构性 :</p>
<ul>
<li>逻辑上:等同于完全二叉树</li>
<li>物理上:直接借助顺序存储实现</li>
</ul>
<p>堆的堆序性：堆是符合这样定义的一棵有局部顺序的线性化完全二叉树：$K[i]\le K[parent(i)]$或$K[i]\ge K[parent(i)]$</p>
<p><strong>优先级队列(PQ priority queue)</strong></p>
<p>队列的一种，不过它可以按照自定义的一种方式（数据的优先级）来对队列中的数据进行态的访问，以方便快速求取最大优先级的数据。</p>
<ul>
<li>栈和队列，都是PQ的特例——优先级完全取决于元素的插入次序</li>
<li>应用：操作系统中的任务调度、中断处理、离散事件模拟等等</li>
<li>作为底层数据结构所支持的高效操作，是很多高效算法的基础</li>
</ul>
<p><strong>完全二叉堆：插入</strong></p>
<p>为插入一个新的元素 e ,只需将 e 作为末元素放入原顺序结构。</p>
<ul>
<li>唯一可能违反堆序性的只有该新节点和它的父亲。</li>
<li>只需从其所在叶节点出发,逐层上溯直到满足堆序性【上滤】。</li>
</ul>
<p>效率：</p>
<ul>
<li>e 与父亲的交换,每次只需 o(1) 时间,且每经过一次交换, e 都会上升一层;</li>
<li>在插入新节点 e 的整个过程中,只有 e 的祖先们才有可能需要参与交换;</li>
<li>堆是一棵完全树,必平衡,故 e 的祖先至多 o(logn)</li>
</ul>
<p>所以，通过上滤,可在 O(logn) 时间内插入一个新节点,并整体的重新调整为堆。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//插入和上滤</span></div><div class="line">Insert(Sqlist  &amp;heap,   RedType e)&#123;</div><div class="line">  heap.r[heap.length] = e;      </div><div class="line">  heap.length += <span class="number">1</span>;</div><div class="line">  percolateUp(heap, heap.length);</div><div class="line">&#125; </div><div class="line">percolateUp(Sqlist &amp;heap, <span class="keyword">int</span> i)&#123;</div><div class="line">  <span class="keyword">while</span> ( ParentValid(i) )&#123;</div><div class="line">    j = Parent（i）；</div><div class="line">      <span class="keyword">if</span> ( heap.r[i].key &gt; heap.r[j].key )  </div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      swap(heap.r[i], heap.r[j]);  i = j;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>完全二叉堆：删除</strong></p>
<p>最大元素始终在堆顶,故删除只需摘除首元素,代之以末元素 e；// 结构性自然保持,<br>那堆序性如何保持?</p>
<ul>
<li>唯一可能违反堆序性的只有该节点e 和它的孩子们。</li>
<li>只需从根节点出发,与孩子中的大者换位,逐层下滤直到满足堆</li>
</ul>
<p>效率:<br>通过下滤,可在 O(logn) 时间内删除堆顶节点,并整体地重新调整为堆。</p>
<p><strong>建堆</strong></p>
<ul>
<li>自上而下的上滤</li>
<li>建堆可以是一个从空堆开始,依次插入各元素。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Heapify(Sqlist &amp;L)&#123;</div><div class="line">  <span class="keyword">for</span> (i =<span class="number">1</span>; i&lt;L.length; i++)</div><div class="line">    percolateUp(L, i) ; <span class="comment">// 经上滤插入各节点</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效率: 在最坏情况下,每个元素都需上滤到根节点,所以时间复杂度是O(nlogn) 。</p>
<ul>
<li>自下而上的下滤</li>
<li>给定堆 H0 、 H1 和节点 P,为了得到堆 H0 UPU H1 ,只需将 ra(H0的堆顶) 和 rb(H1的堆顶) 当作 P 的孩子,对 p 下滤</li>
<li>从下向上,子堆逐层合并</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Heapify(Sqlist &amp;L)&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = L.length/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)</div><div class="line">    percolateDown(L, i) ; <span class="comment">// 下滤各内部节点</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效率：时间复杂度为O(n)</p>
<p><strong>堆排序即是利用堆的特性,不断输出当前最小( 大 ) 值,从而实现对序列进行排序的一种排序方法。</strong></p>
<p><strong>堆排序是不稳定的排序算法。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//堆排序算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span> <span class="params">(Sqlist &amp;L )</span> </span>&#123;</div><div class="line"><span class="comment">// 对顺序表 L 进行堆排序</span></div><div class="line">  Heapify ( L ); <span class="comment">// 建大顶堆</span></div><div class="line">  <span class="keyword">for</span> ( i=H.length; i&gt;<span class="number">1</span>; --i ) &#123;</div><div class="line">    <span class="keyword">int</span> t = H.r[<span class="number">0</span>];</div><div class="line">    H.r[<span class="number">0</span>] = H.r[i];</div><div class="line">    H.r[i] = t; <span class="comment">// 将堆顶记录和当前未经排序子序列H.r[1..i] 中最后一个记录相互交换堆</span></div><div class="line">  &#125;</div><div class="line">  percolateDown(L, <span class="number">0</span>) ; <span class="comment">// 对 H.r[0..i-1] 调整,成为新堆</span></div><div class="line">&#125; <span class="comment">// HeapSort</span></div></pre></td></tr></table></figure>
<p>算法分析：</p>
<ul>
<li>堆排序的时间复杂度为 O(nlogn) 。</li>
<li>堆排序方法对 n 较大的文件是很有效的。</li>
</ul>
<p><strong>左式堆</strong></p>
<p>左式堆是一棵单侧倾斜的树:</p>
<ul>
<li>节点分布偏向左侧</li>
<li>合并操作只涉及右侧</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//左式堆的合并</span></div><div class="line"><span class="function">BiNode *<span class="title">Merge</span><span class="params">(BiNode *a, *b)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> ( !a)</div><div class="line">      <span class="keyword">return</span> b;</div><div class="line">    <span class="keyword">if</span> (!b)</div><div class="line">      <span class="keyword">return</span> a;</div><div class="line">    <span class="keyword">if</span> ( a-&gt;data&lt;=b-&gt;data ) </div><div class="line">      swap( b, a);<span class="comment">//一般确保b不大，确保堆序性</span></div><div class="line">    a-&gt;rchild = merge(a-rchild, b); <span class="comment">//将a的右子堆与b合并</span></div><div class="line">    a-&gt;rchild-&gt;parent = a;<span class="comment">//更新父子关系</span></div><div class="line">    <span class="keyword">if</span> ( !a-&gt;lchild || a-&gt;lchild-&gt;NPL &lt; a-&gt;rchild-&gt;NPL )</div><div class="line">       swap( a-&gt;lchild, a-&gt;rchild );</div><div class="line">    a-&gt;NLP = a-&gt;rc ? A-&gt;rchild-&gt;NPL+<span class="number">1</span>: <span class="number">1</span>;<span class="comment">//更新父节点的NPL</span></div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"><span class="comment">//左式堆的插入 insert( )</span></div><div class="line"><span class="function">BiNode *<span class="title">insert</span><span class="params">(BiNode *a, e)</span></span>&#123;</div><div class="line">  BiNode *v = <span class="keyword">new</span> BiNode(e);</div><div class="line">  root= merge(a, v);</div><div class="line">  root-&gt;parent = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//左式堆的最大元素的删除DelMax</span></div><div class="line"><span class="function">BiNode *<span class="title">insert</span><span class="params">(BiNode *root)</span></span>&#123;</div><div class="line">  BiNode *lHeap = root-&gt;lChild ;BiNode *rHeap = root-&gt;rChild;</div><div class="line">  e = root-&gt;data;</div><div class="line">  <span class="keyword">delete</span> root;</div><div class="line">  root = merge( lHeap,rHeap);</div><div class="line">  <span class="keyword">if</span> ( root ) </div><div class="line">    root-&gt;parent = <span class="literal">NULL</span>;</div><div class="line">  <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul>
<li>分治策略的再一次体现</li>
<li>将序列分为两个子序列: S = SL +SR；规模缩小: max{|SL|,|SR|}&lt;n；彼此独立: max(SL ) &lt;= min(SR )</li>
<li>在子序列分别递归地排序后,原序列自然有序</li>
<li>平凡解:当只剩单个元素时,本身就是解</li>
<li>QuickSort 的难点在于“分” [ 归并排序 ]</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span> <span class="params">(RedType &amp; R[],  <span class="keyword">int</span> s,  <span class="keyword">int</span>  t )</span> </span>&#123;</div><div class="line">    <span class="comment">// 对记录序列R[s..t]进行快速排序</span></div><div class="line">    <span class="keyword">if</span> (s &lt; t<span class="number">-1</span>) &#123;             <span class="comment">// 长度大于1</span></div><div class="line">        pivotloc = Partition(R, s, t); <span class="comment">// 对 R[s..t] 进行一次划分</span></div><div class="line">        QSort(R, s, pivotloc<span class="number">-1</span>);  <span class="comment">// 对低子序列递归排序</span></div><div class="line">        QSort(R, pivotloc+<span class="number">1</span>, t); <span class="comment">// 对高子序列递归排序</span></div><div class="line">    &#125;</div><div class="line">&#125; <span class="comment">// QSort</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">( SqList &amp; L)</span> </span>&#123;</div><div class="line">      <span class="comment">// 对顺序表进行快速排序</span></div><div class="line">       QSort(L.r, <span class="number">1</span>, L.length);</div><div class="line">&#125; <span class="comment">// QuickSort</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span> <span class="params">(RedType&amp; R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">  pivotkey = R[low].key; <span class="comment">// 枢轴</span></div><div class="line">  <span class="keyword">while</span> (low&lt;high) &#123;</div><div class="line">    <span class="keyword">while</span> (low&lt;high &amp;&amp; R[high].key&gt;=pivotkey)</div><div class="line">      --high;</div><div class="line">    R[low]=R[high];</div><div class="line">    <span class="keyword">while</span> (low&lt;high &amp;&amp; R[low].key&lt;=pivotkey)</div><div class="line">      ++low;</div><div class="line">    R[high]=R[low];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> low;<span class="comment">// 返回枢轴所在位置</span></div><div class="line">&#125; <span class="comment">// Partition</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition2</span> <span class="params">(RedType&amp; R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">  pivotkey = R[low].key; <span class="comment">// 枢轴</span></div><div class="line">  mid = low;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = low+<span class="number">1</span>; k&lt;=high; k++)</div><div class="line">    <span class="keyword">if</span> (R[k].key&lt;pivotkey)</div><div class="line">      swap(R[++mid], R[k]);</div><div class="line">  swap(R[low], R[mid]);</div><div class="line"><span class="keyword">return</span> mid;<span class="comment">// 返回枢轴所在位置</span></div><div class="line">&#125; <span class="comment">// Partition例:</span></div></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>又称“缩小增量排序”，将记录序列分成若干子序列，分别对每个子序列进行插入排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span> <span class="params">(SqList &amp;L, <span class="keyword">int</span> dlta[], <span class="keyword">int</span> t)</span></span>&#123;</div><div class="line"><span class="comment">// 增量序列为 dlta[] 的希尔排序,序列长为 t</span></div><div class="line">  <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;t; ++t)</div><div class="line">    ShellInsert(L, dlta[k]);</div><div class="line">&#125; <span class="comment">// ShellSort</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsert</span> <span class="params">( SqList &amp;L, <span class="keyword">int</span> dk )</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> ( i=dk+<span class="number">1</span>; i&lt;=n; ++i )<span class="comment">// 对每个元素在当前增量子序列中排序</span></div><div class="line">    <span class="keyword">if</span> ( L.r[i].key&lt; L.r[i-dk].key) &#123;<span class="comment">// 在子序列中用直接插入法排序当前元素</span></div><div class="line">      L.r[<span class="number">0</span>] = L.r[i];</div><div class="line">      <span class="keyword">for</span> (j=i-dk; j&gt;<span class="number">0</span>&amp;&amp;(L.r[<span class="number">0</span>].key&lt;L.r[j].key); j-=dk)</div><div class="line">        L.r[j+dk] = L.r[j]; <span class="comment">// 记录后移,查找插入位置</span></div><div class="line">      L.r[j+dk] = L.r[<span class="number">0</span>]; <span class="comment">// 插入</span></div><div class="line">    &#125; <span class="comment">// if</span></div><div class="line">&#125; <span class="comment">// ShellInsert</span></div></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<p>希尔排序是一种不稳定的插入排序方法。</p>
<ul>
<li>希尔排序的时间复杂性与各列内部排序的算法 ( 插入 ) 由关。内部排序不一定是高效的,但需要是 input-sensitive</li>
<li>但其实际运行的时间更多地取决于所取“增量”序列的有关,涉及数学上尚未解决的难题。</li>
</ul>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种借助“多关键字排序”的思想来实现“单关键字排序”的内部排序算法。</p>
<p>实现多关键字排序通常有两种作法 :</p>
<p>关键字${K^0&gt;K^1&gt;…&gt;K^{d-1}}$</p>
<ul>
<li>最高位优先 MSD 法 (Most Significant Digit first ) </li>
</ul>
<p>先对 K 进行排序,按 $K^0$ 的不同值将记录序列分成若干子序列之后,分别对 $K^1$ 进行排,…,最后对最次位关键字排序。</p>
<ul>
<li>最低位优先 LSD 法 (Least Significant Digit first)</li>
</ul>
<p>先对$ K^{d-1}$ 进行排序,然后对$ K^{d-2}$ 进行排序, …, 最后对最主位关键字 $K^0 $排序。</p>
<p><strong>对比</strong></p>
<p>最高位优先法</p>
<ul>
<li>必须将序列逐层分割为若干子序列,然后对各子序列分别进行排序 。</li>
</ul>
<p>最低位优先法</p>
<ul>
<li>使用这种排序方法对每一个关键字进行排序时,不必分成子序列,对每个关键字都是整个序列参加排序。</li>
<li>按 LSD 排序时,可以通过若干次“分配”和“收集”来实现排序。其好处是不需要进行关键字间的比较。</li>
</ul>
<p><strong>实现</strong></p>
<p>在计算机上实现基数排序时,为减少所需辅助存储空间,应采用链表作存储结构,即链式基数排序,具体作法为:</p>
<ol>
<li>待排序记录以指针相链,构成一个链表;</li>
<li>“分配” 时,按当前“关键字位”所取值,将记录分配到不同的 “链队列” 中,每个队列中记录的 “关键字位” 相同;</li>
<li>“收集”时,按当前关键字位取值从小到大将各队列首尾相链成一个链表 ；</li>
<li>对每个关键字位均重复 2) 和 3) 两步。</li>
</ol>
<p><strong>链表基数排序算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM_OF_KEY 8</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RADIX 10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SPACE 10000</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</div><div class="line">   KeysType keys[MAX_NUM_OF_KEY];</div><div class="line">   InfoType otheritems;</div><div class="line">   <span class="keyword">int</span> next;</div><div class="line">&#125;SLCell;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</div><div class="line">   SLCell r[MAX_SPACE];</div><div class="line">   <span class="keyword">int</span> keynum;</div><div class="line">   <span class="keyword">int</span> recnum;</div><div class="line">&#125;SLList;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArrType[RADIX];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Distribute</span><span class="params">(SLCell &amp;r, <span class="keyword">int</span> I, ArrType &amp;f, ArrType &amp;e)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;RADIX; ++j) f[j] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (p=r[<span class="number">0</span>].next; p; p= r[p].next)&#123;</div><div class="line">           j = r[p].keys[i];</div><div class="line">           <span class="keyword">if</span> (!f[j])  f[j] = p;</div><div class="line">           <span class="keyword">else</span>  r[e[j]].next = p;</div><div class="line">           e[j] = p;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function">Void <span class="title">Collect</span><span class="params">(SLCell &amp;r, <span class="keyword">int</span> I, ArrType f, ArrType e)</span></span>&#123;</div><div class="line">      <span class="keyword">for</span> (j=<span class="number">0</span>; !f[j]; j = succ(j));</div><div class="line">      r[<span class="number">0</span>].next = f[j]; t = e[j];</div><div class="line">      <span class="keyword">while</span> (j&lt;RADIX)&#123;</div><div class="line">                <span class="keyword">for</span> (j=succ(j); j&lt;RADIX<span class="number">-1</span>&amp;&amp;!f[j]; j = succ(j));</div><div class="line">                <span class="keyword">if</span> (f[j]) &#123; r[t].next = f[j]; t = e[j];&#125;</div><div class="line">      &#125;</div><div class="line">      r[t].next = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function">Void <span class="title">Radixsort</span><span class="params">(SLList &amp;L)</span></span>&#123;</div><div class="line">    <span class="comment">//L是静态链表表示的顺序表</span></div><div class="line">    <span class="comment">//对L作基数排序，使得L成为自小到大的有序静态链表</span></div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>；i&lt;L.recnum;；++i）L.r[i].next = i+<span class="number">1</span>；</div><div class="line">    L.r[L.recnum].next = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;L.recnum; ++i)&#123;</div><div class="line">           Distribute(L.r, i,  f, e);</div><div class="line">            Collect(L.r, I, f, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<ul>
<li>若每个排序码有 d 位 , 需要重复执行 d 趟“分配”与“收集”。每趟对 n 个元素进行“分配”,对 radix 个队列进行“收集”。总时间复杂度为O(d(n+radix))</li>
<li>若基数 radix 相同 , 对于元素个数较多而排序码位数较少的情况 , 使用链式基数排序较好。</li>
<li>基数排序需要增加 n+2radix 个附加链接指针。</li>
<li>基数排序是稳定的排序方法。</li>
</ul>
<h3 id="2-路插入排序"><a href="#2-路插入排序" class="headerlink" title="2-路插入排序"></a>2-路插入排序</h3><ul>
<li>2- 路插入排序是在折半插入排序的基础上进行的改进,目的是减少排序过程中记录移动的次数。</li>
<li>算法的思想为:另设一个和原始待排序列 L 相同的数组D ,该数组是一个循环向量。首先将 L[1] 复制给 D[1] ,并把 D[1]看成是已排好序的序列中处于中间位置的元素,之后将 L 中的从第二个元素开始依次插入到数组 D 中。</li>
</ul>
<h3 id="表插入排序"><a href="#表插入排序" class="headerlink" title="表插入排序"></a>表插入排序</h3><p>为了减少在排序过程中进行的“移动”记录的操作，静态链表结构可以避免元素移动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100  </span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  &#123;  </div><div class="line">  RcdType  rc;  </div><div class="line">  <span class="keyword">int</span> next;  </div><div class="line">&#125;SLNode;  </div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  &#123;  </div><div class="line">  SLNode numbers[SIZE];  </div><div class="line">  <span class="keyword">int</span> length;  </div><div class="line">&#125;SLinkList;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LInsertionSort</span> <span class="params">(Elem SL[ ] , <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line"><span class="comment">// 对记录序列 SL[1..n] 作表插入排序</span></div><div class="line">  SL[<span class="number">0</span>].key = MAXINT ;</div><div class="line">  SL[<span class="number">0</span>].next = <span class="number">1</span>; </div><div class="line">  SL[<span class="number">1</span>].next = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> ( i=<span class="number">2</span>; i&lt;=n; ++i )&#123; <span class="comment">// 逐个将 i 插入已排好 [1..i-1] 中</span></div><div class="line">    <span class="keyword">for</span> ( j=<span class="number">0</span>, k = SL[<span class="number">0</span>].next; SL[k].key&gt;=SL[i].key ;j=k, k=SL[k].next ); <span class="comment">// 从表头开始寻找插入位置</span></div><div class="line">    SL[j].next = i;</div><div class="line">    SL[i].next = k;</div><div class="line">  &#125;</div><div class="line">&#125;<span class="comment">// LinsertionSort</span></div></pre></td></tr></table></figure>
<p>表插入排序的结果只是求得一个有序链表。为了方便查找，需要对结果进行重新排列求得一个有序数组。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>各种排序方法之间的比较：</p>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>比较次数(最好)</th>
<th>比较次数(最差)</th>
<th>移动次数(最好)</th>
<th>移动次数(最差)</th>
<th>稳定性</th>
<th>附加存储</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td>n</td>
<td>n^2</td>
<td>0</td>
<td>n^2</td>
<td>稳定</td>
<td>1</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>n</td>
<td>n^2</td>
<td>0</td>
<td>n^2</td>
<td>稳定</td>
<td>1</td>
</tr>
<tr>
<td>快速排序</td>
<td>nlog2n</td>
<td>n^2</td>
<td>log2n</td>
<td>n</td>
<td>不稳定</td>
<td>log2n</td>
</tr>
<tr>
<td>堆排序</td>
<td>nlog2n</td>
<td></td>
<td>nlog2n</td>
<td></td>
<td>不稳定</td>
<td>1</td>
</tr>
<tr>
<td>归并排序</td>
<td>nlog2n</td>
<td></td>
<td>nlog2n</td>
<td></td>
<td>稳定</td>
<td>n</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;排序:将一组杂乱无章的数据按一定的规律顺次排列起来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设含 n 个记录的序列为 { R1, R2, … , Rn }其相应的关键字序列为 { K1, K2, … , Kn }这些关键字相互之间可以进行比较,即在它们之间存在着这样一个关系 :&lt;/p&gt;
&lt;p&gt;Kp1≤Kp2≤…≤Kpn&lt;br&gt;按此固有关系将上式记录序列重新排列,即使序列成为一个按关键字排序的 序列:{ Rp1, Rp2, … , Rpn }的操作称作排序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排序算法的稳定性 : 当输入含重复关键字时,重复元素在输入、输出序列中的相对次序是否保持不变。&lt;/li&gt;
&lt;li&gt;内排序与外排序 : 内排序是指在 整个排序过程 数据元素全部存放在内存、 不需要访问外存便能完成 的排序, 称此类排序为内部排序 ; 反之,若参加排序的记录数量很大 ,不能同时存放在内存,必须根据排序过程的要求,不断在内、外存之间移动的排序, 称为外部排序。&lt;/li&gt;
&lt;li&gt;排序算法的分类 :内部排序算法很多。但就其全面性能而言,很难认为哪种方法是最好的。没一种方法都有各自的优缺点,适合在不同环境下使用。插入排序、交换排序、选择排序、归并排序、计数排序等等 &amp;lt; 按排序过程中依据的不同原则 &amp;gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Data-Structures" scheme="http://ucasfl.me/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>查找和搜索-Part3</title>
    <link href="http://ucasfl.me/2017/08/07/Find-and-Search-Part3/"/>
    <id>http://ucasfl.me/2017/08/07/Find-and-Search-Part3/</id>
    <published>2017-08-07T04:51:28.000Z</published>
    <updated>2017-09-02T04:38:29.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="键树-数字查找树"><a href="#键树-数字查找树" class="headerlink" title="键树 / 数字查找树"></a>键树 / 数字查找树</h3><p>Keyword Tree/Digital Search Tree 是关键字的一种组织方式,其具有下列特征:</p>
<ul>
<li>( 结点 ) 树的结点包含组成关键字的符号，关键字中的各个符号分布在从根结点到叶的路径上,叶结点内的符号为“结束”的标志符。</li>
<li>键树的深度和关键字集合的大小无关,取决于关键字中字符或数位的个数</li>
<li>( 多叉 ) 度大于 2 的树，每个结点的最大度与关键字的“基”有关</li>
<li>( 排序 ) 键树被约定为是一棵有序树,即同一层中兄弟结点之间依所含符号自左至右有序,并约定结束符‘ $’ 小于任何其它符号。</li>
</ul>
<p><strong>键树的存储结构:双链树</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> DLTNode &#123;</div><div class="line">  <span class="keyword">char</span> symbol;</div><div class="line">  <span class="keyword">struct</span> DLTNode *next; <span class="comment">// 指向兄弟结点的指针</span></div><div class="line">  NodeKind kind;</div><div class="line">  <span class="keyword">union</span> &#123;</div><div class="line">    Record *infoptr; <span class="comment">// 叶子结点内的记录指针</span></div><div class="line">    <span class="keyword">struct</span> DLTNode *first;</div><div class="line"><span class="comment">// 分支结点内的孩子链指针</span></div><div class="line">  &#125;</div><div class="line">&#125; DLTNode, *DLTree; <span class="comment">// 双链树的类型</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>在双链树中查找记录</strong></p>
<ul>
<li>假设: T 为指向双链树根结点的指针, K.ch 为待查关键字 ( 由 k.ch[0]..k.ch[num-2] 的字符组成, k.ch[num-1] 为 $)</li>
<li>查找过程: 从树根出发,沿 first 指针到结点 p ,进行比较K.ch[i] =? p-&gt;symbol ,其中, 0 ≤ i ≤ K.num-1， 若相等,沿 first 指针比较下一个字符， 若不等,沿 next 指针顺序查找</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXKEYLEN 20</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  <span class="keyword">char</span> ch[MAXKEYLEN]; <span class="comment">// 关键字</span></div><div class="line">  <span class="keyword">int</span> num;</div><div class="line"><span class="comment">// 关键字长度</span></div><div class="line">&#125; KeysType;</div><div class="line"><span class="comment">// 关键字类型</span></div><div class="line"><span class="function">RECORD *<span class="title">SearchDLTree</span><span class="params">(DLTree T, KeysType K)</span> </span>&#123;</div><div class="line">  DLTree p; <span class="keyword">int</span> i;</div><div class="line">  p = T-&gt;first; i=<span class="number">0</span>; <span class="comment">// 初始化</span></div><div class="line">  <span class="keyword">while</span> (p &amp;&amp; i&lt;K.num) &#123;</div><div class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;symbol != K.ch[i]) <span class="comment">// 查找关键字的第 i 位</span></div><div class="line">      p = p-&gt;next;</div><div class="line">    <span class="keyword">if</span> (p &amp;&amp; i&lt;K.num<span class="number">-1</span>) </div><div class="line">      p = p-&gt;first; <span class="comment">// 准备查找下一位</span></div><div class="line">    ++i; </div><div class="line">  &#125; <span class="comment">// 查找结束</span></div><div class="line">  <span class="keyword">if</span> (!p) </div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 查找不成功</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> p-&gt;infoptr; <span class="comment">// 查找成功</span></div><div class="line">&#125; <span class="comment">//Search DLTree</span></div></pre></td></tr></table></figure>
<p><strong>键树的存储结构: Trie 树</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> TrieNode &#123;</div><div class="line">  NodeKind kind; <span class="comment">// 结点类型</span></div><div class="line">  <span class="keyword">union</span> &#123;</div><div class="line">    <span class="keyword">struct</span> &#123; </div><div class="line">      KeyType K;</div><div class="line">      Record *infoptr</div><div class="line">    &#125; lf;</div><div class="line"><span class="comment">// 叶子结点 ( 关键字和指向记录的指针 )</span></div><div class="line">    <span class="keyword">struct</span> &#123;</div><div class="line">      TrieNode *ptr[<span class="number">27</span>]; </div><div class="line">      <span class="keyword">int</span> num </div><div class="line">    &#125; bh;</div><div class="line"><span class="comment">// 分支结点 (27 个指向下一层结点的指针 )</span></div><div class="line">  &#125;</div><div class="line">&#125; TrieNode, *TrieTree; <span class="comment">// 键树类型T</span></div></pre></td></tr></table></figure>
<p><strong>在Trie树中查找记录</strong></p>
<ul>
<li>假设 :</li>
</ul>
<p>– T 为指向 Trie 树根结点的指针, K.ch 为待查关键字 ( 由 k.ch[0]..k.ch[num-2] 的字符组成, k.ch[num-1] 为 $)</p>
<ul>
<li>查找过程:</li>
</ul>
<p>– 从树根出发,搜索和对应字母相应的指针 p:<br>– 若 p 不空,且 p 所指为分支结点,则<br>– p= p-&gt;bh.ptr[ord(K.ch[i])] ( 其中, ord 给出字符<br>在字母表中的序号, 0 ≤ i ≤ K.num-1 )<br>– 沿 p 指针比较下一个字符,直到叶子结点<br>– 若未找到 p ,则查找不成功</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在键树 T 中查找关键字等于 K 的记录</span></div><div class="line"><span class="comment">//ord 求字符在字母表中序号</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ord</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> c-<span class="string">'@'</span>; </div><div class="line">&#125;</div><div class="line"><span class="function">RECORD *<span class="title">SearchTrie</span><span class="params">(TrieTree T, KeysType K)</span> </span>&#123;</div><div class="line">  TrieTree p; <span class="keyword">int</span> i;</div><div class="line"><span class="comment">// 对 K 的每个字符逐个查找, *p 为分支结点</span></div><div class="line">  <span class="keyword">for</span> (p=T, i=<span class="number">0</span>; p &amp;&amp; p-&gt;kind==BRANCH &amp;&amp; i&lt;K.num;p=p-&gt;bh.ptr[ord(K.ch[i])], i++) ;</div><div class="line">  <span class="keyword">if</span> (p &amp;&amp; p-&gt;kind==LEAF &amp;&amp;<span class="built_in">strcmp</span>(p-&gt;lf.K.ch, K.ch)==<span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> p-&gt;lf.infoptr; <span class="comment">// 查找成功</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 查找不成功</span></div><div class="line">&#125; <span class="comment">//SearchTrie</span></div></pre></td></tr></table></figure>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><strong>基本思想</strong></p>
<ul>
<li>Motivation :已有的查找方法需要进行一系列的指定值与数据元素的关键字的比较</li>
</ul>
<p>– 不同的查找其差别在于关键字和给定值进行比较的顺序不同<br>– 原因:数据元素的关键字和数据元素的存储位置之间没有确定的关系<br>– 结果:查找的效率取决于和给定值进行比较的关键字的个数</p>
<ul>
<li>Solution : ( 通过哈希函数和冲突处理方法 ) 由记录的关键字确定记录在表中的地址,并将记录放入此地址,这样构成的表叫哈希表</li>
</ul>
<p>– 哈希查找 ( 又叫散列查找 ) :通过哈希表中的对应关系进行一次存取,就能得到所查的元素<br>– 特别适用于,只知道关键字的所属范围,但不知道确切的关键字</p>
<p><strong>基本概念</strong></p>
<ul>
<li>哈希函数:在记录的关键字与记录的存储地址之间建立了一种确定的对应关系</li>
</ul>
<p>– 哈希函数是一种映象,是从关键字空间到存储地址空间的一种映象。<br>– 对于记录 ai , addr(ai) =H(ki) ,其中, addr(ai)是 ai 的地址, ki 是记录 ai 的关键字<br>– 哈希函数通常是一种压缩映象,所以冲突不可避免<br>– 冲突:对于关键字 ki 、 kj ,若 ki!=kj ,但 H(ki)=H(kj) 的现象叫冲突 (collision)<br>– 同义词:具有相同哈希函数值的两个不同的关键字,称为该哈希函数的同义词</p>
<p><strong>哈希表设计要素</strong></p>
<ul>
<li>确定哈希函数的定义域 ( 所有关键字 ) 和值域(0… m-1)</li>
<li>构造合适的哈希函数</li>
</ul>
<p>– 使得同一关键字总被映射到同一地址<br>– 使得对于所有可能的元素 ( 记录的关键字 ) ,其函数值能尽可能覆盖整个地址空间且均匀地映射到地址空间</p>
<p>​                  - 所谓均匀 (uniform) 是指从一个关键字映射到地址集合中任何一个地址的概率是相等的,即使得发生冲突的可能性尽可能最少</p>
<p>– 哈希函数的构造简单,能在较短的时间内计算出来。</p>
<ul>
<li>冲突元给出处理冲突的方法,即当冲突出现时如何为冲突元素找到另一个存储位置。</li>
</ul>
<h4 id="哈希函数的构造"><a href="#哈希函数的构造" class="headerlink" title="哈希函数的构造"></a>哈希函数的构造</h4><p><strong>直接定址法</strong></p>
<p>直接定址法:取关键字或关键字的某个线性函数作哈希地址,即:H(key)=key 或 H(key)=a·key+b (a,b 为常数 )</p>
<ul>
<li>特点:直接定址法所得地址集合与关键字集合大小相等,不会发生冲突,但实际中很少使用</li>
<li>举例:根据年份查找该年份的人口数量</li>
</ul>
<p><strong>数字分析法</strong></p>
<p>数字分析法:若关键字为以 r 为基的数,取关键字的若干位或组合作为哈希地址</p>
<ul>
<li>特点:适用于关键字位数比哈希地址位数大,且事先知道可能出现的关键字的情况 ( 如频度 )</li>
</ul>
<p><strong>平方取中法</strong></p>
<p>平方取中法:将关键字平方后取中间几位作为哈希地址</p>
<ul>
<li>哈希函数所取的位数由哈希表的长度决定</li>
</ul>
<ul>
<li>特点:一个数平方后中间几位和数的每一位都有关,则由随机分布的关键字得到的哈希地址也是随机的</li>
</ul>
<p>– 适用于:不知道全部关键字情况<br>– 适用于:关键字中的每一位都有某些数字重复出现</p>
<p><strong>折叠法</strong></p>
<p>折叠法 (folding) :将关键字分割成位数相同的几部分 ( 最后一部分可以不同 ) ,然后取这几部分的叠加和作为哈希地址</p>
<ul>
<li>数位叠加有移位叠加和间界叠加</li>
</ul>
<p>– 移位叠加:将分割后的几部分低位对齐相加<br>– 间界叠加:从一端到另一端沿分割界来回折迭,然后对齐相加</p>
<ul>
<li>特点:适于关键字位数很多,且每一位上数字分布大致均匀</li>
</ul>
<p><strong>除留余数法</strong></p>
<p>除留余数法:取关键字被某个不大于哈希表表长 m 、但最接近于或等于 m 的质数 p 除后所得余数作哈希地址,即:<br>H(key) = key MOD p (p $\le$ m)<br>– 从 p 到 (m-1) 的地址可以在处理冲突的时候用</p>
<ul>
<li>特点:简单、常用的哈希函数构造方法</li>
<li>一般,哈希函数可以设成:</li>
</ul>
<p>H(key) =(a*key+b) MOD p  (a&gt;0, b&gt;0, a MOD p!=0, p 为素数 )</p>
<p>p的选取：</p>
<ul>
<li>选取$p=2^i(p\le m)$  :便于用移位来实现运算,但等于将关键字的高位忽略而仅留下低位二进制数,因此,高位不同而低位相同的关键字都成为了同义词</li>
<li>选取 $p=q\times f$ (q 、 f 都是 p 的质因数, p$\le $m) :则所有含有 q 或 f 因子的关键字的哈希地址均是 q或 f 的倍数</li>
</ul>
<p><strong>随机数法</strong></p>
<p>随机数法:取关键字的随机函数值作哈希地址,即 H(key)=random(key)</p>
<ul>
<li>当哈希表中关键字长度不等时,该方法比较合适</li>
</ul>
<p><em>选取哈希函数时应考虑的因素</em></p>
<ul>
<li>计算哈希函数所需时间</li>
<li>关键字的长度</li>
<li>哈希表长度 ( 即哈希地址范围 )</li>
<li>关键字分布情况</li>
<li>记录的查找频率</li>
</ul>
<h4 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h4><p><strong>开放定址法</strong></p>
<ul>
<li>当冲突发生时,形成某个探测序列;按此序列逐个探测哈希表中的其他地址,直到为给定的关键字找到一个空地址 ( 开放的地址 ) 为止,将发生冲突的记录放到该地址中</li>
<li>哈希地址的计算公式是:</li>
</ul>
<p>H0 =H(key)<br>Hi (key)=(H(key)+di ) MOD m , i=1, 2, …, m-1<br>– 其中: H(key) 为哈希函数; m 是哈希表长度; Hi (key) 为经第 i 次探测后得到的哈希地址; di 是第 i 次探测时的增量序列</p>
<ul>
<li>根据 di 的形成方法,有:</li>
</ul>
<p>– 线性探测法 (Linear Probing)<br>– 二次探测法 (Quadratic Probing)<br>– 伪随机探测法: 用伪随机函数获得伪随机数列</p>
<p><em>线性探测法</em></p>
<ul>
<li>将哈希表 T[0 …m-1] 看成循环向量。当发生冲突时,从初次发生冲突的位置依次向后探测其他的地址,即: 增量序列为: di=1, 2, 3, …, m-1</li>
<li>设初次发生冲突的地址是 h ,则依次探测 T[h+1] , T[h+2]… ,直到 T[m-1] 时又循环到表头,再次探测 T[0] , T[1]… ,直到 T[h-1]</li>
<li>探测过程终止的情况:</li>
</ul>
<p>– 探测到的地址为空:表中没有记录。若是查找操作则失败;若是插入操作，则将记录写入到该地址<br>– 探测到的地址有给定的关键字:若是查操作找则成功;若是插入操作则失败<br>– 直到 T[h] :仍未探测到空地址或给定的关键字,则表示哈希表满</p>
<ul>
<li>线性探测法的特点:</li>
</ul>
<p>– 优点:只要哈希表未满,总能找到一个不冲突的哈希地址<br>– 缺点:二次聚集 ( 两个第一次哈希地址不同的记录争夺同一个后继哈希地址 )</p>
<p><em>二次探测法</em></p>
<ul>
<li>增量序列为: $d_i=1^2,-1^2,2^2,-2^2,3^2,……+k^2,- k^2 (k\le ⌊ m/2 ⌋ )$</li>
</ul>
<p>– 当 M 是质数,且装填因子小于等于 0.5 ,可以找出空闲地址<br>– 表长 m 形如 4j+3 的质数 ( 如 7, 11, 19, 23, 31, 43, … 等 ) 时,可以保证查找链的前 m 项均互异:基于 费马双平方定理</p>
<ul>
<li>除了 2 这个特殊的素数,所有的素数都可以分两类:被 4 除余 1 的素数,如 5 , 13 , 17 , 29 , 37 , 41 ,这类素数都能表示为两个整数的平方和;第二类则是被 4 除余 3 的素数如 3, 7 , 11 , 19 , 23 , 31 。这类不能表示为两个整数的平方和。</li>
<li>优点:探测序列跳跃式地哈希到整个表中,不易产生冲突的聚集现象</li>
<li>缺点:不能保证探测到哈希表的所有地址</li>
</ul>
<p><strong>再哈希法</strong></p>
<ul>
<li>构造若干个哈希函数,当发生冲突时,利用不同的哈希函数再计算下一个新哈希地址,直到不发生冲突为止,</li>
</ul>
<p>– 即: Hi =RHi (key) i=1, 2, …, k<br>– 其中, RHi 为一组不同的哈希函数。第一次发生冲突时,用 RH1 计算,第二次发生冲突时,用 RH2 计算,依此类推直到到某个 Hi 不发生冲突为止</p>
<ul>
<li>优点:不易产生冲突的聚集现象</li>
<li>缺点:计算时间增加</li>
</ul>
<p><strong>链地址法</strong></p>
<ul>
<li>将所有关键字为同义词 ( 哈希地址相同 ) 的记录存储在一个单链表中,并用一维数组存放链表的头指针</li>
<li>设哈希表长为 m ,定义一个一维指针数组: RecNode *linkhash[m] ,其中 RecNode 是结点类型,每个分量的初值为空。凡哈希地址为 k 的记录都插入到以 linkhash[k] 为头指针的链表中,插入位置可以在表头或表尾或按关键字排序插入</li>
<li>优点:不易产生冲突的聚集;删除记录也很简单</li>
</ul>
<p><strong>建立公共溢出区</strong></p>
<ul>
<li>在基本哈希表之外,另外设立一个溢出表保存与基本表中记录冲突的所有记录</li>
<li>设哈希表长为 m ,设立基本哈希表 Hashtable[m],每个分量保存一个记录;溢出表 Overtable[m],一旦某个记录的哈希地址发生冲突,都填入溢出表中</li>
</ul>
<h3 id="哈希查找过程"><a href="#哈希查找过程" class="headerlink" title="哈希查找过程"></a>哈希查找过程</h3><ul>
<li>哈希表的主要目的是用于快速查找,且插入和删除操作都要用到查找</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开放定址哈希表的结构</span></div><div class="line"><span class="keyword">int</span> hashsize[] = &#123; <span class="number">997</span>, ... &#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  ElemType *elem; <span class="comment">//ElemType 中含 key</span></div><div class="line">  <span class="keyword">int</span> count; <span class="comment">// 当前数据元素个数</span></div><div class="line">  <span class="keyword">int</span> sizeindex;<span class="comment">// hashsize[sizeindex] 为当前容量</span></div><div class="line">&#125; HashTable;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DUPLICATE -1</span></div><div class="line"></div><div class="line"><span class="comment">//在哈希表 H 中查找关键码为 K 的元素</span></div><div class="line"><span class="function">Status <span class="title">SearchHash</span><span class="params">(HashTable H, HKeyType K, <span class="keyword">int</span> &amp;p, <span class="keyword">int</span> &amp;c)</span> </span>&#123;</div><div class="line"><span class="comment">// 若查找成功,以 p 指示待查数据元素在表中位置,并返回</span></div><div class="line"><span class="comment">//SUCCESS ,否则,以 p 指示插入位置,并返回 UNSUCCESS,</span></div><div class="line"><span class="comment">//c 用以记录冲突次数,其初值置零,供建表插入时参考</span></div><div class="line">  p = Hash(K); <span class="comment">// 求得哈希地址</span></div><div class="line">  <span class="keyword">while</span> ((H.elem[p].key != NULLKEY) &amp;&amp; !equal(K, (H.elem[p].key))) <span class="comment">// 该位置中填有记录，并且关键字不相等</span></div><div class="line">    collision(p, ++c); <span class="comment">// 求得下一探查地址 p</span></div><div class="line">  <span class="keyword">if</span> (equal(K, (H.elem[p].key)))</div><div class="line">    <span class="keyword">return</span> SUCCESS;</div><div class="line"><span class="comment">// 查找成功, p 返回待查数据元素位置</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> UNSUCCESS;</div><div class="line"><span class="comment">// 查找不成功, p 返回的是插入位置</span></div><div class="line">&#125; <span class="comment">// SearchHash</span></div><div class="line"></div><div class="line"><span class="comment">//哈希表插入算法</span></div><div class="line"><span class="function">Status <span class="title">InsertHash</span><span class="params">(HashTable &amp;H, HElemType e)</span> </span>&#123;</div><div class="line"><span class="comment">// 查找不成功时插入数据元素 e 到开放定址哈希表 H 中,</span></div><div class="line"><span class="comment">// 并返回 OK ;若冲突次数过大,则重建哈希表</span></div><div class="line">  <span class="keyword">int</span> c = <span class="number">0</span>; <span class="keyword">int</span> p = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (SearchHash(H, e.key, p, c) == SUCCESS )</div><div class="line">    <span class="keyword">return</span> DUPLICATE;</div><div class="line"><span class="comment">// 表中已有与 e 有相同关键字的元素</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; H.cursize) &#123;</div><div class="line"><span class="comment">// 冲突次数 c 未达到上限 ( 阈值 c 可调 )</span></div><div class="line">    H.elem[p] = e; ++H.count;</div><div class="line">    <span class="keyword">return</span> SUCCESS; <span class="comment">// 插入 e</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    RecreateHashTable(H); <span class="comment">// 重建哈希表</span></div><div class="line">    <span class="keyword">return</span> UNSUCCESS; </div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">// InsertHash</span></div></pre></td></tr></table></figure>
<p><strong>哈希查找的性能分析</strong></p>
<ul>
<li>从哈希查找过程可见,尽管哈希表在关键字与记录的存储地址之间建立了直接映象,但由于存在冲突,查找过程仍是一个给定值与关键字进行比较的过程,仍要用 ASL 评价哈希查找效率</li>
<li>哈希查找时,关键字与给定值比较的次数取决于:</li>
</ul>
<p>– 哈希函数<br>– 处理冲突的方法<br>– 哈希表的填满因子：$\alpha=\frac{\text{表中填入的记录数}}{\text{哈希表的长度}}$</p>
<ul>
<li>一般情况下,可以认为选用的哈希函数是均匀的,则在讨论 ASL 时,可以不考虑它的因素</li>
<li>哈希表的ASL是填满因子$\alpha$的函数，而不是$n$的函数。</li>
<li>用哈希表构造查找表时，可以选择一个合适的填满因子，使得ASL限定在某个范围内。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;键树-数字查找树&quot;&gt;&lt;a href=&quot;#键树-数字查找树&quot; class=&quot;headerlink&quot; title=&quot;键树 / 数字查找树&quot;&gt;&lt;/a&gt;键树 / 数字查找树&lt;/h3&gt;&lt;p&gt;Keyword Tree/Digital Search Tree 是关键字的一种组织方式,其具有下列特征:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;( 结点 ) 树的结点包含组成关键字的符号，关键字中的各个符号分布在从根结点到叶的路径上,叶结点内的符号为“结束”的标志符。&lt;/li&gt;
&lt;li&gt;键树的深度和关键字集合的大小无关,取决于关键字中字符或数位的个数&lt;/li&gt;
&lt;li&gt;( 多叉 ) 度大于 2 的树，每个结点的最大度与关键字的“基”有关&lt;/li&gt;
&lt;li&gt;( 排序 ) 键树被约定为是一棵有序树,即同一层中兄弟结点之间依所含符号自左至右有序,并约定结束符‘ $’ 小于任何其它符号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;键树的存储结构:双链树&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; DLTNode &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; symbol;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; DLTNode *next; &lt;span class=&quot;comment&quot;&gt;// 指向兄弟结点的指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  NodeKind kind;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Record *infoptr; &lt;span class=&quot;comment&quot;&gt;// 叶子结点内的记录指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; DLTNode *first;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 分支结点内的孩子链指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; DLTNode, *DLTree; &lt;span class=&quot;comment&quot;&gt;// 双链树的类型&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Data-Structures" scheme="http://ucasfl.me/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>查找和搜索-Part2</title>
    <link href="http://ucasfl.me/2017/08/07/Find-and-Search-Part2/"/>
    <id>http://ucasfl.me/2017/08/07/Find-and-Search-Part2/</id>
    <published>2017-08-07T04:51:24.000Z</published>
    <updated>2017-09-02T04:38:29.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><ul>
<li>Motivation: 二叉排序树是一种查找效率比较高的数据组织形式,但其平均查找长度受树的形态影响较大,形态比较均匀时查找效率很好,形态明显偏向某一方向时其效率就大大降低。因此,希望有更好的二叉排序树,其形态总是均衡的,查找时能得到最好的效率</li>
<li>Solution: 平衡二叉排序树 (Balanced Binary Sort Tree) ,由 Adelson-Velskii 和 Landis于 1962 年提出的,故称 AVL 树</li>
<li>变种:红黑树,树堆,伸展树</li>
</ul>
<p><strong>基本概念</strong></p>
<p>平衡二叉树 (Balanced Binary Tree 或 Height-Balanced Tree) 或者是空树,或者是满足下列性质的二叉树</p>
<ul>
<li>左子树和右子树深度之差的绝对值不大于 1</li>
<li>左子树和右子树也都是平衡二叉树</li>
</ul>
<p>结点的平衡因子 (Balance Factor) :该结点的右子树的深度减去其左子树深度</p>
<ul>
<li>平衡二叉树上每个结点的平衡因子只可能是 1 、 0和 -1</li>
<li>平衡二叉排序树 (Balanced Binary Sort Tree) :一棵二叉树既是二叉排序树又是平衡二叉树</li>
</ul>
<a id="more"></a>
<p><strong>结构定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BSTNode &#123;</div><div class="line">  ElemType data;</div><div class="line">  <span class="keyword">int</span> bf; <span class="comment">// 平衡因子</span></div><div class="line">  <span class="keyword">struct</span> BSTNode *lchild , *rchild;</div><div class="line">&#125; BSTNode, *BSTree;</div></pre></td></tr></table></figure>
<p><strong>平衡化旋转</strong></p>
<ul>
<li>如果在一棵平衡的二叉排序树中插入一个新结点,造成了不平衡。此时必须调整树的结构,使之平衡化</li>
<li>每插入一个新结点时, AVL 树中相关结点的平衡状态会发生改变。因此,在插入一个新结点后,需要从插入位置沿通向根的路径回溯,检查各结点的平衡因子</li>
<li>如果在某一结点发现不平衡,停止回溯。从发生不平衡的结点起,沿刚才回溯的路径取直接下两层的结点</li>
<li>如果这三个结点处于一条直线上,则采用单旋转进行平衡化。单旋转可按其方向分为左单旋转和右单旋转 , 其中一个是另一个的镜像,其方向与不平衡的形状相关</li>
<li>如果这三个结点处于一条折线上,则采用双旋转进行平衡化。</li>
</ul>
<p><strong>右单旋转(RotateRight) : LL 型</strong></p>
<ul>
<li>在结点 A 的左子女的左子树 D 上插入新结点使其高度增 1 导致结点 A 的平衡因子增到 -2 ,造成不平衡</li>
<li>为使树恢复平衡,从 A 沿插入路径连续取 3个结点 A 、 B 和 D ,以结点 B 为旋转轴,将结点 A 顺时针旋转</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BSTree &amp;p)</span> </span>&#123;</div><div class="line"><span class="comment">// 对以 *p 为根的二叉排序树作右旋处理</span></div><div class="line"><span class="comment">// 处理之后 p 指向新的树根结点,</span></div><div class="line"><span class="comment">// 即旋转处理之前的左子树的根结点</span></div><div class="line">  BSTree lc;</div><div class="line">  lc = p-&gt;lchild; <span class="comment">//lc 指向 *p 的左子树根结点</span></div><div class="line">  p-&gt;lchild = lc-&gt;rchild;</div><div class="line"><span class="comment">// lc 的右子树挂接为 *p 的左子树</span></div><div class="line">  lc-&gt;rchild = p;</div><div class="line">  p = lc; <span class="comment">//p 指向新的根结点</span></div><div class="line">&#125; <span class="comment">// R_Rotate</span></div></pre></td></tr></table></figure>
<p><strong>左单旋转 (RotateLeft) : RR 型</strong></p>
<ul>
<li>在结点 A 的右子女的右子树 E 中插入新结点,该子树高度增 1 导致结点 A 的平衡因子变成 2 ,出现不平衡</li>
<li>为使树恢复平衡,从 A 沿插入路径连续取 3个结点 A 、 C 和 E ,以结点 C 为旋转轴,让结点 A 反时针旋转 p</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BSTree &amp;p)</span> </span>&#123;</div><div class="line"><span class="comment">// 对以 *p 为根的二叉排序树作左旋处理</span></div><div class="line"><span class="comment">// 处理之后 p 指向新的树根结点</span></div><div class="line"><span class="comment">// 即旋转处理之前的右子树的根结点</span></div><div class="line">  BSTree rc;</div><div class="line">  rc = p-&gt;rchild; <span class="comment">//rc 指向 *p 的右子树根结点</span></div><div class="line"><span class="comment">//rc 的左子树挂接为 *p 的右子树</span></div><div class="line">  p-&gt;rchild = rc-&gt;lchild;</div><div class="line">  rc-&gt;lchild = p;</div><div class="line"><span class="comment">//p 指向新的根结点</span></div><div class="line">  p = rc;</div><div class="line">&#125; <span class="comment">//L_Rotate</span></div></pre></td></tr></table></figure>
<p><strong>先左后右双旋转 (RotationLeftRight)-LR 型</strong></p>
<ul>
<li>在结点 A 的左子女的右子树中插入新结点,该子树高度增 1 导致结点 A 的平衡因子变为 -2 ,造成不平衡</li>
<li>以结点 E 为旋转轴,将结点 B 反时针旋转,以 E 代替原来 B 的位置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LR_Rotate</span> <span class="params">(BSTree &amp;p)</span> </span>&#123;</div><div class="line"><span class="comment">// 对以 *p 为根的二叉排序树做先左后右旋转</span></div><div class="line">  BSTree lc,rc;</div><div class="line"><span class="comment">// 初始化</span></div><div class="line">  rc =p; lc =rc-&gt;lchild;</div><div class="line">  p=lc-&gt;rchild; <span class="comment">// 重新确定根</span></div><div class="line">  lc-&gt;rchild=p-&gt;lchild; <span class="comment">// 为 BF 拉链</span></div><div class="line">  p-&gt;lchild=lc; <span class="comment">// 设置新根的左孩子,为 EB 拉链</span></div><div class="line">  rc-&gt;lchild=p-&gt;rchild; <span class="comment">// 为 AG 拉链</span></div><div class="line">  p-&gt;rchild=rc; <span class="comment">// 为 EA 拉链</span></div><div class="line">&#125; <span class="comment">// LR_Rotate</span></div></pre></td></tr></table></figure>
<p><strong>先右后左双旋转 (RotationRightLeft)-RL 型</strong></p>
<ul>
<li>在结点 A 的右子女的左子树中插入新结点,该子树高度增 1 。结点 A 的平衡因子变为 2 ,发生了不平衡</li>
<li>首先以结点 D 为旋转轴,将结点 C 顺时针旋转,以 D 代替原来 C 的位置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RL_Rotate</span> <span class="params">(BSTree &amp;p)</span> </span>&#123;</div><div class="line"><span class="comment">// 对以 *p 为根的二叉排序树做先右后左旋转</span></div><div class="line">  BSTree lc,rc;</div><div class="line"><span class="comment">// 初始化</span></div><div class="line">  lc =p; rc =lc-&gt;rchild;</div><div class="line">  p=rc-&gt;lchild;</div><div class="line">  rc-&gt;lchild=p-&gt;rchild;</div><div class="line">  p-&gt;rchild=rc;</div><div class="line">  lc-&gt;rchild=p-&gt;lchild;</div><div class="line">  p-&gt;lchild=lc;</div><div class="line">&#125; <span class="comment">// RL_Rotate</span></div></pre></td></tr></table></figure>
<p><strong>AVL 树的插入</strong></p>
<ul>
<li>AVL 树的插入算法是从一棵空树开始,通过输入一系列关键字,逐步建立 AVL 树</li>
<li>在向一棵本来是平衡的 AVL 树中插入一个新结点时,需从插入结点沿通向根的路径向上回溯,如果某个结点的平衡因子的绝对值 |bf| &gt; 1 ,那么需从这个结点出发,使用平衡旋转方法进行平衡化处理</li>
</ul>
<p>算法实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LH -1 <span class="comment">// 左高</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EH 0 <span class="comment">// 等高</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RH 1 <span class="comment">// 右高</span></span></div><div class="line"><span class="function">Status <span class="title">InsertAVL</span><span class="params">(BSTree &amp;T, ElemType e, Boolean &amp;taller)</span> </span>&#123;</div><div class="line"><span class="comment">// 若在平衡的二叉排序树 T 中不存在和 e 有相同关键字的结点,</span></div><div class="line"><span class="comment">// 则插入一个数据元素为 e 的新结点,并返回 1 ,否则返回0 。</span></div><div class="line"><span class="comment">// 若因插入而使二叉排序树失去平衡,则作平衡旋转处理,</span></div><div class="line"><span class="comment">// 布尔变量 taller 反映 T 长高与否</span></div><div class="line">  <span class="keyword">if</span> (!T) &#123; <span class="comment">// 插入新结点,树 " 长高 " ,置 taller 为 TRUE</span></div><div class="line">    T = (BSTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BSTNode));</div><div class="line">    T-&gt;data = e; T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</div><div class="line">    T-&gt;bf = EH; taller = TRUE; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (EQ(e.key, T-&gt;data.key))&#123;</div><div class="line">      taller = <span class="literal">false</span>;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//已经存在记录，不再插入</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (LT(e.key, T-&gt;data.key)) &#123;</div><div class="line"><span class="comment">// 应继续在 *T 的左子树中进行搜索</span></div><div class="line">      <span class="keyword">if</span> (InsertAVL(T-&gt;lchild, e, taller)==<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未插入</span></div><div class="line">      <span class="keyword">if</span> (taller) <span class="comment">// 插入到 *T 的左子树中且左子树 " 长高“</span></div><div class="line">        <span class="keyword">switch</span> (T-&gt;bf) &#123; <span class="comment">// 检查 *T 的平衡度</span></div><div class="line">          <span class="keyword">case</span> LH: <span class="comment">// 原本左子树比右子树高,需作左平衡处理</span></div><div class="line">            LeftBalance(T); taller = FALSE; <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> EH: <span class="comment">// 原本左、右子树等高</span></div><div class="line"><span class="comment">// 现因左子树增高而使树增高</span></div><div class="line">            T-&gt;bf = LH; taller = TRUE; <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> RH: <span class="comment">// 原本右子树比左子树高 S</span></div><div class="line"><span class="comment">// 现左、右子树等高</span></div><div class="line">            T-&gt;bf = EH; taller = FALSE; <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="comment">// switch (T-&gt;bf)</span></div><div class="line">    &#125; <span class="comment">// if</span></div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 应继续在 T↑ 的右子树中进行搜索</span></div><div class="line">      <span class="keyword">if</span> (InsertAVL(T-&gt;rchild, e, taller)==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      <span class="keyword">if</span> (taller) <span class="comment">// 已插入到 *T 的右子树且右子树长高</span></div><div class="line">        <span class="keyword">switch</span> (T-&gt;bf) &#123; <span class="comment">// 检查 *T 的平衡度</span></div><div class="line">          <span class="keyword">case</span> LH: <span class="comment">// 原本左子树比右子树高</span></div><div class="line"><span class="comment">// 现左、右子树等高</span></div><div class="line">            T-&gt;bf = EH; taller = FALSE; <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> EH: <span class="comment">// 原本左、右子树等高</span></div><div class="line"><span class="comment">// 现因右子树增高而使树增高</span></div><div class="line">            T-&gt;bf = RH; taller = TRUE; <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> RH: <span class="comment">// 原本右子树比左子树高</span></div><div class="line"><span class="comment">// 需要作右平衡处理</span></div><div class="line">            RightBalance(T); taller = FALSE; <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="comment">//switch (T-&gt;bf)</span></div><div class="line">    &#125; <span class="comment">//else</span></div><div class="line">  &#125; <span class="comment">// else</span></div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>; </div><div class="line">&#125; <span class="comment">//InsertAVL</span></div><div class="line"></div><div class="line"><span class="comment">//对以指针 T 所指结点为根的二叉树作左平衡旋转处理</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(BSTree &amp;T)</span> </span>&#123;</div><div class="line"><span class="comment">// 本算法结束时,指针 T 指向新的根结点</span></div><div class="line">  BSTree lc,rd;</div><div class="line">  lc = T-&gt;lchild; <span class="comment">// lc 指向 *T 的左子树根结点</span></div><div class="line">  <span class="keyword">switch</span> (lc-&gt;bf) &#123; <span class="comment">// 检查 *T 的左子树的平衡度</span></div><div class="line"><span class="comment">// 并作相应平衡处理</span></div><div class="line">    <span class="keyword">case</span> LH:</div><div class="line"><span class="comment">// 新结点插入在 *T 的左孩子的左子树上,</span></div><div class="line"><span class="comment">// 要作单右旋处理</span></div><div class="line">      T-&gt;bf = lc-&gt;bf = EH;</div><div class="line">      R_Rotate(T); </div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> RH: <span class="comment">// 新结点插入在 *T 的左孩子的右子树上</span></div><div class="line"><span class="comment">// 要作双旋处理</span></div><div class="line">      rd = lc-&gt;rchild; <span class="comment">// rd 指向 *T 的左孩子的右子树根</span></div><div class="line">      <span class="keyword">switch</span> (rd-&gt;bf) &#123; <span class="comment">// 修改 *T 及其左孩子的平衡因子</span></div><div class="line">        <span class="keyword">case</span> LH: T-&gt;bf = RH; lc-&gt;bf = EH; <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> EH: T-&gt;bf = lc-&gt;bf = EH; <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> RH: T-&gt;bf = EH; lc-&gt;bf = LH; <span class="keyword">break</span>;</div><div class="line">      &#125; <span class="comment">//switch (rd-&gt;bf)</span></div><div class="line">      rd-&gt;bf = EH;</div><div class="line"><span class="comment">// 对 *T 的左子树作左旋平衡处理</span></div><div class="line">      L_Rotate(T-&gt;lchild);</div><div class="line">      R_Rotate(T); <span class="comment">// 对 *T 作右旋平衡处理</span></div><div class="line">  &#125; <span class="comment">// switch (lc-&gt;bf)</span></div><div class="line">&#125; <span class="comment">// LeftBalance</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RightBalance</span><span class="params">(BSTree *T)</span></span>&#123;</div><div class="line">    BSTree lc,ld;</div><div class="line">    lc=(*T)-&gt;rchild;</div><div class="line">    <span class="keyword">switch</span>(lc-&gt;bf)&#123;</div><div class="line">    <span class="keyword">case</span> RH:</div><div class="line">        (*T)-&gt;bf=lc-&gt;bf=EH;</div><div class="line">        L_Rotate(T);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> LH:</div><div class="line">        ld=lc-&gt;lchild;</div><div class="line">        <span class="keyword">switch</span>(ld-&gt;bf)&#123;</div><div class="line">        <span class="keyword">case</span> LH:</div><div class="line">            (*T)-&gt;bf=EH;</div><div class="line">            lc-&gt;bf=RH;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> EH:</div><div class="line">            (*T)-&gt;bf=lc-&gt;bf=EH;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> RH:</div><div class="line">            lc-&gt;bf=EH;</div><div class="line">            (*T)-&gt;bf=LH;</div><div class="line">        &#125;</div><div class="line">        ld-&gt;bf=EH;</div><div class="line">        R_Rotate(&amp;((*T)-&gt;rchild));</div><div class="line">        L_Rotate(T);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> EH:</div><div class="line">        (*T)-&gt;bf=RH;</div><div class="line">        lc-&gt;bf=LH;</div><div class="line">        L_Rotate(T);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;<span class="comment">//RightBalance</span></div></pre></td></tr></table></figure>
<p><strong>AVL树的删除</strong></p>
<ul>
<li>如果被删结点 x 最多只有一个子女,可做简单删除</li>
</ul>
<p>– 将结点 x 从树中删去<br>– 因为结点 x 最多有一个子女,可以简单地把 x 的双亲中原来指向 x 的指针改指到这个子女结点<br>– 如果结点 x 没有子女, x 双亲原来指向 x的指针置为 NULL<br>– 将原来以结点 x 为根的子树的高度减 1</p>
<ul>
<li>如果被删结点 x 有两个子女</li>
</ul>
<p>– 搜索 x 在中序次序下的直接前驱 y ( 同样可以找直接后继 )<br>– 把结点 y 的内容传送给结点 x ,现在问题转移到删除结点 y 。把结点 y 当作被删结点 x<br>– 因为结点 y 最多有一个子女,可以简单地用 前一页给出的方法进行删除</p>
<ul>
<li>必须沿结点 x 通向根的路径反向追踪高度的变化对路径上各个结点的影响</li>
<li>用一个布尔变量 shorter 来指明子树高度是否被缩短</li>
</ul>
<p>– 布尔变量 shorter 的值初始化为 True</p>
<ul>
<li>对于从 x 的双亲到根的路径上的各个结点p ,在 shorter 保持为 True 时执行下面操作;如果 shorter 变成 False ,算法终止</li>
</ul>
<p>– 在每个结点上要做的操作取决于 shorter 的值<br>和结点的 bf ,有时还要依赖子女的 bf</p>
<p>算法实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteAVL</span><span class="params">(BSTree *t, ElemType key, <span class="keyword">bool</span>&amp; shorter)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>((*t)== <span class="literal">NULL</span>)&#123;                      </div><div class="line">        shorter=<span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                   </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(EQ(key, (*t)-&gt;data))&#123;        </div><div class="line">        BSTNode* q = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">if</span>((*t)-&gt;lchild == <span class="literal">NULL</span>)&#123;           </div><div class="line">            q = *t;</div><div class="line">            (*t) = (*t)-&gt;rchild;</div><div class="line">            <span class="keyword">delete</span> q;</div><div class="line">            shorter = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((*t)-&gt;rchild == <span class="literal">NULL</span>)&#123;      </div><div class="line">            q = (*t);</div><div class="line">            (*t) = (*t)-&gt;lchild;</div><div class="line">            <span class="keyword">delete</span> q;</div><div class="line">            shorter = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;                            </div><div class="line">            q = (*t)-&gt;lchild;</div><div class="line">            <span class="keyword">while</span>(q-&gt;rchild)</div><div class="line">                q = q-&gt;rchild;</div><div class="line">            (*t)-&gt;data = q-&gt;data;</div><div class="line">            deleteAVL(&amp;((*t)-&gt;lchild), q-&gt;data, shorter);   </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LT(key, (*t)-&gt;data))&#123;        </div><div class="line">        <span class="keyword">if</span>(!deleteAVL(&amp;((*t)-&gt;lchild), key, shorter))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(shorter)&#123;</div><div class="line">            <span class="keyword">switch</span>((*t)-&gt;bf)&#123;</div><div class="line">                <span class="keyword">case</span> LH:</div><div class="line">                    (*t)-&gt;bf = EH;</div><div class="line">                    shorter = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> EH:</div><div class="line">                    (*t)-&gt;bf = RH;</div><div class="line">                    shorter = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> RH:</div><div class="line">                    RightBalance(t);    </div><div class="line">                    <span class="keyword">if</span>((*t)-&gt;rchild-&gt;bf == EH)</div><div class="line">                        shorter = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        shorter = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;                                </div><div class="line">        <span class="keyword">if</span>(!deleteAVL(&amp;((*t)-&gt;rchild), key, shorter))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(shorter)&#123;</div><div class="line">            <span class="keyword">switch</span>((*t)-&gt;bf)&#123;</div><div class="line">                <span class="keyword">case</span> LH:</div><div class="line">                    LeftBalance(t);    </div><div class="line">                    <span class="keyword">if</span>((*t)-&gt;lchild-&gt;bf == EH)</div><div class="line">                        shorter = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        shorter = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> EH:</div><div class="line">                    (*t)-&gt;bf = LH;</div><div class="line">                    shorter = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> RH:</div><div class="line">                    (*t)-&gt;bf = EH;</div><div class="line">                    shorter = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>AVL 上的查找</strong></p>
<p>AVL上进行查找的时间复杂度为O(logn) .</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>一棵m阶B树，或者是空树，或者是满足下面性质的一棵树：</p>
<ul>
<li>每个节点至多有m棵子树</li>
<li>节点要么是根节点，或者是叶子节点，或者至少有两棵子树</li>
<li>除根节点外，所有非终节点至少有m/2(上取整)棵子树</li>
<li>所有非终端节点应包含如下信息：<ul>
<li>$(n, A_0, K_1, A_1, K_2, A_2, …, K_n, A_n)$</li>
<li>其中，$K_i$是关键字，且$K<em>i &lt; K</em>{i+1}, A<em>i$为指向孩子节点的指针，且$A</em>{i-1}$所指向的子树中的所有节点的关键字均小于$K_i,A_i$所指向子树中的所有节点的关键字均大于$K_i$，$n$是节点中关键字的个数，$n+1$为子树的棵树。</li>
</ul>
</li>
<li>所有叶子节点都在树的同一层上，且不带信息。<ul>
<li>叶子节点为外部节点，查找失败时候的节点，实际上不存在。</li>
</ul>
</li>
</ul>
<p><strong>m阶B树定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> m 3</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BTNode &#123;</div><div class="line">  <span class="keyword">int</span> keynum; <span class="comment">// 结点中关键字个数,即结点大小</span></div><div class="line">  <span class="keyword">struct</span> BTNode *parent; <span class="comment">// 指向父结点的指针</span></div><div class="line">  KeyType key[m+<span class="number">1</span>]; <span class="comment">// 关键字, 0 号单元不用</span></div><div class="line">  Record *recptr[m+<span class="number">1</span>]; <span class="comment">// 记录指针向量,0 号单元不用</span></div><div class="line">  <span class="keyword">struct</span> BTNode *ptr[m+<span class="number">1</span>]; <span class="comment">// 子树指针向量</span></div><div class="line">&#125; BTNode, *BTree; <span class="comment">//B 树结点和 B 树的类型</span></div></pre></td></tr></table></figure>
<p><strong>B 树的查找:类似二叉排序树</strong></p>
<ul>
<li>(1) 从树的根结点 T 开始,在 T 所指向的结点的关键字向量 key[1…keynum] 中查找给定值 K( 用 s 顺序查找或折半查找 ) :</li>
<li>若 key[i]=K(1≤i≤keynum) ,则查找成功,返回结点及关键字位置;否则,转 (2) ;</li>
<li>(2) 将 K 与向量 key[1…keynum] 中的各个分量的值进行比较,以选定查找的子树:</li>
</ul>
<p>​    – 若 K &lt; key[1] : T=T-&gt;ptr[0]<br>​    – 若 key[i] &lt; K&lt; key [i+1] (i=1, 2, …keynum-1) : T=T-&gt;ptr[i]<br>​    – 若 K&gt;key[keynum] : T=T-&gt;ptr[keynum]</p>
<ul>
<li>转 (1) ,直到 T 是叶子结点且未找到相等的关键字,则查找失败• 在 B+ 树上插入、删除的过程基本上和 B 树类似</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  BTNode *pt; <span class="comment">// 指向找到的结点</span></div><div class="line">  <span class="keyword">int</span> i; <span class="comment">// 在结点中的关键字序号</span></div><div class="line">  <span class="keyword">int</span> tag;</div><div class="line"><span class="comment">//1 :查找成功, 0 :查找失败</span></div><div class="line">&#125; Result;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(BTree p, KeyType K)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; p-&gt;keynum &amp;&amp; p-&gt;key[i+<span class="number">1</span>] &lt;= K; i++);</div><div class="line">  <span class="keyword">return</span> i; <span class="comment">// p-&gt;key[i] &lt;= K &lt; p-&gt;key[i+1]</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//在 m 阶 B 树 T 上查找关键字 K ,返回结果 (pt,i,tag)</span></div><div class="line"><span class="function">Result <span class="title">SearchBTree</span><span class="params">(BTree T, KeyType K)</span> </span>&#123;</div><div class="line">  BTree p, q; <span class="keyword">int</span> found, i, j=<span class="number">0</span>; Result R;</div><div class="line"><span class="comment">// 初始化, p 指向待查结点, q 指向 p 的双亲</span></div><div class="line">  p = T; q = <span class="literal">NULL</span>; found = FALSE; i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (p &amp;&amp; !found) &#123;</div><div class="line">    i = Search(p, K); <span class="comment">// 在 p-&gt;key[1..keynum] 中查找 i ,</span></div><div class="line"><span class="comment">// 使得 p-&gt;key[i]&lt;=K&lt;p-&gt;key[i+1]</span></div><div class="line">    <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; p-&gt;key[i]==K)</div><div class="line">      found = TRUE; <span class="comment">// 找到待查关键字</span></div><div class="line">    <span class="keyword">else</span> &#123; q = p; p = p-&gt;ptr[i]; &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (found) &#123; <span class="comment">// 查找成功: pt 所指结点中第 i 个关键字等于 K</span></div><div class="line">    R.pt = p; R.i = i; R.tag = <span class="number">1</span>; &#125;</div><div class="line">  <span class="keyword">else</span> &#123; <span class="comment">// 关键字 k 应插入在 pt 所指结点中的第 i 和第 i+1 个关键字之间</span></div><div class="line">    R.pt = q; R.i = i; R.tag = <span class="number">0</span>; &#125;</div><div class="line">  <span class="keyword">return</span> R; <span class="comment">// 返回结果信息 : K 的位置 ( 或插入位置 )</span></div><div class="line">&#125; <span class="comment">// SearchBTree</span></div></pre></td></tr></table></figure>
<ul>
<li>在 B 树上的查找有两种基本操作:</li>
</ul>
<p>​     – 在 B 树上查找结点:在磁盘上进行<br>​     – 在结点中查找关键字:将结点信息读入内存后再查找</p>
<ul>
<li>因此,磁盘上的查找次数 ( 即:待查找的记录关键字在 B 树上的层次数 ) 是决定 B 树查找效率的首要因素.</li>
</ul>
<p><strong>B树的插入</strong></p>
<ul>
<li>B 树的生成是从空树起,逐个插入关键字</li>
<li>插入时不是每插入一个关键字就添加一个叶子结点,而是首先在最低层的某个叶子结点中添加一个关键字,然后</li>
<li>若关键字的数目达到 m ,则分裂成两个结点,并将中间关键字插入到 p 的父结点,这时,父结点也可能不满足 m 阶 B 树的要求( 分枝数大于 m) ,则必须对父结点进行分裂,一直进行下去,直到没有父结点或分裂后的父结点满足 m 阶 B 树的要求</li>
<li>当根结点分裂时,因没有父结点,则建立一个新的根, B 树增高一层</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function">BTNode *<span class="title">split</span><span class="params">(BTNode *p)</span></span></div><div class="line"><span class="comment">// 结点 p 中包含 m 个关键字,从中分裂出一个新的结点</span></div><div class="line">&#123;</div><div class="line">  BTNode *q ; <span class="keyword">int</span> k, mid, j ;</div><div class="line">  q=(BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>( BTNode));</div><div class="line">  mid=(m+<span class="number">1</span>)/<span class="number">2</span>; </div><div class="line">  q-&gt;ptr[<span class="number">0</span>]=p-&gt;ptr[mid];</div><div class="line">  <span class="keyword">for</span> (j=<span class="number">1</span>,k=mid+<span class="number">1</span>; k&lt;=m; k++) &#123;</div><div class="line">    q-&gt;key[j]=p-&gt;key[k] ;</div><div class="line">    q-&gt;ptr[j++]=p-&gt;ptr[k] ;</div><div class="line">  &#125; <span class="comment">// 将 p 的后半部分移到新结点 q 中</span></div><div class="line">  q-&gt;keynum=m-mid ; p-&gt;keynum=mid<span class="number">-1</span> ;</div><div class="line">  <span class="keyword">return</span>(q) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>B树的删除</strong></p>
<ul>
<li>在 B 树上删除一个关键字 K ,首先找到关键字所在的结点 N ,然后在 N 中进行关键字 K 的删除操作。</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><ul>
<li>m 阶 B+ 树, B 树的一种变体</li>
<li>一棵 m 阶 B+ 树与 m 阶 B 树的主要差异是: 若一个结点有 n 棵子树,则必含有 n 个关键字</li>
<li>所有叶子结点中包含了全部记录的关键字信息以及这些关键字记录的指针,而且叶子结点按关键字的大小从小到大顺序链接,构成一个有序链表</li>
<li>在 B+ 树中,所有的非叶子结点可以看成是索引,结点中只含有其子树的根结点中的最大 ( 或最小 ) 关键字</li>
</ul>
<p><strong>B+树定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;branch, left&#125; NodeType;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BPNode &#123;</div><div class="line">  NodeTag tag; <span class="comment">// 结点标志</span></div><div class="line">  <span class="keyword">int</span> keynum; <span class="comment">// 结点中关键字的个数</span></div><div class="line">  <span class="keyword">struct</span> BTNode *parent; <span class="comment">// 指向父结点的指针</span></div><div class="line">  KeyType key[M+<span class="number">1</span>]; <span class="comment">// 关键字向量 ,key[0] 未用</span></div><div class="line">  <span class="keyword">union</span> pointer</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">struct</span> BTNode *ptr[M+<span class="number">1</span>]; <span class="comment">// 子树指针向量</span></div><div class="line">    RecType *recptr[M+<span class="number">1</span>]; <span class="comment">//recptr[0] 未用</span></div><div class="line">  &#125;ptrType ; <span class="comment">// 用联合体定义子树指针和记录指针</span></div><div class="line">&#125;BPNode;</div></pre></td></tr></table></figure>
<p><strong>B+树的查找</strong></p>
<ul>
<li>与 B 树相比,对 B+ 树不仅可以从根结点开始按关键字随机查找,而且可以从最小关键字起,按叶子结点的链接顺序进行顺序查找。</li>
<li>在 B+ 树上进行随机查找的过程基本上和 B树类似。</li>
<li>在 B+ 树上进行随机查找时,若非叶子结点的关键字等于给定的 K 值,并不终止,而是继续向下直到叶子结点 ( 只有叶子结点才存储记录 ) , 即无论查找成功与否,都走了一条从根结点到叶子结点的路径。</li>
</ul>
<p><strong>B+ 树的插入、删除</strong></p>
<ul>
<li>在 B+ 树上插入、删除的过程基本上和 B 树类似。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;AVL-树&quot;&gt;&lt;a href=&quot;#AVL-树&quot; class=&quot;headerlink&quot; title=&quot;AVL 树&quot;&gt;&lt;/a&gt;AVL 树&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Motivation: 二叉排序树是一种查找效率比较高的数据组织形式,但其平均查找长度受树的形态影响较大,形态比较均匀时查找效率很好,形态明显偏向某一方向时其效率就大大降低。因此,希望有更好的二叉排序树,其形态总是均衡的,查找时能得到最好的效率&lt;/li&gt;
&lt;li&gt;Solution: 平衡二叉排序树 (Balanced Binary Sort Tree) ,由 Adelson-Velskii 和 Landis于 1962 年提出的,故称 AVL 树&lt;/li&gt;
&lt;li&gt;变种:红黑树,树堆,伸展树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基本概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;平衡二叉树 (Balanced Binary Tree 或 Height-Balanced Tree) 或者是空树,或者是满足下列性质的二叉树&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左子树和右子树深度之差的绝对值不大于 1&lt;/li&gt;
&lt;li&gt;左子树和右子树也都是平衡二叉树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结点的平衡因子 (Balance Factor) :该结点的右子树的深度减去其左子树深度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平衡二叉树上每个结点的平衡因子只可能是 1 、 0和 -1&lt;/li&gt;
&lt;li&gt;平衡二叉排序树 (Balanced Binary Sort Tree) :一棵二叉树既是二叉排序树又是平衡二叉树&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Data-Structures" scheme="http://ucasfl.me/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>查找和搜索-Part1</title>
    <link href="http://ucasfl.me/2017/08/05/Find-and-Search-Part1/"/>
    <id>http://ucasfl.me/2017/08/05/Find-and-Search-Part1/</id>
    <published>2017-08-05T04:51:20.000Z</published>
    <updated>2017-09-02T04:38:29.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>查找表 (Search Table) :相同类型的数据元素 ( 或记录 ) 组成的集合,每个数据元素通常由若干数据项构成</li>
<li>关键字 (Key ,码 ) :数据元素中某个 ( 或几个 ) 数据项的值,它可以标识一个数据元素</li>
</ul>
<p>– 主关键字 (Primary Key) :能唯一标识一个数据元素的关键字<br>– 次关键字 (Secondary Key) :能标识若干个数据元素的关键字</p>
<h4 id="关键字类型"><a href="#关键字类型" class="headerlink" title="关键字类型"></a>关键字类型</h4><ul>
<li>数据元素的关键字:其类型通常是可以进行比较运算的类型</li>
<li>典型的关键字类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> KeyType ;</div><div class="line"><span class="comment">// 实型</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType ; <span class="comment">// 整型</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> KeyType ; <span class="comment">// 字符串型</span></div><div class="line">• 数据元素类型</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> RecType &#123;</div><div class="line">KeyType key ; <span class="comment">// 关键字域</span></div><div class="line">... ... <span class="comment">// 其他域</span></div><div class="line">&#125; ElemType;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="对两个关键字的比较"><a href="#对两个关键字的比较" class="headerlink" title="对两个关键字的比较"></a>对两个关键字的比较</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//C 的宏定义</div><div class="line">// 对数值型关键字</div><div class="line">#define EQ(a, b) ((a)==(b))</div><div class="line">#define LT(a, b) ((a)&lt;(b))</div><div class="line">#define LQ(a, b) ((a)&lt;=(b))</div><div class="line">// 对字符串型关键字</div><div class="line">#define EQ(a, b) (!strcmp((a), (b)) )</div><div class="line">#define LT(a, b) (strcmp((a), (b))&lt;0 )</div><div class="line">#define LQ(a, b) (strcmp((a), (b))&lt;=0 )</div></pre></td></tr></table></figure>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>根据给定的 Key 值,在查找表中确定一个关键字等于给定值的数据元素或记录</p>
<ul>
<li>查找表中存在满足条件的数据元素 / 记录,则查找成功,返回所查到的数据元素或其在查找表中的位置</li>
<li>查找表中不存在满足条件的记录,则查找失败</li>
<li>“ 关键字等于给定值 ” 只是一种最为常用的查找条件,实际应用中可能会有其他的查找件,例如查找 “ 关键字在某个范围内的数据元素 ” 等等</li>
</ul>
<p>采用何种查找方法,首先取决于查找表的组织,即按何种关系组织 / 存储数据元素</p>
<ul>
<li>查找表是记录的集合,而集合中的元素之间是一种完全松散的关系,因此,查找表是一种非常灵活的数据结构,可以用多种方式来存储</li>
</ul>
<h3 id="查找及其方法分类"><a href="#查找及其方法分类" class="headerlink" title="查找及其方法分类"></a>查找及其方法分类</h3><ul>
<li>静态查找 / 静态查找表 (Static Search Table):只对该表的数据元素进行查询</li>
<li>动态查找 / 动态查找表 (Dynamic Search Table) :在对该表实施查找的同时,可插入查找表中不存在的记录,或从查找表中删除已存在的某个记录;表的结构本身是在查找过程中动态生成的</li>
</ul>
<h4 id="分类1：按存储结构的不同"><a href="#分类1：按存储结构的不同" class="headerlink" title="分类1：按存储结构的不同"></a>分类1：按存储结构的不同</h4><ul>
<li>线性表查找: 数据元素保存在顺序表或链表中</li>
<li>哈希查找:数据元素保存在哈希表中,根据给定的 Key 值直接访问 查找表, 从而找到要查找的记录</li>
<li>树表查找:数据元素保存在树中</li>
</ul>
<h4 id="分类2："><a href="#分类2：" class="headerlink" title="分类2："></a>分类2：</h4><ul>
<li>内查找:整个查找过程全部在内存进行</li>
<li>外查找:在查找过程中还需要访问外存，例如:查找表太大,无法全部放入内存中</li>
</ul>
<h4 id="查找方法的评价指标"><a href="#查找方法的评价指标" class="headerlink" title="查找方法的评价指标"></a>查找方法的评价指标</h4><ul>
<li>查找过程中的主要操作是关键字的比较,查找过程中关键字的平均比较次数是衡量一个查找算法效率高低的标准</li>
<li>ASL (Average Search Length , 平均查找长度 ) 定义为需要和给定值进行比较的关键字的个数的期望值</li>
</ul>
<h3 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h3><p>静态查找表:可以用线性表 ( 顺序表或线性链表 ) 实现</p>
<p>静态查找表 StaticSearchTable 的基本操作:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void CreateSSTable(SSTable *t);// 构造一个查找表</div><div class="line">void Destroy(SSTable *t);</div><div class="line">void ListSSTable(SSTable *t); // 输出查找表</div><div class="line">int SearchSSTable(SSTable *t,KeyType key); // 查找成功,返回元素值在表中位置</div><div class="line">void Traverser(SSTable *t, void Visit(ElemType *e)); // 按某种次序对 t 的每个元素调用函数 Visit()</div><div class="line">一次且一次</div></pre></td></tr></table></figure>
<h4 id="静态查找表的查找方法"><a href="#静态查找表的查找方法" class="headerlink" title="静态查找表的查找方法"></a>静态查找表的查找方法</h4><ul>
<li>基于顺序表的查找: 顺序查找 (SequentialSearch) ,逐一比较</li>
<li>基于有序表的查找</li>
</ul>
<p>– 折半查找 / 二分查找 (Binary Search) :每次对查找表进行折半缩小<br>– Fibonacci 查找 :根据 Fibonacci 数列的特点对查找表进行分割<br>– 静态树表查找</p>
<ul>
<li>基于索引顺序表的查找:索引顺序查找 /分块查找 (Blocking Search) ,基于顺序表和其索引的查找</li>
</ul>
<h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>顺序表的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SSTable&#123;</div><div class="line"><span class="comment">// 数据元素存储空间的基地址</span></div><div class="line"><span class="comment">// 建表时按实际长度分配, 0 号单元留空</span></div><div class="line">ElemType *elem;</div><div class="line"><span class="keyword">int</span> length ; <span class="comment">// 实际元素个数</span></div><div class="line">&#125; SSTable;</div></pre></td></tr></table></figure>
<p>顺序查找算法：</p>
<p>从表的一端 ( 例如:最后一个记录 ) 开始,逐个将记录的关键字和给定 Key 值进行比较<br>– 若某个记录的关键字和给定 Key 值相等,查找成功<br>– 否则,若扫描完整个表,仍然没有找到相应的记录,则查找失败</p>
<p>简单实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchSSTable</span><span class="params">(SSTable *t, KeyType key)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=t-&gt;length &amp;&amp; (t-&gt;elem[i].key != key); i++ );</div><div class="line">  <span class="keyword">if</span>( i&lt;=t-&gt;length )</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125; <span class="comment">//Search_Seq</span></div></pre></td></tr></table></figure>
<p>标准算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchSSTable</span><span class="params">(SSTable *t,KeyType key)</span> </span>&#123;</div><div class="line"><span class="comment">// 设置哨兵,查找失败时返回 0</span></div><div class="line">  t-&gt;elem[<span class="number">0</span>].key=key;</div><div class="line"><span class="comment">// 从后往前找</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=t-&gt;length; !EQ(t-&gt;elem[i].key, key); i--) ;</div><div class="line">  <span class="keyword">return</span> i ; <span class="comment">// 找不到时, i 为 0</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//设立哨兵后可以使循环中省掉了一次比较</span></div></pre></td></tr></table></figure>
<p>算法分析：</p>
<ul>
<li>查找成功时候的比较次数：ASL = (n+1)/2</li>
<li>查找失败时候的比较次数：ASL=n+1</li>
<li>若查找成功与不成功的概率相等，则 ASL = 3(n+1)/4</li>
</ul>
<p>缺点：</p>
<p>查找效率低,当 n 较大时,不宜采用顺序查找。</p>
<p>改进：</p>
<ul>
<li>根据数据元素被查找的概率组织顺序表，在不等概率的情况下，按被查找概率的升序排序。</li>
<li>在数据元素中增加一数据项,用于记录对该数据元素的访问次数<br>– 在每次查找后,维护查找表使得其按照数据元素的访问次数升序排序</li>
<li>在每次查找后,将刚查找到的元素移动至表尾:已发生的事会重复发生</li>
<li>为顺序表加索引</li>
</ul>
<h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><ul>
<li>基于有序顺序表的查找chazhao</li>
</ul>
<p>– 查找表中的所有记录是按关键字有序 ( 升序或降序 ) 排列的</p>
<ul>
<li>查找过程中,先确定待查找记录在表中的范围,然后逐步缩小范围 ( 每次将待查记录所在区间缩小一半 ) ,直到找到或找不到记录为止</li>
</ul>
<p>算法思想：</p>
<ul>
<li>初始:用 Low 、 High 和 Mid 表示待查找区间的下界、上界和中间位置指针,初值设置为 Low=1 , High=n</li>
<li>(1) 取中间位置 Mid : Mid=(Low+High)/2</li>
<li>(2) 比较中间位置记录的关键字与给定的 Key值:</li>
</ul>
<p>– 相等:查找成功;<br>– 大于:待查记录在区间的前半段,修改上界指针: High=Mid-1 ,转 (1) ;<br>– 小于:待查记录在区间的后半段,修改下界指针: Low=Mid+1 ,转 (1) ;</p>
<ul>
<li>直到越界 (Low&gt;High) ,查找失败</li>
</ul>
<p><strong>算法实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在有序表 t 中折半查找其关键字等于 key 的数据元素</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchSSTable</span><span class="params">(SSTable *t, KeyType key)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> low, high, mid;</div><div class="line">  low = <span class="number">1</span>; high = t-&gt;length; <span class="comment">// 置区间初值</span></div><div class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</div><div class="line">    mid = (low + high) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (EQ(key , t-&gt;elem[mid].key))</div><div class="line"><span class="comment">// 找到,返回该待查元素在表中的位置</span></div><div class="line">      <span class="keyword">return</span> mid;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (LT(key, t-&gt;elem[mid].key))</div><div class="line"><span class="comment">// 继续在前半区间进行查找</span></div><div class="line">      high = mid - <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="comment">// 继续在后半区间进行查找</span></div><div class="line">      low = mid + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 顺序表中不存在待查元素</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>算法分析</strong>：</p>
<ul>
<li>查找时,每经过一次比较,查找范围就缩小一半,该过程可用一棵二叉树表示:</li>
</ul>
<p>– 把当前查找区间的中点作为根结点<br>– 左子区间和右子区间分别作为根的左子树和右子树<br>– 排在中间位置前面的作为左子树的结点<br>– 排在中间位置后面的作为右子树的结点</p>
<ul>
<li>上述描述查找过程的二叉树被称为折半查找的判定树(Decision Tree)</li>
</ul>
<p>– 内结点代表顺序表中已有的元素,外结点代表失败结点,它表示在两个相邻已有元素值之间的值</p>
<ul>
<li>找到有序表中任一记录的过程是走了一条从根结点到与该记录相应的结点的路径,与给定值进行比较的关键字个数为该结点在判定树上的层次数</li>
<li>查找成功时候的ASL = (n+1)/nlog2(n+1) - 1</li>
<li>当n很大时(n&gt;50)，ASL = log2(n+1) - 1</li>
</ul>
<p><strong>算法优缺点分析</strong>：</p>
<ul>
<li>Strength :折半查找速度很快</li>
</ul>
<p>– 1000 个元素的有序表,至多需要比较 10 次<br>– 1000,000 个元素的有序表,需要不超过 20 次的比较</p>
<ul>
<li>Limitation :查找对象是有序表,即在查找之前需要对顺序表进行排序操作</li>
</ul>
<ul>
<li>Weaknesses :</li>
</ul>
<p>– 折半查找无法应用于链表<br>– 在不等概率查找的情况下,折半查找不一定是有序表最好的查找方法<br>– 当查找表的长度不大时,也许折半查找的效率不如顺序查找</p>
<ul>
<li>Conclusion :适合于大量的静态数据</li>
</ul>
<p>– 有序表的插入和删除都比较麻烦,平均要移动表中一半的元素</p>
<h4 id="Fibonacci-查找"><a href="#Fibonacci-查找" class="headerlink" title="Fibonacci 查找"></a>Fibonacci 查找</h4><ul>
<li>基于有序顺序表的查找</li>
</ul>
<p>– 查找表中的所有记录是按关键字有序 ( 升序或降序 )排列的</p>
<ul>
<li>查找过程中,先确定待查找记录在表中的范围,然后逐步缩小范围 ( 每次根据 Fibonacci 数列的特点对查找表进行分割 ) ,直到找到或找不到记录为止</li>
</ul>
<p><strong>算法思想</strong></p>
<ul>
<li>设查找表中的记录数 n 比某个 Fibonacci 数小 1,即设 n=F(j)-1</li>
<li>用 Low 、 High 和 Mid 表示待查找区间的下界、上界和分割位置,初值为 Low=1 , High=n</li>
<li>(1) 取分割位置 Mid : Mid=F(j-1)</li>
<li>(2) 比较 key 值与分割位置记录的关键字:</li>
</ul>
<p>– 相等: 查找成功<br>– 小于:待查记录在区间的前半段,修改上界指针:High=Mid-1 ,这时,区间长度为 F(j-1)-1 ,转(1) ;<br>– 大于:待查记录在区间的后半段,修改下界指针:Low=Mid+1 , 这时,区间长度为 F(j-2)-1 ,转(1) ;</p>
<ul>
<li>直到越界 (Low&gt;High) ,查找失败</li>
</ul>
<p><strong>算法实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Fibonacci 数的计算</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, f, f0=<span class="number">0</span>, f1=<span class="number">1</span>;</div><div class="line">  <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ;</div><div class="line">  <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> ;</div><div class="line">  <span class="keyword">for</span> (i=<span class="number">2</span> ; i&lt;=n ; i++ ) &#123;</div><div class="line">    f=f0+f1 ; f0=f1 ; f1=f ; </div><div class="line">  &#125;chazhao</div><div class="line">  <span class="keyword">return</span> f ;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 在有序表 t 中用 Fibonacci 方法查找关键字为 key 的记录</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchSSTableFibonacci</span><span class="params">(SSTable *t, KeyType key , <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> Low=<span class="number">1</span>, High, Mid, f1, f2 ;</div><div class="line">  High=fib(n); </div><div class="line">  f1=fib(n<span class="number">-1</span>); </div><div class="line">  f2=fib(n<span class="number">-2</span>);<span class="function">chazhao</span></div><div class="line">  <span class="title">while</span> <span class="params">(Low&lt;=High)</span> &#123;</div><div class="line">    Mid=Low+f1<span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span> ( EQ(key, t-&gt;elem[Mid].key) ) </div><div class="line">      <span class="keyword">return</span> Mid ;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( LT(key, t-&gt;elem[Mid].key) )&#123; </div><div class="line">      High=Mid<span class="number">-1</span>; f2=f1-f2; f1=f1-f2; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123; </div><div class="line">      Low=Mid+<span class="number">1</span>; f1=f1-f2; f2=f2-f1; </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<ul>
<li>Fibonacci 查找的平均性能比折半查找好，但最坏情况下比折半查找差。</li>
<li>插值查找：根据key值来决定与哪个记录比较并分区。</li>
<li>插值查找适用于关键字均匀分布。</li>
</ul>
<h4 id="索引顺序查找-分块查找"><a href="#索引顺序查找-分块查找" class="headerlink" title="索引顺序查找 / 分块查找"></a>索引顺序查找 / 分块查找</h4><ul>
<li>查找表的组织:将查找表分成几块</li>
</ul>
<p>– 块间有序,即第 i+1 块的所有记录关键字均大于 ( 或小于 ) 第 i 块记录关键字<br>– 块内无序<br>– 在查找表的基础上附加一个索引表,索引表是按关键字有序的,索引表中记录的构成是:<br>– 可以建立多级索引<br>– 可以建立多种索引</p>
<ul>
<li>先 ( 用顺序查找或折半查找 ) 确定待查记录所在块,再在块内查找 ( 顺序查找 )</li>
</ul>
<p><strong>算法实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//数据结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> IndexType &#123;</div><div class="line">  KeyType maxkey; <span class="comment">// 块中最大的关键字</span></div><div class="line">  <span class="keyword">int</span> startpos;</div><div class="line"><span class="comment">// 块的起始位置指针</span></div><div class="line"><span class="comment">//int length;</span></div><div class="line"><span class="comment">// 块的长度</span></div><div class="line">&#125; Index;</div><div class="line"><span class="comment">//算法实现</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchSSTableBlock</span> <span class="params">(SSTable *t, Index ind[], KeyType key , <span class="keyword">int</span> n , <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 表长为 n ,块数为 b</span></div><div class="line">  <span class="keyword">int</span> i=<span class="number">0</span>, j , k ;</div><div class="line"><span class="comment">// 在块间顺序查找</span></div><div class="line">  <span class="keyword">while</span> ((i&lt;b)&amp;&amp; LT(ind[i].maxkey, key) ) i++ ;</div><div class="line">  <span class="keyword">if</span> (i&gt;b)</div><div class="line">    <span class="keyword">return</span>(<span class="number">0</span>); <span class="comment">// 没有找到</span></div><div class="line">  j=ind[i].startpos;</div><div class="line">  <span class="keyword">while</span> ((j&lt;n) &amp;&amp; LQ(t-&gt;elem[j].key, ind[i].maxkey) ) &#123;</div><div class="line"><span class="comment">// 在块内顺序查找</span></div><div class="line">    <span class="keyword">if</span> ( EQ(t-&gt;elem[j].key, key) ) <span class="keyword">break</span> ;</div><div class="line">    j++ ;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (j&gt;n||!EQ(t-&gt;elem[j].key, key) ) j=<span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span>(j)；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<ul>
<li>索引顺序查找的平均查找长度ASL等于 = 查找索引表确定所在块的平均查找长度Lb + 在块内查找元素的平均查找长度Lw.</li>
</ul>
<h4 id="查找方法比较"><a href="#查找方法比较" class="headerlink" title="查找方法比较"></a>查找方法比较</h4><table>
<thead>
<tr>
<th style="text-align:right"></th>
<th>顺序查找</th>
<th>分块查找</th>
<th>折半查找</th>
<th>Fibonacci查找</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">表结构</td>
<td>有序表/无序表</td>
<td>分块有序表</td>
<td>有序表</td>
<td>有序表</td>
</tr>
<tr>
<td style="text-align:right">存储结构</td>
<td>顺序存储结构/线性链表</td>
<td>顺序存储结构/线性链表</td>
<td>顺序存储结构</td>
<td>顺序存储结构</td>
</tr>
<tr>
<td style="text-align:right">ASL</td>
<td>最大</td>
<td>介于两者之间</td>
<td>最小</td>
<td>平均比折半查找好</td>
</tr>
</tbody>
</table>
<h3 id="静态树表-次优查找树的查找"><a href="#静态树表-次优查找树的查找" class="headerlink" title="静态树表/次优查找树的查找"></a>静态树表/次优查找树的查找</h3><ul>
<li>若有序表中的各个元素的查找概率不等,那么,用折半查找,性能未必最优</li>
<li>如何改进,以提高性能 ?</li>
</ul>
<p>– 需要找到查找性能最佳的判定树,即,静态最优查找树 (Static Optimal Tree)<br>– 该判定树的带权内路径长度之和最小<br>$$Min PH=Min\sum_{i=1}^{n}w_i\times h_i$$<br>– n 为有序表长度, hi 为第 i 个结点在二叉树上的层次数, wi =cpi (i=1,2,…,n) , pi 为结点的查找概率, c 为常量</p>
<p><strong>算法思路</strong></p>
<ul>
<li>构造静态最优查找树的时间开销太大</li>
<li>为有序表构造次优查找树 (Nearly Optimal Search Tree)</li>
<li>基于次优查找树的查找</li>
</ul>
<p>– 给定 Key ,<br>– 从根结点开始,将 Key 值与根结点比较,若 key大于根结点值,在右子树中查找,若 key 小于根结点值,在左子树中查找<br>– 平均查找长度与 logn 成正比</p>
<p><strong>次优查找树的构建</strong></p>
<ul>
<li><p>已知按关键字升序排列的记录序列$ (r<em>l ,r</em>{l+1} ,…,r_h )$ ,与每个记录相应的权值为 $w<em>l ,w</em>{l+1} ,…,w_h$,现构造一颗二叉树,使得该树的带权内路径长度 PH 值在所有具有相同权值的二叉树中近似为最小</p>
</li>
<li><p>取第 i(l&lt;=i&lt;=h) 个记录构造根节点,使得下式取最小</p>
<p>$$\Delta P<em>i=|\sum</em>{j=i+1}^{h}w<em>j-\sum</em>{j=l}^{i-1}|$$</p>
</li>
<li><p>然后分别对子序列 $(r<em>l ,r</em>{l+1} ,…,r<em>{i-1} ) , (r</em>{i+1 },…,r_h )​$构造两颗次优查找树,并分别设为根节点的左子树和右子树.</p>
</li>
</ul>
<p><strong>递归构造次优查找树t</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据有序表 R[low..high] 及其累计权值表 sw( 其中 sw[0]==0)构造次优查找树 t</span></div><div class="line"><span class="function">BiTree <span class="title">SecondOptimal</span><span class="params">(ElemType R[], <span class="keyword">float</span> sw[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i,j; </div><div class="line">  <span class="keyword">float</span> min,dw; </div><div class="line">  BiTree *t;</div><div class="line">  i = low; </div><div class="line">  min = (<span class="keyword">float</span>) <span class="built_in">fabs</span>(sw[high]-sw[low]);</div><div class="line">  dw = sw[high]+sw[low<span class="number">-1</span>];</div><div class="line">  <span class="keyword">for</span> (j=low+<span class="number">1</span>; j&lt;=high; ++j) <span class="comment">// 选择最小的 ΔPi 值</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(dw-sw[j]-sw[j<span class="number">-1</span>]) &lt; min) &#123;</div><div class="line">      i = j; min = (<span class="keyword">float</span>)<span class="built_in">fabs</span>(dw-sw[j]-sw[j<span class="number">-1</span>]);</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">if</span> (!(t = (BiTree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTreeTNode))))</div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">  t-&gt;data = R[i];</div><div class="line"><span class="comment">// 生成结点</span></div><div class="line">  <span class="keyword">if</span> (i==low) </div><div class="line">    t-&gt;lchild = <span class="literal">NULL</span>;</div><div class="line"><span class="comment">// 左子树空</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    t-&gt;lchild=SecondOptimal(R, sw, low, i<span class="number">-1</span>); <span class="comment">// 构造左子树</span></div><div class="line">  <span class="keyword">if</span> (i==high) </div><div class="line">    t-&gt;rchild = <span class="literal">NULL</span>; <span class="comment">// 右子树空</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    t-&gt;rchild=SecondOptimal(R, sw, i+<span class="number">1</span>, high); <span class="comment">// 构造右子树</span></div><div class="line">  <span class="keyword">return</span> t; </div><div class="line">&#125; <span class="comment">// SecondOptimal</span></div></pre></td></tr></table></figure>
<h3 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h3><p><strong>表的组织方式</strong></p>
<ul>
<li>若以线性表的形式组织查找表,那么如需要对查找表进行插入、删除或排序操作,就必须移动大量的记录</li>
</ul>
<p>– 当记录数很多时,这种移动的代价很大</p>
<ul>
<li>以树的形式组织查找表,可以对查找表进行动态、高效的查找</li>
</ul>
<p>– 二叉排序树<br>– 平衡二叉树<br>– B 树<br>– B+ 树<br>– 键树</p>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>二叉排序树或者是空树,或者是满足下列性质的二叉树:</p>
<ul>
<li>若左子树不为空,则左子树上所有结点的值( 关键字 ) 都小于根结点的值;</li>
<li>若右子树不为空,则右子树上所有结点的值( 关键字 ) 都大于根结点的值;</li>
<li>左、右子树都分别是二叉排序树</li>
<li>每个结点的 Key 互不相同</li>
</ul>
<p><strong>数据结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//BST 可以用二叉链表来存储</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> RecType&#123;</div><div class="line">  KeyType key;</div><div class="line"><span class="comment">//Others</span></div><div class="line">&#125; ElemType;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BiTreeNode &#123;</div><div class="line">  ElemType data;</div><div class="line">  <span class="keyword">struct</span> BiTreeNode *lchild,*rchild;</div><div class="line">&#125; *BiTree;</div></pre></td></tr></table></figure>
<p><strong>BST的查找算法1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在根指针 T 所指二叉排序树中,</span></div><div class="line"><span class="comment">// 递归地查找其关键字等于 key 的数据元素,</span></div><div class="line"><span class="comment">// 若查找成功,则返回指向该数据元素结点的指针</span></div><div class="line"><span class="comment">// 若查找不成功,则返回空指针</span></div><div class="line"><span class="function">BiTree <span class="title">SearchBST</span> <span class="params">(BiTree T, KeyType key)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!T || EQ(key, T-&gt;data.key)) </div><div class="line">    <span class="keyword">return</span> T; <span class="comment">// 查找结束</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (LT(key, T-&gt;data.key))</div><div class="line">    <span class="keyword">return</span> SearchBST(T-&gt;lchild, key); <span class="comment">// 在左子树中查找</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> SearchBST(T-&gt;rchild, key); <span class="comment">// 在右子树中查找</span></div><div class="line">&#125; <span class="comment">// SearchBST</span></div></pre></td></tr></table></figure>
<p><strong>注：若按中序遍历一棵二叉排序树,所得到的结点序列是一个递增序列</strong></p>
<p><strong>BST的构造</strong></p>
<ul>
<li>BST 是在查找过程中,当树中不存在关键字等于给定值的结点时进行插入</li>
</ul>
<p>– 新插入的结点一定是 BST 的一个新的叶子结点,并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子</p>
<ul>
<li>因此:</li>
</ul>
<p>– 需要一个 BST 的查找算法,它在没有找到指定值时,返回:查找路径上访问的最后一个结点<br>– 基于上述查找算法,形成 BST 的构造算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 若查找成功,则指针 p 指向该数据元素结点,并返回 TRUE</span></div><div class="line"><span class="comment">// 否则指针 p 指向查找路径上访问的最后一个结点,并返回</span></div><div class="line"><span class="comment">// FALSE 。指针 f 指向 T 的双亲,其初始调用值为 NULL</span></div><div class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, KeyType key, BiTree f, BiTree &amp;p)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span> (!T) &#123;</div><div class="line">    p = f; <span class="keyword">return</span> FALSE; </div><div class="line">  &#125; <span class="comment">// 查找不成功</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (EQ(key, T-&gt;data.key)) &#123;</div><div class="line">    p = T; <span class="keyword">return</span> TRUE; </div><div class="line">  &#125; <span class="comment">// 查找成功</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (LT(key, T-&gt;data.key))</div><div class="line">    <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p); <span class="comment">// 在左子树中查找</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p); <span class="comment">// 在右子树中查找</span></div><div class="line">&#125; <span class="comment">// SearchBST</span></div></pre></td></tr></table></figure>
<p><strong>BST的插入算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当二叉排序树 T 中没有关键字等于 e.key 的数据元素时,</span></div><div class="line"><span class="comment">// 插入 e 并返回 TRUE ,否则返回 FALSE</span></div><div class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree &amp;T, ElemType e)</span></span>&#123;</div><div class="line">  BiTree p,s;</div><div class="line">  <span class="keyword">if</span> (!SearchBST(T, e.key, <span class="literal">NULL</span>, p)) &#123; <span class="comment">// 查找不成功</span></div><div class="line">    s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>( BiTreeNode ));</div><div class="line">    s-&gt;data = e; </div><div class="line">    s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>; </div><div class="line">    <span class="keyword">if</span> (!p) T = s; <span class="comment">// 插入 s 为新的根结点</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (LT(e.key, p-&gt;data.key))</div><div class="line">      p-&gt;lchild=s; <span class="comment">// 插入 s 为左孩子 时,不必移动其它</span></div><div class="line">    <span class="keyword">else</span> </div><div class="line">      p-&gt;rchild=s;<span class="comment">// 插入 s 为右孩子</span></div><div class="line">    <span class="keyword">return</span> TRUE;</div><div class="line">  &#125; </div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> FALSE; <span class="comment">// 树中已有关键字相同的结点,不再插入</span></div><div class="line">&#125; <span class="comment">// Insert BST</span></div></pre></td></tr></table></figure>
<p><strong>BST上节点的删除</strong></p>
<p>从 BST 上删除一个结点,需要保证删除结点后的树仍满足 BST 的性质</p>
<p>设被删除结点为 p ,其父结点为 f ,分如下情况:</p>
<ol>
<li><p>若 p 是叶子结点: 直接删除 p</p>
</li>
<li><p>若 p 只有一棵子树 ( 左子树或右子树 ) :直接用 p 的左子树 ( 或右子树 ) 取代 p 的位置而成为 f 的一棵子树</p>
</li>
<li><p>若 p 既有左子树又有右子树</p>
<p>方法一：用 p 的直接前驱 ( 或直接后继 ) 结点 s 代替 p ,即从 p 的左子树中选择值最大的结点 s 放在 p 的位置 ( 用结点 s 的内容替换结点 p 内容 ) ,然后删除结点 s ,并将 s的左子树作为 s 的父结点的右子树</p>
<p>方法二：找到 s , s 是 p 的左子树中的最右边的结点且没有右子树,将 p 的右子树作为 s 的右子树,然后用 p 的左子树顶替被删结点 ( 也就是将 p 的左子树为 f 的左子树 )</p>
</li>
</ol>
<p><strong>算法实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree *T, KeyType key)</span></span></div><div class="line"><span class="comment">// 若二叉排序树 T 中存在关键字等于 key 的数据元素时,</span></div><div class="line"><span class="comment">// 则删除该数据元素结点 p ,返回 TRUE ;否则返回 FALSE</span></div><div class="line">&#123; </div><div class="line">  <span class="keyword">if</span> (!T)</div><div class="line">    <span class="keyword">return</span> FALSE;<span class="comment">// 不存在关键字等于 key 的数据元素</span></div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (EQ(key, T-&gt;data.key))</div><div class="line"><span class="comment">// 找到关键字等于 key 的数据元素</span></div><div class="line">      <span class="keyword">return</span> Delete(T);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (LT(key, T-&gt;data.key))</div><div class="line">      <span class="keyword">return</span> DeleteBST(T-&gt;lchild, key);</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="keyword">return</span> DeleteBST(T-&gt;rchild, key);</div><div class="line">  &#125;</div><div class="line">&#125;<span class="comment">//DeleteBST</span></div><div class="line"><span class="comment">// 从二叉排序树中删除结点 p ,并重接它的左或右子树，伪代码</span></div><div class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree &amp;p)</span> </span>&#123;</div><div class="line">  BiTree q, s;</div><div class="line">  <span class="keyword">if</span> (!p-&gt;rchild) &#123;<span class="comment">// 右子树空则只需重接它的左子树</span></div><div class="line">    q = p; p = p-&gt;lchild;</div><div class="line">    <span class="comment">//将 p 原来的父结点 ( 设为 f) 与 p 相连 </span></div><div class="line">    f-&gt;lchild/rchild=p</div><div class="line">      <span class="built_in">free</span>(q); </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;lchild) &#123;<span class="comment">// 只需重接它的右子树</span></div><div class="line">    q = p; p = p-&gt;rchild;</div><div class="line">   <span class="comment">//将 p 原来的父结点 ( 设为 f) 与 p 相连 </span></div><div class="line">    f-&gt;lchild/rchild=p</div><div class="line">      <span class="built_in">free</span>(q); </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123; <span class="comment">// 左右子树均不空,按方法一</span></div><div class="line"><span class="comment">// 左右子树均不空</span></div><div class="line">    q = p; s = p-&gt;lchild;</div><div class="line">    <span class="keyword">while</span> (s-&gt;rchild)</div><div class="line"><span class="comment">// 转左,然后向右到尽头 q</span></div><div class="line">    &#123;</div><div class="line">      q = s; s = s-&gt;rchild;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//s 指向被删结点的前驱</span></div><div class="line">    p-&gt;data = s-&gt;data;</div><div class="line">    <span class="keyword">if</span> (q != p)</div><div class="line">      q-&gt;rchild = s-&gt;lchild;</div><div class="line"><span class="comment">// 重接 *q 的右子树</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">      q-&gt;lchild = s-&gt;lchild;</div><div class="line"><span class="comment">// 重接 *q 的左子树</span></div><div class="line">    <span class="built_in">free</span>(s);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>BST的查找性能分析</strong></p>
<ul>
<li>二叉排序树上成功的查找次数不会超过二叉树的深度,而具有 n 个结点的二叉排序树的深度,最好为 log2n ,最坏为 n 。因此二叉排序树查找的最好时间复杂度为 O(log2n) ,最坏的时间复杂度为 O(n)。</li>
<li>在随机情况下, n 个结点的二叉排序树的平均查找长度 (ASL) 和log2n ( 树的深度 ) 是等数量级的。</li>
<li>随机:各个元素的查找概率相同,元素组成的序列是随机的</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;查找表 (Search Table) :相同类型的数据元素 ( 或记录 ) 组成的集合,每个数据元素通常由若干数据项构成&lt;/li&gt;
&lt;li&gt;关键字 (Key ,码 ) :数据元素中某个 ( 或几个 ) 数据项的值,它可以标识一个数据元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;– 主关键字 (Primary Key) :能唯一标识一个数据元素的关键字&lt;br&gt;– 次关键字 (Secondary Key) :能标识若干个数据元素的关键字&lt;/p&gt;
&lt;h4 id=&quot;关键字类型&quot;&gt;&lt;a href=&quot;#关键字类型&quot; class=&quot;headerlink&quot; title=&quot;关键字类型&quot;&gt;&lt;/a&gt;关键字类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;数据元素的关键字:其类型通常是可以进行比较运算的类型&lt;/li&gt;
&lt;li&gt;典型的关键字类型&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; KeyType ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实型&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; KeyType ; &lt;span class=&quot;comment&quot;&gt;// 整型&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; KeyType ; &lt;span class=&quot;comment&quot;&gt;// 字符串型&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;• 数据元素类型&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; RecType &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;KeyType key ; &lt;span class=&quot;comment&quot;&gt;// 关键字域&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;... ... &lt;span class=&quot;comment&quot;&gt;// 其他域&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; ElemType;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Data-Structures" scheme="http://ucasfl.me/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>动态存储管理</title>
    <link href="http://ucasfl.me/2017/07/30/Dynamic-Memory-Management/"/>
    <id>http://ucasfl.me/2017/07/30/Dynamic-Memory-Management/</id>
    <published>2017-07-30T11:57:40.000Z</published>
    <updated>2017-09-02T04:38:29.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="存储空间的分配和管理"><a href="#存储空间的分配和管理" class="headerlink" title="存储空间的分配和管理"></a>存储空间的分配和管理</h3><ul>
<li>问题的来源: ( 数据 ) 结构中的每一个数据元素都对应一定的存储空间,数据元素的访问都是通过对应的存储单元来进行的 – 操作系统、编译程序 ( 例如 JVM) 、用户程序</li>
<li>问题的解决策略:采用动态存储管理思想</li>
<li>存储空间的分配和管理策略的选择与用户的需求有关:<ul>
<li>用户存储请求的分配量的大小分布</li>
<li>用户存储分配请求和释放请求的频率</li>
<li>分配效率 对系统的重要性</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="动态存储管理-堆的管理"><a href="#动态存储管理-堆的管理" class="headerlink" title="动态存储管理 - 堆的管理"></a>动态存储管理 - 堆的管理</h3><ul>
<li>堆(heap)：操作系统在内存中划出一块地址连续的大区域<ul>
<li>占用块:已分配给用户使用的一块地址连续的内存区域;</li>
<li>空闲块:未曾分配的地址连续的内存区域</li>
</ul>
</li>
<li>堆的管理要解决的问题:如何根据用户的存储 / 内存分配请求分配内存空间?如何回收被释放的或不再使用的 ) 内存空间?</li>
<li>堆的使用:利用程序设计语言提供的内存动态分配函数<br>– C : malloc() , calloc() , realloc , free() 函数<br>– C++ : new , delete 函数等</li>
</ul>
<h3 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h3><p>方式1： 从高地址空闲块中进行分配,直到分配无法进行时,才回收所有用户不再使用的空闲块,重新组织一个大的空闲块来再分配。</p>
<p>方式2：用户程序一旦运行结束,便将它所占的内存区释放成为空闲块,同时,每当新用户请求分配内存时,需查找整个内存区中所有空闲块,并从中找出一个合适的空闲块分配之。</p>
<h3 id="可利用空间表"><a href="#可利用空间表" class="headerlink" title="可利用空间表"></a>可利用空间表</h3><ul>
<li>可利用空间表 / 存储池:包含所有可分配的空闲块</li>
</ul>
<p>​       – 当用户请求分配时,系统从可利用空间表中删除一个结点分配之<br>​       – 当用户释放其所占内存时,系统即回收并将它插入到可利用空间表中</p>
<ul>
<li>可利用空间表的组织方式</li>
</ul>
<p>​       – 目录表<br>​       – 链表方式</p>
<h3 id="链式可利用空间表的分配方式"><a href="#链式可利用空间表的分配方式" class="headerlink" title="链式可利用空间表的分配方式"></a>链式可利用空间表的分配方式</h3><ul>
<li>当可利用空间表以链表方式组织时,每个空闲块就是链表中的一个结点<br>– 分配时:从链表中找到一个合适的结点加以分配,然后将该结点删除之;<br>– 回收时:将空闲块插入到链表中。</li>
<li>具体的分配和释放的策略取决于结点 ( 空闲块 ) 的结构<br>– 空闲块的大小相同<br>– 空闲块的大小只有几种规格<br>– 空闲块的大小不固定</li>
</ul>
<h4 id="分配方式1：空闲块的大小相同"><a href="#分配方式1：空闲块的大小相同" class="headerlink" title="分配方式1：空闲块的大小相同"></a>分配方式1：空闲块的大小相同</h4><p>– 将进行动态存储分配的整个内存区域( 堆 ) 按所需大小分割成若干大小相同的块,然后用指针链接成一个可利用空间表。<br>– 分配时:从表的首结点分配,然后删除该结点<br>– 回收时:将释放的空闲块插入表头<br>– 存在的问题:空间利用率不高<br>当请求分配的块空间大小比最大规格的结点还大时,分配不能进行。而实际上内存空间却可能存在比所需大小还要大的的连续空间。</p>
<h4 id="分配方式2：空闲块大小只有几种规格"><a href="#分配方式2：空闲块大小只有几种规格" class="headerlink" title="分配方式2：空闲块大小只有几种规格"></a>分配方式2：空闲块大小只有几种规格</h4><p>– 根据统计分析得到的概率分布,事先对动态分配的堆建立若干个可利用空间链表,同一链表中的结点 ( 块 ) 大小都相同。<br>– 分配时:根据请求的大小,将最接近该大小的某个链表的首结点分配给用户。若剩余部分正好是另一种规格大小,则将剩余部分插入到另一种规格的链表中,然后删除该结点<br>– 回收时:只要将所释放的空闲块插入到相应大小的表头<br>– 存在的问题:同前</p>
<h4 id="分配方式3：请求分配的块大小不确定"><a href="#分配方式3：请求分配的块大小不确定" class="headerlink" title="分配方式3：请求分配的块大小不确定"></a>分配方式3：请求分配的块大小不确定</h4><p>– 整个堆空间开始是一个空闲块,链表中只有一个大小为整个堆的结点,随着分配和回收的进行,链表中的结点大小和个数动态变化<br>– 链表结点中,增加一个表示结点大小的域 (size),以保存空闲块的大小<br>– 分配策略:若用户请求分配大小为 n(kB) 的内存,而链表中有若干大小不小于 n 的空闲块时,如何分配 ?</p>
<ul>
<li>首次拟合法 (First fit)</li>
<li>最佳拟合法 (Best fit)</li>
<li>最差拟合法 (Worst fit)</li>
</ul>
<h3 id="首次拟合法-First-fit"><a href="#首次拟合法-First-fit" class="headerlink" title="首次拟合法 (First fit)"></a>首次拟合法 (First fit)</h3><ul>
<li>分配时:从表头指针开始查找可利用空间表,将找到的第一个不小于 n 的空闲块的部分 ( 所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点</li>
<li>回收时:将释放的空闲块插在链表的表头</li>
<li>特点:分配时随机的;回收时仅需插入到表头</li>
</ul>
<h3 id="最佳拟合法-Best-fit"><a href="#最佳拟合法-Best-fit" class="headerlink" title="最佳拟合法 (Best fit)"></a>最佳拟合法 (Best fit)</h3><ul>
<li>分配时:扫描整个可利用空间链表,找到一个大小满足要求且最接近 n 的空闲块,将其中的一部分 ( 即所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点</li>
<li>回收时:只要将释放的空闲块插入到可利用空间链表的合适位置</li>
<li>为了使分配时不需要扫描整个可利用空间链表,链表组织 ( 包括块回收时 ) 成按从小到大排序 ( 升序 )</li>
<li>优点:适用于请求分配的内存块大小范围较广的系统</li>
<li>缺点:系统容易产生无法分配的内存碎片;无论分配与回收,都需要查找空闲链表,最费时</li>
</ul>
<h3 id="最差拟合法-Worst-fit"><a href="#最差拟合法-Worst-fit" class="headerlink" title="最差拟合法 (Worst fit)"></a>最差拟合法 (Worst fit)</h3><ul>
<li>分配时:扫描整个可利用空间链表,找到一个大小最大的空闲块,将其中的一部分 ( 所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点</li>
<li>回收时:只要将释放的空闲块插入到链表的合适位置</li>
<li>为了使分配时不需要扫描整个可利用空间链表,链表组织 ( 块回收时 ) 成按从大到小排序 (降序 )</li>
<li>特点:适用于请求分配的内存块的大小范围较窄的系统;分配无需查找,回收需要查找适当的位置</li>
</ul>
<h3 id="边界标识法-Boundary-Tag-Method"><a href="#边界标识法-Boundary-Tag-Method" class="headerlink" title="边界标识法 (Boundary Tag Method)"></a>边界标识法 (Boundary Tag Method)</h3><ul>
<li>操作系统中常用的动态存储管理方法</li>
<li>将所有的空闲块链接成一个双重循环链表</li>
<li>每个内存区域的头部和底部两个边界上分别设置标识,以标识该区域为占用块或空闲块</li>
<li>在回收块时易于判别在物理位置上与其相邻的内存区域是否为空闲块,以便于将所有地址连续的空闲存储区合并成一个尽可能大的空闲块</li>
</ul>
<p>可利用空间表的节点结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> word &#123;</div><div class="line"><span class="keyword">union</span> &#123;</div><div class="line"><span class="comment">// 头部域,指向前驱结点</span></div><div class="line">  <span class="keyword">struct</span> word *llink;</div><div class="line"><span class="comment">// 尾部域,指向本结点的头部</span></div><div class="line">  <span class="keyword">struct</span> word *uplink;</div><div class="line">&#125;;</div><div class="line">  <span class="keyword">int</span> tag; <span class="comment">//0 :空闲; 1 :占用</span></div><div class="line">  <span class="keyword">int</span> size;</div><div class="line"><span class="comment">// 头部域,指向后继结点</span></div><div class="line">  <span class="keyword">struct</span> word *rlink;</div><div class="line"><span class="comment">//OtherType other;</span></div><div class="line">&#125;WORD, head, foot, *Space;</div><div class="line"><span class="comment">// 指向 p 所指结点的底部</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FootLoc(p) (p+p-&gt;size-1)</span></div><div class="line"><span class="function">Space <span class="title">FootLoc</span><span class="params">(Space p)</span> </span>&#123;</div><div class="line">  <span class="keyword">char</span> *q; Space f;</div><div class="line">  q=(<span class="keyword">char</span> *)p;</div><div class="line">  f=(Space)(q+<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*p-&gt;size-<span class="keyword">sizeof</span>(foot));</div><div class="line">  <span class="keyword">return</span> f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分配算法：两个约定"><a href="#分配算法：两个约定" class="headerlink" title="分配算法：两个约定"></a>分配算法：两个约定</h3><h4 id="分配约定"><a href="#分配约定" class="headerlink" title="分配约定"></a>分配约定</h4><ul>
<li>选定适当常量 e ,设待分配空闲块、请求分配空间的大小分别为 m 、 n</li>
<li>当 m-n&lt;=e 时:将整个空闲块分配给用户;</li>
<li>当 m-n&gt;e 时:则只分配请求的大小 n 给用户;</li>
<li>尽量减少空闲块链表中出现小碎片 ( 容量 ≤ e) ,提高分配效率;减少对空闲块链表的维护工作量</li>
<li>为了避免修改指针,约定将高地址部分分配给用户</li>
</ul>
<h4 id="查找约定"><a href="#查找约定" class="headerlink" title="查找约定"></a>查找约定</h4><ul>
<li>每次需要查找空闲块时,从上次刚分配结点的后继结点开始查找空闲块</li>
<li>作用:提高查找空闲块的速度,防止小容量结点聚集</li>
</ul>
<h3 id="分配算法：首次拟合法"><a href="#分配算法：首次拟合法" class="headerlink" title="分配算法：首次拟合法"></a>分配算法：首次拟合法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> e = <span class="number">16</span>; <span class="comment">// 不保留小于等于 e 的剩余量</span></div><div class="line"><span class="comment">// 若有不小于 n 的空闲块,则分配相应的存储块,并返</span></div><div class="line">回其首地址, 否则返回 <span class="function"><span class="literal">NULL</span></span></div><div class="line">Space <span class="title">AllocBoundTag</span><span class="params">(Space pav, <span class="keyword">int</span> n)</span> &#123;</div><div class="line">  Space p;</div><div class="line"><span class="comment">// 查找不小于 n 的空闲块</span></div><div class="line">  <span class="keyword">for</span> (p=pav; p &amp;&amp; p-&gt;size&lt;n &amp;&amp; p-&gt;rlink!=pav; p=p-&gt;rlink);</div><div class="line">  <span class="keyword">if</span> (!p || p-&gt;size&lt;n) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 找不到,返回空指针</span></div><div class="line">  <span class="keyword">else</span> &#123; <span class="comment">// p 指向找到的空闲块</span></div><div class="line">    Space f = FootLoc(p); <span class="comment">// f 指向底部</span></div><div class="line">    pav = p-&gt;rlink;</div><div class="line"><span class="comment">// pav 指向 *p 结点的后继结点</span></div><div class="line">    <span class="keyword">if</span> (p-&gt;size-n &lt;= e) &#123; <span class="comment">// 整块分配,不保留小于等于 e 的剩余量</span></div><div class="line">      <span class="keyword">if</span> (pav==p) pav = <span class="literal">NULL</span>; <span class="comment">// 可利用空间表变为空表</span></div><div class="line">      <span class="keyword">else</span> &#123; <span class="comment">// 在表中删除分配的结点</span></div><div class="line">        pav-&gt;llink = p-&gt;llink; p-&gt;llink-&gt;rlink = pav;</div><div class="line">      &#125;</div><div class="line">      p-&gt;tag = f-&gt;tag = <span class="number">1</span>; <span class="comment">// 修改分配结点的头部和底部标志</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 分配该块的后 n 个字</span></div><div class="line">      f-&gt;tag = <span class="number">1</span>; <span class="comment">// 修改分配块的底部标志</span></div><div class="line">      p-&gt;size -= n; <span class="comment">// 置剩余块大小</span></div><div class="line">      f = FootLoc(p); <span class="comment">// 指向剩余块底部</span></div><div class="line">      f-&gt;tag = <span class="number">0</span>; f-&gt;uplink = p; <span class="comment">// 设置剩余块底部</span></div><div class="line">      p = f+<span class="number">1</span>; <span class="comment">// 指向分配块头部</span></div><div class="line">      p-&gt;tag = <span class="number">1</span>; p-&gt;size = n; <span class="comment">// 设置分配块头部</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回分配块首地址</span></div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">// AllocBoundTag</span></div></pre></td></tr></table></figure>
<h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><ul>
<li>释放块的左、右邻块均为占用块:将被释放块简单地插入到空闲块链表中即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">p-&gt;tag=<span class="number">0</span> ; FootLoc(p)-&gt;uplink=p;</div><div class="line">FootLoc(p)-&gt;tag=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> ( !pav )</div><div class="line">pav=p-&gt;llink=p-&gt;rlink=p; <span class="comment">// 第一个空闲块</span></div><div class="line"><span class="keyword">else</span> &#123;<span class="comment">// 刚释放的空闲结点是插在 pav 之前,并成为 pav</span></div><div class="line">q=pav-&gt;llink; p-&gt;rlink=pav ;</div><div class="line">p-&gt;llink=q ; q-&gt;rlink=pav-&gt;llink=p ;</div><div class="line">pav=p ; <span class="comment">//pav 指向刚释放的空闲结点</span></div><div class="line"><span class="comment">// 成为下次分配最先查询的结点</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="情况2、3"><a href="#情况2、3" class="headerlink" title="情况2、3"></a>情况2、3</h4><ul>
<li>释放块的左邻块空闲而右邻块为占用:和左邻块合并成一个大的空闲块结点,改变左邻块的 size 域及重新设置 ( 合并后 ) 结点的底部</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">n=p-&gt;size;</div><div class="line">s=(p<span class="number">-1</span>)-&gt;uplink; s-&gt;size+=n; <span class="comment">// 设置新空闲块大小</span></div><div class="line">f=FootLoc(p); f-&gt;uplink=s; f-&gt;tag=<span class="number">0</span>; <span class="comment">// 设置新空闲块底部</span></div></pre></td></tr></table></figure>
<ul>
<li>释放块的左邻占用而右邻空闲:和右邻块合并成一个大的空闲块结点,改变右邻块的 size 域及重新设置( 合并后 ) 结点的头部</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">t= FootLoc(p)+<span class="number">1</span>; p-&gt;tag=<span class="number">0</span>; q=t-&gt;llink;</div><div class="line">p-&gt;llink=q; q-&gt;rlink=p ; <span class="comment">// 设置空闲块的前驱</span></div><div class="line">q1=t-&gt;rlink ; p-&gt;rlink=q1 ; q1-&gt;llink=p ;</div><div class="line">p-&gt;size+=t-&gt;size; <span class="comment">// 设置新空闲块大小</span></div><div class="line">FootLoc(t)-&gt;uplink=p ; <span class="comment">// 底部指针指向新结点的头部</span></div></pre></td></tr></table></figure>
<h4 id="情况4"><a href="#情况4" class="headerlink" title="情况4"></a>情况4</h4><ul>
<li>释放块的左、右邻块均为空闲块:和左、右邻块合并成一个大的空闲块结点,改变左邻块的 size 域及重新设置 ( 合并后 ) 结点的底部</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">n=p-&gt;size;</div><div class="line">s=(p<span class="number">-1</span>)-&gt;uplink;<span class="comment">//s 指向左邻块</span></div><div class="line">t= FootLoc(p)+<span class="number">1</span>; <span class="comment">//t 指向右邻块 , p+p-&gt;size</span></div><div class="line">s-&gt;size +=n+t-&gt;size; <span class="comment">// 设置新空闲结点的大小</span></div><div class="line"><span class="comment">// 在空闲链表中,删除右邻空闲块</span></div><div class="line">q=t-&gt;llink; q1=t-&gt;rlink; <span class="comment">// 修改右邻原来的关系</span></div><div class="line">q-&gt;rlink=q1; q1-&gt;llink=q ;</div><div class="line">FootLoc(t)-&gt;uplink=s; <span class="comment">// 新结点底部指针指向其头部</span></div></pre></td></tr></table></figure>
<h3 id="伙伴系统-Buddy-System"><a href="#伙伴系统-Buddy-System" class="headerlink" title="伙伴系统 (Buddy System)"></a>伙伴系统 (Buddy System)</h3><ul>
<li>操作系统中常用的动态存储管理方法</li>
<li>与边界标识法类似,所不同是:无论占用块或空闲块,其大小均为 2 的 k 次幂 ,不是以顺序片段来分配内存</li>
<li>伙伴系统的可利用空间表:<ul>
<li>将所有大小相同的空闲块建于一张子表中,每个子表是一个双重链表,这样的链表可能有 m+1 个</li>
<li>再将这 m+1 个表头指针用向量结构组织成一个表</li>
</ul>
</li>
</ul>
<p>可利用空间表的结构:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M 16</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> WORD_b &#123;</div><div class="line">  WORD_b * llink;<span class="comment">// 前驱结点</span></div><div class="line">  <span class="keyword">int</span> tag;<span class="comment">// 块占用标识</span></div><div class="line">  <span class="keyword">int</span> kval;<span class="comment">// 块的大小,是 2 的幂次</span></div><div class="line">  WORD_b *rlink;<span class="comment">// 后继结点</span></div><div class="line">  OtherType other;</div><div class="line">&#125; WORD_b, head;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> HeadNode &#123;</div><div class="line">  <span class="keyword">int</span> nodesize;</div><div class="line">  WORD_b * first;</div><div class="line">&#125; FreeList[M+<span class="number">1</span>];<span class="comment">// 子表个数为 M+1</span></div></pre></td></tr></table></figure>
<h4 id="伙伴系统的分配算法"><a href="#伙伴系统的分配算法" class="headerlink" title="伙伴系统的分配算法"></a>伙伴系统的分配算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function">WORD_b* <span class="title">AllocBuddy</span> <span class="params">(FreeList avail[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"><span class="comment">// avail[0..m] 为可利用空间表, n 为申请分配量,若有不小于n 的空闲块,则分配相应的存储块,并返回其首地址;否则返回 NULL</span></div><div class="line">  WORD_b *pa, *pre, *suc, *pi;</div><div class="line"><span class="comment">// 查找满足分配要求的子表</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=m &amp;&amp; (!avail[k].first ||avail[k].nodesize&lt;n+<span class="number">1</span>);k++) ;</div><div class="line">  <span class="keyword">if</span> (k&gt;m) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 分配失败</span></div><div class="line">  <span class="keyword">else</span> &#123; <span class="comment">// 进行分配</span></div><div class="line">    pa = avail[k].first; <span class="comment">// 指向可分配子表的第一个结点</span></div><div class="line"><span class="comment">// 分别指向前驱和后继</span></div><div class="line">    pre = pa-&gt;llink; suc = pa-&gt;rlink;</div><div class="line">    <span class="keyword">if</span> (pa==suc)</div><div class="line">      avail[k].first = <span class="literal">NULL</span>; <span class="comment">// 分配后该子表变成空表</span></div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 从子表删去 *pa 结点</span></div><div class="line">      pre-&gt;rlink = suc; suc-&gt;llink = pre;</div><div class="line">      avail[k].first = suc;</div><div class="line">    &#125;</div><div class="line"><span class="comment">// 将剩余块插入相应子表</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; avail[k-i].nodesize&gt;=n+<span class="number">1</span>; ++i) &#123;</div><div class="line">      pi = pa+(<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, (k-i)); pi-&gt;rlink = pi;</div><div class="line">      pi-&gt;llink = pi; pi-&gt;tag = <span class="number">0</span>; pi-&gt;kval = k-i;</div><div class="line">      avail[k-i].first = pi; </div><div class="line">    &#125;</div><div class="line">    pa-&gt;tag = <span class="number">1</span>; pa-&gt;kval = k-(--i);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> pa;</div><div class="line">&#125; <span class="comment">// AllocBuddy</span></div></pre></td></tr></table></figure>
<h4 id="回收算法-1"><a href="#回收算法-1" class="headerlink" title="回收算法"></a>回收算法</h4><ul>
<li>释放占用块时,需要将该新的空闲块插入到可利用空闲表中</li>
<li>考虑合并成大块的问题:只有 “ 互为伙伴 ” 的两个子块均空闲时才合并;即使有两个相邻且大小相同的空闲块,如果不是 “ 互为伙伴 ” ( 从同一个大块中分裂出来的 ) 也不合并。</li>
</ul>
<p>设要回收的空闲块的首地址是 p ,其大小为 2^k :<br> (1) 判断其 “ 互为伙伴 ” 的块是否空闲:</p>
<ul>
<li>若不空闲,仅将要回收的空闲块直接插入到相应的子表中;否则转 (2) ;</li>
</ul>
<p>(2) 按以下步骤进行空闲块的合并:</p>
<ul>
<li>在相应子表中找到其伙伴并删除之;</li>
<li>合并两个空闲块;</li>
</ul>
<p>(3) 重复 (2) ,直到合并后的空闲块的伙伴不是空闲块为止</p>
<ul>
<li>特点:算法简单;速度快;但容易产生碎片</li>
</ul>
<h3 id="无用单元收集"><a href="#无用单元收集" class="headerlink" title="无用单元收集"></a>无用单元收集</h3><ul>
<li>无用单元:用户不再使用而系统没有回收的变量和结构</li>
<li>产生原因:程序 Bug</li>
</ul>
<p>– p=malloc(size); … … p=NULL; // 未回收的空间<br>– p=malloc(size); … … q=p;free(p);// 悬挂访问</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;存储空间的分配和管理&quot;&gt;&lt;a href=&quot;#存储空间的分配和管理&quot; class=&quot;headerlink&quot; title=&quot;存储空间的分配和管理&quot;&gt;&lt;/a&gt;存储空间的分配和管理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;问题的来源: ( 数据 ) 结构中的每一个数据元素都对应一定的存储空间,数据元素的访问都是通过对应的存储单元来进行的 – 操作系统、编译程序 ( 例如 JVM) 、用户程序&lt;/li&gt;
&lt;li&gt;问题的解决策略:采用动态存储管理思想&lt;/li&gt;
&lt;li&gt;存储空间的分配和管理策略的选择与用户的需求有关:&lt;ul&gt;
&lt;li&gt;用户存储请求的分配量的大小分布&lt;/li&gt;
&lt;li&gt;用户存储分配请求和释放请求的频率&lt;/li&gt;
&lt;li&gt;分配效率 对系统的重要性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Data-Structures" scheme="http://ucasfl.me/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>局部变量的栈溢出</title>
    <link href="http://ucasfl.me/2017/07/28/Stack-Over-Flow-in-Function/"/>
    <id>http://ucasfl.me/2017/07/28/Stack-Over-Flow-in-Function/</id>
    <published>2017-07-28T13:47:54.000Z</published>
    <updated>2017-09-02T04:38:28.939Z</updated>
    
    <content type="html"><![CDATA[<p>先上代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10000000</span>;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">bool</span> Tree[MAX_N] = &#123;<span class="literal">false</span>&#125;;<span class="comment">//全局变量</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> depth, balls;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; depth &gt;&gt; balls;</div><div class="line">	 </div><div class="line">	<span class="keyword">int</span> ind = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> last = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>( ind ++ &lt; balls )&#123;</div><div class="line">		<span class="keyword">int</span> curr = <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth; ++i )&#123;</div><div class="line">			<span class="keyword">if</span>( <span class="literal">false</span> == Tree[curr] )&#123;</div><div class="line">				curr = curr*<span class="number">2</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span>&#123;</div><div class="line">				curr = curr*<span class="number">2</span> + <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">			Tree[curr] = !Tree[curr];</div><div class="line">			last = curr;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; last &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>代码1</em></p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">10000000</span>;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">bool</span> Tree[MAX_N] = &#123;<span class="literal">false</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> depth, balls;</div><div class="line">	<span class="built_in">cin</span> &gt;&gt; depth &gt;&gt; balls;</div><div class="line">    <span class="keyword">bool</span> Tree[MAX_N] = &#123;<span class="literal">false</span>&#125;;<span class="comment">//局部变量</span></div><div class="line">	 </div><div class="line">	<span class="keyword">int</span> ind = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> last = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>( ind ++ &lt; balls )&#123;</div><div class="line">		<span class="keyword">int</span> curr = <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth; ++i )&#123;</div><div class="line">			<span class="keyword">if</span>( <span class="literal">false</span> == Tree[curr] )&#123;</div><div class="line">				curr = curr*<span class="number">2</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span>&#123;</div><div class="line">				curr = curr*<span class="number">2</span> + <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">			Tree[curr] = !Tree[curr];</div><div class="line">			last = curr;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; last &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>代码2</em></p>
<p>观察<em>代码1</em>和<em>代码2</em>，二者只有一个区别，前者<code>Tree</code>为全局变量，而后者为局部变量。一般来说，我们可能觉得两个函数运行的时候不会有什么不同，然而却出现不同的结果：</p>
<p><em>代码1</em>能正确运行，<em>代码2</em>：</p>
<p><img src="/photos/stack/1.png" alt=""></p>
<p>惊喜不惊喜，意外不意外！</p>
<p>我们知道，<strong>在内存中，全局变量存于全局变量区，而局部变量位于栈中，函数以栈帧的形式存储。</strong>相对来说，全局变量区空间较大，而栈空间较小，因此便导致了<em>代码2</em>的栈溢出，而<em>代码1</em>则正常。</p>
<p><img src="/photos/stack/2.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先上代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; MAX_N = &lt;span class=&quot;number&quot;&gt;10000000&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; Tree[MAX_N] = &amp;#123;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&amp;#125;;&lt;span class=&quot;comment&quot;&gt;//全局变量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; depth, balls;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; depth &amp;gt;&amp;gt; balls;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	 &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ind = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; last = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;( ind ++ &amp;lt; balls )&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; curr = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; depth; ++i )&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; == Tree[curr] )&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				curr = curr*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				curr = curr*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			Tree[curr] = !Tree[curr];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			last = curr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; last &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;代码1&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://ucasfl.me/categories/C-C/"/>
    
    
      <category term="Stack-Over-Flow" scheme="http://ucasfl.me/tags/Stack-Over-Flow/"/>
    
  </entry>
  
  <entry>
    <title>《Linux 命令行大全》学习笔记-Part3</title>
    <link href="http://ucasfl.me/2017/06/20/Linux-Command-Line-learning-notes-Part3/"/>
    <id>http://ucasfl.me/2017/06/20/Linux-Command-Line-learning-notes-Part3/</id>
    <published>2017-06-20T04:54:21.000Z</published>
    <updated>2017-09-02T04:38:28.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Chapter-14-软件包管理"><a href="#Chapter-14-软件包管理" class="headerlink" title="Chapter 14 软件包管理"></a>Chapter 14 软件包管理</h3><p>低级软件包：</p>
<ul>
<li><p>Debian : dpkg/rpm</p>
<ul>
<li>dpkg –install file.deb/rpm -i package_file/rpm -U package_file：安装/升级软件</li>
<li>dpkg –list ：列出所有已安装软件</li>
<li>dpkg –status package_name：判断是否已安装</li>
<li>dpkg –search filename/rpm -qf file_name：查询文件所属命令</li>
</ul>
</li>
<li>高级软件包：apt-get<ul>
<li>apt-get update ; apt-cache search file_name：搜索软件包</li>
<li>apt-get update ; apt-get install package_name：安装软件包</li>
<li>apt-get remove package_name/yum erase package_name：删除软件包，彻底删除干净，可加上 –purge 参数</li>
<li>apt-get update ; apt-get upgrade ：更新/升级软件包</li>
<li>apt-cache show packagename ：显示软件包相关信息</li>
<li>apt-cache search package_name/yum search package_name：搜索软件包</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="Chapter-15-存储介质"><a href="#Chapter-15-存储介质" class="headerlink" title="Chapter 15 存储介质"></a>Chapter 15 存储介质</h3><p>/etc/fstab 文件：显示系统启动时挂载的设备。</p>
<ul>
<li>mount ：查看已挂载文件系统（不带参数）</li>
<li>mount -t ext4 /dev/sda1 /mnt ：挂载文件系统（root 权限），-t 选项指定文件系统类型</li>
<li>umount /dev/hdc：卸载设备</li>
<li>ls /dev：查看/dev目录下的设备信息</li>
<li>sudo tail -f /var/log/messages ：实时系统监测</li>
<li>sudo fdisk /dev/sdb：磁盘分区</li>
<li>sudo fdformat /dev/sdb1：格式化</li>
<li>sudo mkfs -t ext4 /dev/sdb1：创建新的文件系统(-t vfat:fat32)</li>
<li>sudo fsck /dev/sdb1：检查闪存（事先需卸载）</li>
<li>dd if=input_file of=output_file：文件复制（数据块）<ul>
<li>example: dd if=/dev/sdb of=/dev/sdc</li>
<li>​                  dd if=ubuntu.iso of=/dev/sdc（创建系统启动盘）</li>
</ul>
</li>
<li>挂载镜像文件：mkdir /mnt/iso_file; mount -t iso9660 -o loop image.iso /mnt/iso_file</li>
<li>wodim dev=/dev/cdrw blank=fast ：擦除设备</li>
<li>wodim dev=/dev/cdrw image.iso ：写入镜像文件</li>
<li>md5sum image.iso：计算校验和</li>
</ul>
<h3 id="Chapter-16-网络"><a href="#Chapter-16-网络" class="headerlink" title="Chapter 16 网络"></a>Chapter 16 网络</h3><ul>
<li><p>ping ：向网络主机发送特殊数据包，检测网络是否连通，例如：ping linux.com</p>
</li>
<li><p>traceroute ：跟踪网络数据包的传输路径，例如：traceroute ucasfl.me</p>
</li>
<li><p>netstat ：检查网络设置及相关统计数据</p>
<ul>
<li><p>-ie 选项：检查系统中的网络接口信息</p>
</li>
<li><p>-r 选项：显示内核的网络路由表</p>
</li>
</ul>
</li>
</ul>
<h4 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h4><p>ftp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ftp fileserver:连接主机</div><div class="line">cd dir:进入目录</div><div class="line">ls:列出内容</div><div class="line">lcd dir ：切换目录</div><div class="line">get something:下载东西</div><div class="line">help:显示命令列表</div></pre></td></tr></table></figure>
<p>lftp：与 ftp 类似，支持更多的协议和功能</p>
<ul>
<li>wget ：用于文件下载的命令行程序，既可从网站上下载，也可从 ftp 站点下载<ul>
<li>example:　<code>wget http://ucasfl.me/scripts/vim_config.sh</code></li>
</ul>
</li>
<li>ssh:安全登录远程计算机：ssh user@hostname/ip </li>
<li>ssh user@remote_host command : 远程执行命令</li>
<li>scp user@remote_host:document.txt /user/home/ ：将远程文件复制到当前的 home 目录下</li>
<li>sftp : 命令与 ftp 类似，不过远程主机不需要 ftp 服务器，只需要 ssh 服务器</li>
</ul>
<h3 id="Chapter-17-文件搜索"><a href="#Chapter-17-文件搜索" class="headerlink" title="Chapter 17 文件搜索"></a>Chapter 17 文件搜索</h3><ul>
<li>locate filename：搜索文件，支持扩展，例如：locate zip :搜索以 zip 开头的文件</li>
</ul>
<p>find : 较复杂的方式查找文件</p>
<p>find ~ | wc -l : 计算当前系统总目录的文件数。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">find ~ -type x : 指定类型查找，x 为参数</div><div class="line"><span class="symbol">x:</span></div><div class="line"><span class="symbol"> b:</span>块设备文件</div><div class="line"><span class="symbol"> c:</span>字符设备文件</div><div class="line"><span class="symbol"> d:</span>目录文件</div><div class="line"><span class="symbol"> f:</span>普通文件</div><div class="line"><span class="symbol"> l:</span>符号链接</div></pre></td></tr></table></figure>
<p>find 命令的 test 项参数：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">cmin n ：匹配n分钟前改变状态的文件或目录，不到n分钟，用 -n，超过n分钟，用+n</span></div><div class="line">-<span class="ruby">cnewer file <span class="symbol">:</span>匹配内容或属性的修改时间比file晚的文件或目录</span></div><div class="line">-<span class="ruby">ctime <span class="number">24</span><span class="symbol">:</span>匹配系统中n*<span class="number">24</span>小时前文件状态被改变的文件或目录</span></div><div class="line">-<span class="ruby"><span class="symbol">empty:</span> 匹配空文件或空目录</span></div><div class="line">-<span class="ruby">group <span class="symbol">name:</span>匹配属于name组的文件或目录</span></div><div class="line">-<span class="ruby">iname <span class="symbol">pattern:</span>与-name test项功能类似，只是不区分大小写</span></div><div class="line">-<span class="ruby">inum <span class="symbol">n:</span>匹配索引节点是n的文件</span></div><div class="line">-<span class="ruby">mmin <span class="symbol">n:</span>匹配n分钟前内容被修改的文件或目录</span></div><div class="line">-<span class="ruby">mtime <span class="symbol">n:</span>匹配n*<span class="number">24</span>小时前只有内容被修改的文件或目录</span></div><div class="line">-<span class="ruby">name pattern <span class="symbol">:</span>匹配有特定通配符的文件或目录</span></div><div class="line">-<span class="ruby">newer file <span class="symbol">:</span>匹配内容的修改时间比file文件更近的文件或目录</span></div><div class="line">-<span class="ruby"><span class="symbol">nouser:</span>匹配不属于有效用户的文件或目录</span></div><div class="line">-<span class="ruby"><span class="symbol">nogroup:</span>匹配不属于有效组的文件或目录</span></div><div class="line">-<span class="ruby">perm mode <span class="symbol">:</span>寻找访问权限与既定模式匹配的文件或目录</span></div><div class="line">-<span class="ruby">samefile <span class="symbol">name:</span>与-inum test 选项类似</span></div><div class="line">-<span class="ruby">size <span class="symbol">n:</span>匹配n大小的文件</span></div><div class="line">-<span class="ruby">type <span class="symbol">c:</span>匹配c类型的文件</span></div><div class="line">-<span class="ruby">user <span class="symbol">name:</span>匹配属于name用户的文件或目录</span></div></pre></td></tr></table></figure>
<p>find 命令的逻辑操作符：</p>
<ul>
<li>-and :与</li>
<li>-or : 或</li>
<li>-not : 非</li>
<li>() : 括号</li>
</ul>
<p>注：在shell中，括号需要加反斜杠进行转义。</p>
<p>action 选项：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">预定义操作：</div><div class="line">-<span class="ruby"><span class="symbol">delete:</span> 删除匹配文件</span></div><div class="line">-<span class="ruby"><span class="symbol">ls:</span> 对匹配的文件执行ls操作</span></div><div class="line">-<span class="ruby"><span class="symbol">print:</span> 将匹配的文件的全路径以标准形式打印出，默认形式</span></div><div class="line">-<span class="ruby"><span class="symbol">quit:</span> 匹配成功便退出</span></div></pre></td></tr></table></figure>
<p>自定义操作：</p>
<p>-exec/-ok command {}; :command 为预执行命令(-ok会在每一次执行命令前询问用户)</p>
<p>touch filename: 设定或更新文件的修改时间，文件不存在时，会创建一个新文件(空文件)</p>
<p>stat filename: 显示文件的所有信息及属性</p>
<p>option选项：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"><span class="symbol">depth:</span> 引导find程序处理目录前先处理目录内的文件</span></div><div class="line">-<span class="ruby">maxdepth <span class="symbol">levels:</span> 当执行测试条件行为时，设置find程序陷入的目录数的最大级别数</span></div><div class="line">-<span class="ruby">mindepth <span class="symbol">levels:</span> 设置find程序陷入目录数的最小级别数</span></div><div class="line">-<span class="ruby"><span class="symbol">noleaf:</span> 指导find程序不要基于“正在搜索类UNIX文件系统”的假设来优化搜索，当扫描DOS/Windows文件系统和CD时，会用到该选项</span></div><div class="line">-<span class="ruby"><span class="symbol">mount:</span> 引导find程序不要遍历挂载在其他文件系统上的目录</span></div></pre></td></tr></table></figure>
<h3 id="Chapter-18-归档和备份"><a href="#Chapter-18-归档和备份" class="headerlink" title="Chapter 18 归档和备份"></a>Chapter 18 归档和备份</h3><p>gzip:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gzip <span class="string">filename:</span> 压缩文件</div><div class="line">gunzip filename.<span class="string">gz:</span> 解压缩文件</div></pre></td></tr></table></figure>
<p>gzip 命令的一些选项：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"><span class="symbol">c:</span> 将输出内容写到标准输出端口并且保持原有文件</span></div><div class="line">-<span class="ruby"><span class="symbol">d:</span> 解压缩，gzip -d == gunzip</span></div><div class="line">-<span class="ruby"><span class="symbol">f:</span> 强制压缩</span></div><div class="line">-<span class="ruby"><span class="symbol">h:</span> 显示有用信息，可用 --help 代替</span></div><div class="line">-<span class="ruby"><span class="symbol">l:</span> 列出所有压缩文件的压缩统计，也可以用 --list 代替</span></div><div class="line">-<span class="ruby"><span class="symbol">r:</span> 存在目录时，递归压缩 ==--recursive</span></div><div class="line">-<span class="ruby"><span class="symbol">t:</span> 检验压缩文件的完整性 ==--test</span></div><div class="line">-<span class="ruby"><span class="symbol">v:</span> 在压缩时显示详细信息，==--verbose</span></div><div class="line">-<span class="ruby"><span class="symbol">number:</span> 设置压缩级别，number是<span class="number">1</span>~<span class="number">9</span>的一个数，默认压缩级别是<span class="number">6</span></span></div></pre></td></tr></table></figure>
<p>bzip2/bunzip2: 与gzip命令类似，不过使用不同的压缩算法，该算法具有高质量的数据压缩能力，但降低了压缩速度。</p>
<p>tar: 归档文件</p>
<p>用法：tar mode pathname…</p>
<p>tar命令的操作模式：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">c:</span> 创建文件或目录的归档文件</div><div class="line"><span class="symbol">x:</span> 从归档文件中提取文件</div><div class="line"><span class="symbol">t:</span> 在归档文件末尾追加指定路径名</div><div class="line"><span class="symbol">r:</span> 列出归档文件的内容</div><div class="line"><span class="symbol">f:</span> 指定归档文件名</div><div class="line"><span class="symbol">v:</span> 获取详细信息</div></pre></td></tr></table></figure>
<p>example:</p>
<ul>
<li>tar cf/cvf file.tar file: 归档文件</li>
<li>tar xf/xvf file.tar file: 提取文件</li>
</ul>
<p>zip: 打包压缩文件</p>
<p>example: zip -r file.zip file</p>
<p>解压缩：unzip file.zip</p>
<p>rsync: 远程文件、目录的同步</p>
<h3 id="Chapter-19-正则表达式"><a href="#Chapter-19-正则表达式" class="headerlink" title="Chapter 19 正则表达式"></a>Chapter 19 正则表达式</h3><p>grep: 文本搜索，搜索文本文件中与指定正则表达式匹配的行，并送至标准输出</p>
<p>命令用法： grep mode searchfile，例如 grep -h ‘^int$’ test.c </p>
<p>grep 选项：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"><span class="symbol">i:</span> 忽略大小写</span></div><div class="line">-<span class="ruby"><span class="symbol">v:</span> 输出不匹配行</span></div><div class="line">-<span class="ruby"><span class="symbol">c:</span> 输出匹配项数目</span></div><div class="line">-<span class="ruby"><span class="symbol">l:</span> 输出匹配项文件名而不是直接输出匹配行</span></div><div class="line">-<span class="ruby"><span class="symbol">L:</span> 与-l类似，但输出不包含匹配项的文件名</span></div><div class="line">-<span class="ruby"><span class="symbol">n:</span> 在每个匹配行前面加上该行在文件中的行号</span></div><div class="line">-<span class="ruby"><span class="symbol">h:</span> 进行多文件搜索时，抑制文件名输出</span></div></pre></td></tr></table></figure>
<h4 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h4><p>详细内容可查看计算理论相关书籍。</p>
<p>元字符：^ $  . [ ] - ?  * + ( ) | \ </p>
<p>a/A~z/Z 为文字字符</p>
<p>注：在命令行中输入包含元字符的正则表达式时，应把元字符用引号括起来以避免不必要的shell 扩展。</p>
<h5 id="任意字符："><a href="#任意字符：" class="headerlink" title="任意字符："></a>任意字符：</h5><p>. : 匹配任意字符</p>
<p>example: ls /usr/bin/ | grep -h ‘.zip’</p>
<p>注意，上面输出中并不会包含zip，因为zip只包含三个字符，而这里至少要有四个字符。</p>
<h5 id="开头字符和末尾字符："><a href="#开头字符和末尾字符：" class="headerlink" title="开头字符和末尾字符："></a>开头字符和末尾字符：</h5><p>^ : 匹配开头字符</p>
<p>$ : 匹配末尾字符</p>
<p>example : ls /usr/bin | grep -h ‘^zip’ : 匹配以zip开头的输出</p>
<p>ls /usr/bin | grep -h ‘zip$’ : 匹配以zip结尾的输出</p>
<p>ls /usr/bin | grep -h ‘^zip$’ : 输出只有zip</p>
<h5 id="中括号表达式和字符类"><a href="#中括号表达式和字符类" class="headerlink" title="中括号表达式和字符类"></a>中括号表达式和字符类</h5><p>中括号除了可用于匹配正则表达式中的给定字符外，还可用于匹配字符集中的单个字符。借助中括号，也可指定要匹配的字符集，例如：ls /usr/bin | grep -h ‘[bg]zip’ 会输出以bzip和gzip开头的输出。</p>
<p>注：^在中括号中表示否定；-在中括号中表示字符范围。</p>
<h5 id="否定"><a href="#否定" class="headerlink" title="否定"></a>否定</h5><p>在中括号中使用 ^ ,表示剩余字符不应该出现，例如：</p>
<p><code>ls /usr/bin/ | grep -h &#39;[^bg]zip&#39;</code> 会得到包含zip但zip前面既不是b，又不是g的程序。</p>
<p>注：^ 只有在中括号中的第一个字符才会当作否定符，否则当作普通符号处理。</p>
<h5 id="字符范围"><a href="#字符范围" class="headerlink" title="字符范围"></a>字符范围</h5><p>使用 -</p>
<p>例：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">grep</span> -h <span class="string">'^[A-Z]'</span> filename :所有以大写字母开头的行</div><div class="line"><span class="keyword">grep</span> -h <span class="string">'^[A-Za-z0-9]'</span> filename :所有以字母和数字开头的行</div><div class="line"><span class="keyword">grep</span> -h <span class="string">'[-AZ]'</span> filename :仅表示包含连字符，大写字母A或Z的行</div></pre></td></tr></table></figure>
<h5 id="POSIX-字符集"><a href="#POSIX-字符集" class="headerlink" title="POSIX 字符集"></a>POSIX 字符集</h5><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="string">[:alnum:]</span>  字母字符和数字字母，在ASCII中，与<span class="string">[A-Za-z0-9]</span>等效</div><div class="line"><span class="string">[:word:]</span>   与上者相比，多了下划线字符_</div><div class="line"><span class="string">[:alpha:]</span>  字母字符，在ASCII中，等效于<span class="string">[A-Za-z]</span></div><div class="line"><span class="string">[:blank:]</span>  空字符，包括空格和制表符</div><div class="line"><span class="string">[:cntrl:]</span>  ASCII控制符，包括ASCII字符<span class="number">0</span>~<span class="number">31</span>以及<span class="number">127</span></div><div class="line"><span class="string">[:digit:]</span>  数字<span class="number">0</span>~<span class="number">9</span></div><div class="line"><span class="string">[:graph:]</span>  可见字符，在ASCII中，包括字符<span class="number">33</span>~<span class="number">126</span></div><div class="line"><span class="string">[:lower:]</span>  小写字母</div><div class="line"><span class="string">[:punct:]</span>  标点符号字符</div><div class="line"><span class="string">[:print:]</span>  可打印字符，包括<span class="string">[:graph:]</span>中的所有字符加上空格字符</div><div class="line"><span class="string">[:space:]</span>  空白字符包括空格符，制表符，回车符，换行符垂直制表符以及换页符，在ASCII中，等价于<span class="string">[\t\r\n\v\f]</span></div><div class="line"><span class="string">[:upper:]</span>  大写字母</div><div class="line"><span class="string">[:xdigit:]</span> 用于表示十六进制的字符 ==<span class="string">[0-9a-fA-F]</span></div></pre></td></tr></table></figure>
<p>例如：</p>
<p>ls /usr/sbin/[[:upper:]]* : 列出所有以大写字母开头的文件</p>
<h5 id="或选项："><a href="#或选项：" class="headerlink" title="或选项：|"></a>或选项：|</h5><p>例如：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">echo <span class="string">"AAA"</span> | <span class="type">grep</span> -E 'AAA|<span class="type">BBB</span>|<span class="type">CCC</span>'</div><div class="line">ls /usr/bin | <span class="type">grep</span> -Eh '^(bz|<span class="type">gz</span>|<span class="type">zip</span>)' 匹配以bz或gz或zip开头的程序</div></pre></td></tr></table></figure>
<h5 id="匹配某元素0次或1次："><a href="#匹配某元素0次或1次：" class="headerlink" title="匹配某元素0次或1次：?"></a>匹配某元素0次或1次：?</h5><p>? 置于字符的后面表示前面的字符（单个）匹配一次或零次</p>
<h5 id="匹配0次或多次："><a href="#匹配0次或多次：" class="headerlink" title="匹配0次或多次： *"></a>匹配0次或多次： *</h5><p>用法和上者类似。</p>
<h5 id="匹配一次或多次："><a href="#匹配一次或多次：" class="headerlink" title="匹配一次或多次： +"></a>匹配一次或多次： +</h5><p>用法和上者类似。</p>
<h5 id="以指定次数匹配："><a href="#以指定次数匹配：" class="headerlink" title="以指定次数匹配："></a>以指定次数匹配：</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;n&#125;   前面的元素恰好出现n次</div><div class="line">&#123;n,m&#125; 前面的元素出现的次数在n~m之间时匹配</div><div class="line">&#123;n,&#125;  前面的元素超过n次时匹配</div><div class="line">&#123;,m&#125;  前面的元素不超过m次时匹配</div></pre></td></tr></table></figure>
<p>locate 查找文件： </p>
<p>选项： </p>
<ul>
<li>–regexp    支持基本正则表达式</li>
<li>–regex      支持扩展正则表达式</li>
</ul>
<h5 id="less-和-Vim"><a href="#less-和-Vim" class="headerlink" title="less 和 Vim"></a>less 和 Vim</h5><p>二者皆支持正则表达式搜索，并且搜索方法相同：按下“/”键后，输入正则表达式，便可搜索。</p>
<h3 id="Chapter-20-文本处理"><a href="#Chapter-20-文本处理" class="headerlink" title="Chapter 20 文本处理"></a>Chapter 20 文本处理</h3><h5 id="cat-进行文件间的拼接并输出到标准输出"><a href="#cat-进行文件间的拼接并输出到标准输出" class="headerlink" title="cat : 进行文件间的拼接并输出到标准输出"></a>cat : 进行文件间的拼接并输出到标准输出</h5><p>选项：</p>
<ul>
<li>-A    : 输出非打印字符</li>
<li>-n    : 对行编号</li>
<li>-s     : 禁止输出多个空白行</li>
</ul>
<h5 id="sort-对文本进行排序"><a href="#sort-对文本进行排序" class="headerlink" title="sort : 对文本进行排序"></a>sort : 对文本进行排序</h5><p>sort 是一个排序程序，操作对象为标准输入或是命令行中指定的一个或多个文件，然后将结果送至标准输出。</p>
<p>example:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sort &gt; foo<span class="selector-class">.txt</span>   可在键盘输入然后sort排序后输入到 foo<span class="selector-class">.txt</span> 中（重定向）</div><div class="line">sort file1 file2 file3 &gt; file_sorted  将三个文件进行排序后输出到一个文件中</div></pre></td></tr></table></figure>
<p>sort 选项：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">b  忽略行开头的空格，默认情况下，会对整个行进行排序</span></div><div class="line">-<span class="ruby">f  排序时不区分大小写</span></div><div class="line">-<span class="ruby">n  基于字符串的长度进行排序而不是基于字母表顺序进行排序</span></div><div class="line">-<span class="ruby">r  逆序进行排序</span></div><div class="line">-<span class="ruby">m  将输入的多个参数当作已经排序好的。将多个文件合并为一个排序好的文件，而不执行额外的排序操作</span></div><div class="line">-<span class="ruby">o  将排序结果输出到文件而不是标准输出</span></div><div class="line">-<span class="ruby">t  定义字段分隔符，默认情况下是空格或制表符</span></div></pre></td></tr></table></figure>
<h5 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h5><p>给定一个排序好的文件或标准输入，unip会删除重复的行并将结果输出到标准输出中。</p>
<p>注意：uniq仅对排序好的文件有用，因为uniq只能移除相邻的重复行。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">c  输出重复行列表，并且在重复行的前面加上出现的次数</span></div><div class="line">-<span class="ruby">d  只输出重复行，不包括单独行</span></div><div class="line">-<span class="ruby">f n 忽略每行的前n个字段</span></div><div class="line">-<span class="ruby">i  行与行之间比较时忽略大小写</span></div><div class="line">-<span class="ruby">s n 忽略每行的前n个字符</span></div><div class="line">-<span class="ruby">u  仅输出不重复的行，该选项是默认的</span></div></pre></td></tr></table></figure>
<h5 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h5><p>从文本行中提取一段文字并输出至标准输出。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">c char_list   从文本行中提取char_list定义的内容，例，cut -c <span class="number">7</span>-<span class="number">10</span> 提取每行中的<span class="number">7</span>-<span class="number">10</span>个字符</span></div><div class="line">-<span class="ruby">f field_list  从文本行中提取field_list定义的一个或多个字段</span></div><div class="line">-<span class="ruby">d delim_char  使用-f选项后，可使用delim_char作为字段分隔符，默认时以Tab制表符隔开</span></div><div class="line">-<span class="ruby">-complemet  从文本中提取整行，除了那些-c和/或-f指定的部分</span></div></pre></td></tr></table></figure>
<h4 id="paste-合并文本行"><a href="#paste-合并文本行" class="headerlink" title="paste - 合并文本行"></a>paste - 合并文本行</h4><p>example:</p>
<p><code>paste file1.txt file2.txt</code>：将两个文件中的内容按行拼接起来</p>
<h4 id="join-连接两个文件中具有相同字段的行"><a href="#join-连接两个文件中具有相同字段的行" class="headerlink" title="join - 连接两个文件中具有相同字段的行"></a>join - 连接两个文件中具有相同字段的行</h4><p>example:</p>
<p><code>join file1.txt file2.txt</code></p>
<h4 id="comm-逐行比较两个已排序好的文件"><a href="#comm-逐行比较两个已排序好的文件" class="headerlink" title="comm - 逐行比较两个已排序好的文件"></a>comm - 逐行比较两个已排序好的文件</h4><p>详见<a href="http://ucasfl.me/2017/06/05/Linux-Command-of-comm/">另一篇博客 - Linux Command of comm</a></p>
<ul>
<li>diff - 逐行比较文件</li>
<li>patch - 对原文件进行 diff 操作</li>
<li>tr - 替换或删除字符</li>
<li>sed - 用于文本过滤和转换的流编辑器</li>
<li>aspell - 交互式拼写检查工具</li>
</ul>
<h3 id="Chapter-21-格式化输出"><a href="#Chapter-21-格式化输出" class="headerlink" title="Chapter 21 格式化输出"></a>Chapter 21 格式化输出</h3><h4 id="nl-对行进行标号"><a href="#nl-对行进行标号" class="headerlink" title="nl - 对行进行标号"></a>nl - 对行进行标号</h4><p>example :</p>
<p><code>nl file.txt</code> : 默认对非空行进行标号。</p>
<h4 id="fold-设定文本行长度"><a href="#fold-设定文本行长度" class="headerlink" title="fold - 设定文本行长度"></a>fold - 设定文本行长度</h4><p>example :</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fold -w <span class="number">15</span> file<span class="selector-class">.txt</span>  每行设置为<span class="number">15</span>个字符</div><div class="line">fold -w <span class="number">15</span> -s file<span class="selector-class">.txt</span> 使其断行时考虑单词边界</div></pre></td></tr></table></figure>
<ul>
<li>fmt - 简单的文本格式化工具</li>
<li>pr - 格式化打印文本</li>
<li>printf - 格式化并打印数据，与C语言中的printf类似。</li>
</ul>
<h3 id="Chapter-22-打印"><a href="#Chapter-22-打印" class="headerlink" title="Chapter 22 打印"></a>Chapter 22 打印</h3><ul>
<li>pr : 转换打印文本，从而进行打印操作</li>
<li>lpr: 打印文件</li>
<li>lp: 打印文件</li>
<li>a2ps: 格式化文件，以在PostScript打印机上打印</li>
<li>lpstat: 显示打印状态信息</li>
<li>lpq: 显示打印机队列状态</li>
<li>lprm: 取消打印任务</li>
<li>cancel: 取消打印任务</li>
</ul>
<h3 id="Chapter-23-编译程序"><a href="#Chapter-23-编译程序" class="headerlink" title="Chapter 23 编译程序"></a>Chapter 23 编译程序</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line"><span class="built_in">make</span></div><div class="line">sudo <span class="built_in">make</span> install</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Chapter-14-软件包管理&quot;&gt;&lt;a href=&quot;#Chapter-14-软件包管理&quot; class=&quot;headerlink&quot; title=&quot;Chapter 14 软件包管理&quot;&gt;&lt;/a&gt;Chapter 14 软件包管理&lt;/h3&gt;&lt;p&gt;低级软件包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Debian : dpkg/rpm&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dpkg –install file.deb/rpm -i package_file/rpm -U package_file：安装/升级软件&lt;/li&gt;
&lt;li&gt;dpkg –list ：列出所有已安装软件&lt;/li&gt;
&lt;li&gt;dpkg –status package_name：判断是否已安装&lt;/li&gt;
&lt;li&gt;dpkg –search filename/rpm -qf file_name：查询文件所属命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高级软件包：apt-get&lt;ul&gt;
&lt;li&gt;apt-get update ; apt-cache search file_name：搜索软件包&lt;/li&gt;
&lt;li&gt;apt-get update ; apt-get install package_name：安装软件包&lt;/li&gt;
&lt;li&gt;apt-get remove package_name/yum erase package_name：删除软件包，彻底删除干净，可加上 –purge 参数&lt;/li&gt;
&lt;li&gt;apt-get update ; apt-get upgrade ：更新/升级软件包&lt;/li&gt;
&lt;li&gt;apt-cache show packagename ：显示软件包相关信息&lt;/li&gt;
&lt;li&gt;apt-cache search package_name/yum search package_name：搜索软件包&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Command" scheme="http://ucasfl.me/categories/Command/"/>
    
    
      <category term="Reading-Summary" scheme="http://ucasfl.me/tags/Reading-Summary/"/>
    
  </entry>
  
  <entry>
    <title>C 语言中的静态变量</title>
    <link href="http://ucasfl.me/2017/06/19/The-Static-Variables-in-C/"/>
    <id>http://ucasfl.me/2017/06/19/The-Static-Variables-in-C/</id>
    <published>2017-06-19T09:17:44.000Z</published>
    <updated>2017-09-02T04:38:28.979Z</updated>
    
    <content type="html"><![CDATA[<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>静态变量的关键字为 <code>static</code> ，采用静态存储方式，一般的声明如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;<span class="comment">//a 为一个静态变量</span></div></pre></td></tr></table></figure>
<p>静态变量的一些特点：</p>
<ul>
<li><strong>静态局部变量在函数内定义，但不像自动变量那样，当调用时就存在，退出函数时就消失。静态局部变量始终存在着，也就是说它的生存期为整个源程序。</strong></li>
<li><strong>静态局部变量的生存期虽然为整个源程序，但是其作用域仍与自动变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</strong></li>
<li>允许对构造类静态局部量赋初值。若未赋以初值，则由系统自动赋值。数值型变量自动赋初值0，字符型变量赋空字符。</li>
<li>对基本类型的静态局部变量若在说明时未赋以初值，则系统自动赋予0值。而对自动变量不赋初值，则其值是不定的。 根据静态局部变量的特点， 可以看出它是一种生存期为整个源文件的量。<strong>虽然离开定义它的函数后不能使用，但如再次调用定义它的函数时，它又可继续使用， 而且保存了前次被调用后留下的值。</strong> 因此，当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。</li>
</ul>
<p>尽管如此，全局静态变量和局部静态变量还有一些区别。</p>
<a id="more"></a>
<h3 id="全局静态变量"><a href="#全局静态变量" class="headerlink" title="全局静态变量"></a>全局静态变量</h3><p>尽管全局静态变量的生命周期为整个源程序，<strong>但是，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。</strong></p>
<h3 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h3><p>在一些函数比如递归函数中，局部静态变量用处较大，比如在递归函数中。但是需要注意，每次在主函数中调用该函数时，局部静态变量都保存之前的值。此时，需要注意一个问题。</p>
<p><strong>如果在一个递归函数中，当递归调用时，需要静态变量保存之前的值，而每次在主函数中调用该递归函数，都需要将该静态变量赋一个固定的初值，那么可以多加一个参数来实现。</strong></p>
<p>下面是一个例子。通过中序遍历一个平衡二叉排序树来获取一个递增序列，将该序列存于一个数组中，并得到数组的最后一个元素下标。</p>
<p>第一种实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inorder</span><span class="params">(BiTree T, <span class="keyword">int</span> key[], <span class="keyword">int</span> *last)</span></span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span>(!T)</div><div class="line">	  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">if</span> (inorder(T-&gt;lchild, key, last, ++ restore))&#123;</div><div class="line">			key[i++] = T-&gt;data;<span class="comment">//get array list</span></div><div class="line">			<span class="keyword">if</span> (inorder(T-&gt;rchild, key, last, ++ restore))&#123;</div><div class="line">				*last = i - <span class="number">1</span>;<span class="comment">// get the length-1 of list</span></div><div class="line">				<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;<span class="comment">//inorder</span></div></pre></td></tr></table></figure>
<p><strong>如果在主函数中，该函数仅调用一次，那么像这样写没有任何问题。但是，如果主函数中多次调用了该递归函数，那么之后的调用 <code>i</code> 的初值遍不是 0 ，而这儿我们需要在是 0 ，当每次在主函数中调用时。</strong></p>
<p>我们可以通过添加一个参数来保证每次在主函数中调用该递归函数时，<code>i</code> 的初值均为 0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inorder</span><span class="params">(BiTree T, <span class="keyword">int</span> key[], <span class="keyword">int</span> *last, <span class="keyword">int</span> restore)</span></span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (!restore)</div><div class="line">	  i = <span class="number">0</span>;<span class="comment">//when everytime call the function in main function, restore i to zero</span></div><div class="line">	<span class="keyword">if</span>(!T)</div><div class="line">	  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">if</span> (inorder(T-&gt;lchild, key, last, ++ restore))&#123;</div><div class="line">			key[i++] = T-&gt;data;<span class="comment">//get array list</span></div><div class="line">			<span class="keyword">if</span> (inorder(T-&gt;rchild, key, last, ++ restore))&#123;</div><div class="line">				*last = i - <span class="number">1</span>;<span class="comment">// get the length-1 of list</span></div><div class="line">				<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;<span class="comment">//inorder</span></div></pre></td></tr></table></figure>
<p>如上面的代码所示，我们增加了一个新的参数 <code>restore</code>，每次在主函数中调用该函数时，<code>restore</code> 传入的值为 0 ，这样便可消除上面的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;静态变量&quot;&gt;&lt;a href=&quot;#静态变量&quot; class=&quot;headerlink&quot; title=&quot;静态变量&quot;&gt;&lt;/a&gt;静态变量&lt;/h3&gt;&lt;p&gt;静态变量的关键字为 &lt;code&gt;static&lt;/code&gt; ，采用静态存储方式，一般的声明如：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a;&lt;span class=&quot;comment&quot;&gt;//a 为一个静态变量&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;静态变量的一些特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态局部变量在函数内定义，但不像自动变量那样，当调用时就存在，退出函数时就消失。静态局部变量始终存在着，也就是说它的生存期为整个源程序。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态局部变量的生存期虽然为整个源程序，但是其作用域仍与自动变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;允许对构造类静态局部量赋初值。若未赋以初值，则由系统自动赋值。数值型变量自动赋初值0，字符型变量赋空字符。&lt;/li&gt;
&lt;li&gt;对基本类型的静态局部变量若在说明时未赋以初值，则系统自动赋予0值。而对自动变量不赋初值，则其值是不定的。 根据静态局部变量的特点， 可以看出它是一种生存期为整个源文件的量。&lt;strong&gt;虽然离开定义它的函数后不能使用，但如再次调用定义它的函数时，它又可继续使用， 而且保存了前次被调用后留下的值。&lt;/strong&gt; 因此，当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管如此，全局静态变量和局部静态变量还有一些区别。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://ucasfl.me/categories/C-C/"/>
    
    
      <category term="Static-variables" scheme="http://ucasfl.me/tags/Static-variables/"/>
    
  </entry>
  
  <entry>
    <title>递归实现平衡二叉树的插入、删除、合并和分裂</title>
    <link href="http://ucasfl.me/2017/06/19/Using-Recursive-Method-to-Finish-the-Join-Split-of-AVL-Tree/"/>
    <id>http://ucasfl.me/2017/06/19/Using-Recursive-Method-to-Finish-the-Join-Split-of-AVL-Tree/</id>
    <published>2017-06-19T08:39:12.000Z</published>
    <updated>2017-09-02T04:38:29.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树是这样一棵树，要么是一棵空树，要么是满足下面条件的树：</p>
<ul>
<li>左子树和右子树的深度的绝对值只差不超过 1;</li>
<li>左子树和右子树也是平衡二叉树。</li>
</ul>
<p>既是二茬排序树又是平衡二叉树的树为平衡二茬排序树。下面说到的平衡二叉树表示平衡二茬排序树。</p>
<p>在平衡二叉树的结构定义中，比二叉树多了一个平衡因子。实现平衡二叉树的插入和删除是一件比较头疼的事情。因为每次插入或删除之后都要检查平衡是否被破坏，如果被破坏，则要进行各种左旋、右旋的平衡化。</p>
<a id="more"></a>
<p>除了插入和删除，有的时候还会涉及到将两个平衡二叉树或多个合并成一个平衡二叉树。或者将一个平衡二叉树分裂为两个平衡二叉树，其中一个中的值均小于等于 $x$，另一个的值均大于 $x$ 。对于合并，最常规的方法自然是，将其中一个二叉树中的点一个个插入到另一个平衡二叉树中。然而，这样做的时间复杂度很大，而且其中一棵二叉树被破坏。但是，如果通过递归来做，则可以在不破坏两棵树的前提下创建一棵新的平衡二叉树，并且时间复杂度比前者要优越很多。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>下面说一下该算法：</p>
<ol>
<li>分别中序遍历两棵二叉树，得到两个有序序列。</li>
<li>将两个有序序列合并为一个有序序列。</li>
<li>利用该有序序列来创建一棵新的平衡二叉树。</li>
</ol>
<p>递归部分：</p>
<p>终止条件：</p>
<ul>
<li>序列中只剩下一个或两个记录，一个时，直接建节点，插入记录；两个时，可建节点，将前者插入，然后再后一个作为前者的右孩子插入。</li>
</ul>
<p>递归：</p>
<ul>
<li>当序列数大于二时，首先建立节点，将序列最中间的记录插入，然后递归，将中间节点之前的记录作为左孩子插入，中间节点后面的记录作为右孩子插入。</li>
</ul>
<p>通过该算法构造出的二叉树一定为平衡二茬排序树：</p>
<ul>
<li>每次递归保证了左边的点小于根节点，右边的点大于根节点，因此为排序树。</li>
<li>递归过程中保证了左右孩子的数目相等或相差一个，这样保证了左右孩子的深度绝对值只差不会超过 1 。</li>
</ul>
<p>利用这一个思路，也可进行分裂、插入和删除：</p>
<ul>
<li>分裂：中序遍历平衡二叉树得到序列，定位出 $x$ 的位置，利用递归算法和 $x$ 以及之前的序列可构造出一棵二叉树，之后的序列同样构造出一棵二叉树。</li>
<li>插入：先中序遍历得到序列，将需插入的值插入序列，然后再建树，只是这样相当于重新创建一棵二叉树。</li>
<li>删除：和插入一样。</li>
</ul>
<h3 id="C-语言实现："><a href="#C-语言实现：" class="headerlink" title="C 语言实现："></a>C 语言实现：</h3><p>下面是合并和分裂的 C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAX 200</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BiTreeNode&#123;</div><div class="line">	<span class="keyword">int</span> number;</div><div class="line">	<span class="keyword">int</span> data;</div><div class="line">	<span class="keyword">struct</span> BiTreeNode *lchild;</div><div class="line">	<span class="keyword">struct</span> BiTreeNode *rchild;</div><div class="line">&#125;BiTreeNode, *BiTree;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(BiTree *T, <span class="keyword">int</span> key[], <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>; <span class="comment">//use a sorted array key[] to create a balanced tree</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(BiTree T, BiTree *T1, BiTree *T2, <span class="keyword">int</span> x)</span></span>; <span class="comment">//split a balanced tree into two balanced tree</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inorder</span><span class="params">(BiTree T, <span class="keyword">int</span> key[], <span class="keyword">int</span> *last, <span class="keyword">int</span> restore)</span></span>; <span class="comment">//inorder traverse a balanced tree to get the record list</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">preorder</span><span class="params">(BiTree T)</span></span>; <span class="comment">//preorder traverse a tree</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_index_x</span><span class="params">(<span class="keyword">int</span> key[], <span class="keyword">int</span> last, <span class="keyword">int</span> x, <span class="keyword">int</span> *index_x)</span></span>; <span class="comment">//get the index of x in array key</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_array</span><span class="params">(<span class="keyword">int</span> key[], <span class="keyword">int</span> key1[], <span class="keyword">int</span> key2[], <span class="keyword">int</span> len1, <span class="keyword">int</span> len2, <span class="keyword">int</span> *last)</span></span>; <span class="comment">//merge two sorted array into one sorted array</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_tree</span><span class="params">(BiTree *T, BiTree T1, BiTree T2)</span></span>;  <span class="comment">//merge two balanced tree into one balanced tree</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_tree</span><span class="params">(BiTree *T, BiTree T1, BiTree T2)</span></span>&#123; </div><div class="line">	<span class="keyword">int</span> key[MMAX], key1[MAX], key2[MAX];</div><div class="line">	<span class="keyword">int</span> len1, len2, last;</div><div class="line">    <span class="comment">//get lists</span></div><div class="line">	inorder(T1, key1, &amp;len1, <span class="number">0</span>);</div><div class="line">	inorder(T2, key2, &amp;len2, <span class="number">0</span>);</div><div class="line">   <span class="comment">//merge lists</span></div><div class="line">	merge_array(key, key1, key2, len1, len2, &amp;last);</div><div class="line">	join(T, key, <span class="number">0</span>, last); <span class="comment">//create tree</span></div><div class="line">&#125;<span class="comment">//merge_tree</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_array</span><span class="params">(<span class="keyword">int</span> key[], <span class="keyword">int</span> key1[], <span class="keyword">int</span> key2[], <span class="keyword">int</span> len1, <span class="keyword">int</span> len2, <span class="keyword">int</span> *last)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> i, j, k ;</div><div class="line">	key[<span class="number">0</span>] = (key1[<span class="number">0</span>] &lt; key2[<span class="number">0</span>])?key1[<span class="number">0</span>]:key2[<span class="number">0</span>];<span class="comment">//get the first value </span></div><div class="line">	</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">1</span>; i &lt;= len1 &amp;&amp; j &lt;= len2; )&#123; <span class="comment">//merge lists</span></div><div class="line">		<span class="keyword">if</span> (key1[i] &lt; key2[j] )&#123;</div><div class="line">			<span class="keyword">if</span> (key1[i] != key[k<span class="number">-1</span>])</div><div class="line">			  key[k++] = key1[i++];</div><div class="line">			<span class="keyword">else</span></div><div class="line">			  i ++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">if</span> (key2[j] != key[k<span class="number">-1</span>])</div><div class="line">			  key[k++] = key2[j++];</div><div class="line">			<span class="keyword">else</span></div><div class="line">			  j ++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (i &lt;= len1)&#123;  <span class="comment">//merge remain record of key1[]</span></div><div class="line">		<span class="keyword">while</span> ( i &lt;= len1 ) &#123;</div><div class="line">			key[k++] = key1[i++];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(j &lt;= len2 )&#123; <span class="comment">//merge remain record of key2[]</span></div><div class="line">		<span class="keyword">while</span> ( j &lt;= len2 ) &#123;</div><div class="line">			key[k++] = key2[j++];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> ;</div><div class="line">	*last = k - <span class="number">1</span>; <span class="comment">//get lenth-1</span></div><div class="line">&#125;<span class="comment">//merge_array</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(BiTree *T, <span class="keyword">int</span> key[], <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123; <span class="comment">//create balanced tree using sorted array</span></div><div class="line">	<span class="keyword">if</span>(first == last)&#123;<span class="comment">//left one record</span></div><div class="line">		*T = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTreeNode));</div><div class="line">		(*T)-&gt;data = key[first];</div><div class="line">		(*T)-&gt;lchild = (*T)-&gt;rchild = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(first == last - <span class="number">1</span>)&#123;<span class="comment">//left two record</span></div><div class="line">		*T = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTreeNode));</div><div class="line">		(*T)-&gt;data = key[first];</div><div class="line">		(*T)-&gt;rchild = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTreeNode));</div><div class="line">		(*T)-&gt;rchild-&gt;data = key[last];</div><div class="line">		(*T)-&gt;lchild = (*T)-&gt;rchild-&gt;lchild = (*T)-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123; <span class="comment">//insert middle record</span></div><div class="line">		<span class="keyword">int</span> middle = (first + last) / <span class="number">2</span>;</div><div class="line">		*T = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTreeNode));</div><div class="line">		(*T)-&gt;data = key[middle];</div><div class="line">		<span class="comment">//recursive call the join function</span></div><div class="line">		join(&amp;((*T)-&gt;lchild), key, first, middle - <span class="number">1</span>);</div><div class="line">		join(&amp;((*T)-&gt;rchild), key, middle + <span class="number">1</span>, last);</div><div class="line">	&#125;</div><div class="line">&#125; <span class="comment">//join</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(BiTree T, BiTree *T1, BiTree *T2, <span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//split one balanced tree T into two balanced tree T1 and T2</span></div><div class="line">	<span class="keyword">int</span> key[MAX];</div><div class="line">	<span class="keyword">int</span> last, index_x;</div><div class="line">	inorder(T, key, &amp;last, <span class="number">0</span>);<span class="comment">//get sorted list array</span></div><div class="line">	<span class="keyword">int</span> get_x = get_index_x(key, last, x, &amp;index_x);<span class="comment">//get the index of x in array key</span></div><div class="line">	<span class="keyword">if</span> (get_x)&#123;</div><div class="line">		<span class="comment">//call join funcion to create balanced tree</span></div><div class="line">		join(T1, key, <span class="number">0</span>, index_x);</div><div class="line">		join(T2, key, index_x + <span class="number">1</span>, last);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123; <span class="comment">//all record &gt; x or &lt;= x, don't need split;</span></div><div class="line">		*T1 = T;</div><div class="line">		*T2 = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">&#125; <span class="comment">//split</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_index_x</span><span class="params">(<span class="keyword">int</span> key[], <span class="keyword">int</span> last, <span class="keyword">int</span> x, <span class="keyword">int</span> *index_x)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> i, j;</div><div class="line">	<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= last; i++ ) &#123;</div><div class="line">		j = i + <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>( key[i] &lt;= x &amp;&amp; key[j] &gt; x &amp;&amp;  j &lt;= last )&#123;</div><div class="line">			*index_x = i;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;<span class="comment">//get_index</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inorder</span><span class="params">(BiTree T, <span class="keyword">int</span> key[], <span class="keyword">int</span> *last, <span class="keyword">int</span> restore)</span></span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (!restore)</div><div class="line">	  i = <span class="number">0</span>;<span class="comment">//when everytime call the function in main function, restore i to zero</span></div><div class="line">	<span class="keyword">if</span>(!T)</div><div class="line">	  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">if</span> (inorder(T-&gt;lchild, key, last, ++ restore))&#123;</div><div class="line">			key[i++] = T-&gt;data;<span class="comment">//get array list</span></div><div class="line">			<span class="keyword">if</span> (inorder(T-&gt;rchild, key, last, ++ restore))&#123;</div><div class="line">				*last = i - <span class="number">1</span>;<span class="comment">// get the length-1 of list</span></div><div class="line">				<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;<span class="comment">//inorder</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">preorder</span><span class="params">(BiTree T)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(!T)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		<span class="built_in">printf</span>( <span class="string">"%d  "</span>, T-&gt;data );</div><div class="line">		<span class="keyword">if</span>(preorder(T-&gt;lchild))</div><div class="line">		  <span class="keyword">if</span>(preorder(T-&gt;rchild))</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;<span class="comment">//preorder</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> key[<span class="number">16</span>];</div><div class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; i++ ) &#123;</div><div class="line">		key[i<span class="number">-1</span>] = <span class="number">4</span>*i - <span class="number">3</span>;</div><div class="line">	&#125;</div><div class="line">	BiTree T;</div><div class="line">	join(&amp;T, key, <span class="number">0</span>, <span class="number">15</span>);</div><div class="line">	preorder(T);</div><div class="line">	<span class="built_in">printf</span>( <span class="string">"\n\n"</span> );</div><div class="line"></div><div class="line">	<span class="keyword">int</span> num[<span class="number">40</span>];</div><div class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++ ) &#123;</div><div class="line">		num[i] = <span class="number">2</span>*i + <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	BiTree T0, T1, T2;</div><div class="line">	</div><div class="line">	join(&amp;T0, num, <span class="number">0</span>, <span class="number">39</span>);</div><div class="line">	preorder(T0);</div><div class="line">	<span class="built_in">printf</span>( <span class="string">"\n\n"</span> );</div><div class="line">	</div><div class="line">	<span class="keyword">int</span> x;</div><div class="line">	<span class="built_in">printf</span>( <span class="string">"Input x: "</span> );</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</div><div class="line">	split(T0, &amp;T1, &amp;T2, x);</div><div class="line">	preorder(T1);</div><div class="line">	<span class="built_in">printf</span>( <span class="string">"\n"</span> );</div><div class="line">	preorder(T2);</div><div class="line">	<span class="built_in">printf</span>( <span class="string">"\n\n"</span> );</div><div class="line"></div><div class="line">	<span class="keyword">int</span> key1[<span class="number">10</span>], key2[<span class="number">20</span>];</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)</div><div class="line">	  key1[i] = <span class="number">3</span>*i;</div><div class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ ) &#123;</div><div class="line">		key2[i] = <span class="number">2</span>*i;</div><div class="line">	&#125;</div><div class="line">	BiTree t, t1, t2;</div><div class="line">	join(&amp;t1, key1, <span class="number">0</span>, <span class="number">9</span>);</div><div class="line">	preorder(t1);</div><div class="line">	<span class="built_in">printf</span>( <span class="string">"\n"</span> );</div><div class="line">	join(&amp;t2, key2, <span class="number">0</span>, <span class="number">19</span>);</div><div class="line">	preorder(t2);</div><div class="line">	<span class="built_in">printf</span>( <span class="string">"\n\n"</span> );</div><div class="line">	merge_tree(&amp;t, t1, t2);</div><div class="line">	preorder(t);</div><div class="line">	<span class="built_in">printf</span>( <span class="string">"\n"</span> );</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;平衡二叉树&quot;&gt;&lt;a href=&quot;#平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树&quot;&gt;&lt;/a&gt;平衡二叉树&lt;/h3&gt;&lt;p&gt;平衡二叉树是这样一棵树，要么是一棵空树，要么是满足下面条件的树：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左子树和右子树的深度的绝对值只差不超过 1;&lt;/li&gt;
&lt;li&gt;左子树和右子树也是平衡二叉树。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既是二茬排序树又是平衡二叉树的树为平衡二茬排序树。下面说到的平衡二叉树表示平衡二茬排序树。&lt;/p&gt;
&lt;p&gt;在平衡二叉树的结构定义中，比二叉树多了一个平衡因子。实现平衡二叉树的插入和删除是一件比较头疼的事情。因为每次插入或删除之后都要检查平衡是否被破坏，如果被破坏，则要进行各种左旋、右旋的平衡化。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://ucasfl.me/categories/Algorithms/"/>
    
    
      <category term="AVL-Tree" scheme="http://ucasfl.me/tags/AVL-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的命名冲突</title>
    <link href="http://ucasfl.me/2017/06/18/Name-Conflict-in-Python/"/>
    <id>http://ucasfl.me/2017/06/18/Name-Conflict-in-Python/</id>
    <published>2017-06-18T13:40:57.000Z</published>
    <updated>2017-09-02T04:38:28.959Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天中午正在吃饭，一位外校的学妹突然发微信问关于 <code>Python</code> 的编程题，其实很简单，但中间却出了一些意料不到的差错。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>学妹问的其中一个题是利用 <code>random</code> 函数连续取 100 个随机数，统计其中小于 0.2 的随机数个数。这题很简单，毕竟该学妹并不是计算机系的，所以不会也算正常吧。</p>
<p>我们知道，<code>random</code> 函数是 Python 内建的 <code>random</code> 模块中的一个函数，可直接调用该模块来用。它能够产生区间 0~1 之间的随机数。</p>
<p>下面是我写的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/home/fenglv/FILE/anaconda2/bin/python</span></div><div class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">less</span><span class="params">()</span>:</span></div><div class="line">    num = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</div><div class="line">        value = rd.random()</div><div class="line">        <span class="keyword">if</span> value &lt; <span class="number">0.2</span>:</div><div class="line">            num += <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> num</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">print</span> less()</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>无论怎么看，这个代码都是没问题的。因为它的确是对的，但是，当我运行的时候，却出错了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;random.py&quot;, line 11, in &lt;module&gt;</div><div class="line">    print less()</div><div class="line">  File &quot;random.py&quot;, line 6, in less</div><div class="line">    value = rd.random()</div><div class="line">AttributeError: &apos;module&apos; object has no attribute &apos;random&apos;</div></pre></td></tr></table></figure>
<p>WTF？于是我在 Python 提示符下一行一行的运行代码，发现却是对的？</p>
<p>后来上网查，在 <code>stackoverflow</code> 上看到了答案。其实过去也注意过，只是这次却不小心忽略了。</p>
<p><strong>在 Python，每一个脚本就是一个模块，模块名就是脚本名。</strong></p>
<p>而我把这个文件命名为了 <code>random.py</code> ，于是便和内建的 <code>random</code> 模块冲突了，所以才导致错误的出现。</p>
<p>所以，无论如何，一定切记不要把脚本名命名了和内建模块名相同，特别是你还在该脚本中调用这一模块时。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天中午正在吃饭，一位外校的学妹突然发微信问关于 &lt;code&gt;Python&lt;/code&gt; 的编程题，其实很简单，但中间却出了一些意料不到的差错。&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h3&gt;&lt;p&gt;学妹问的其中一个题是利用 &lt;code&gt;random&lt;/code&gt; 函数连续取 100 个随机数，统计其中小于 0.2 的随机数个数。这题很简单，毕竟该学妹并不是计算机系的，所以不会也算正常吧。&lt;/p&gt;
&lt;p&gt;我们知道，&lt;code&gt;random&lt;/code&gt; 函数是 Python 内建的 &lt;code&gt;random&lt;/code&gt; 模块中的一个函数，可直接调用该模块来用。它能够产生区间 0~1 之间的随机数。&lt;/p&gt;
&lt;p&gt;下面是我写的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#!/home/fenglv/FILE/anaconda2/bin/python&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; random &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; rd&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;less&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    num = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        value = rd.random()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; value &amp;lt; &lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            num += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&#39;__main__&#39;&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; less()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://ucasfl.me/categories/Python/"/>
    
    
      <category term="Python/name" scheme="http://ucasfl.me/tags/Python-name/"/>
    
  </entry>
  
  <entry>
    <title>No Zuo, No Die</title>
    <link href="http://ucasfl.me/2017/06/17/no-zuo-no-die/"/>
    <id>http://ucasfl.me/2017/06/17/no-zuo-no-die/</id>
    <published>2017-06-17T13:45:34.000Z</published>
    <updated>2017-09-02T04:38:28.975Z</updated>
    
    <content type="html"><![CDATA[<p>历经千辛万苦，博客终于又回来了……</p>
<p>一周前，智障的我一不小心把 Linux 内核给删了。然后又智障的重启，想看看会发生什么。</p>
<p>正所谓吃一堑，长一智，大概这辈子都不会再犯这样的傻了。</p>
<p>笔芯 ^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;历经千辛万苦，博客终于又回来了……&lt;/p&gt;
&lt;p&gt;一周前，智障的我一不小心把 Linux 内核给删了。然后又智障的重启，想看看会发生什么。&lt;/p&gt;
&lt;p&gt;正所谓吃一堑，长一智，大概这辈子都不会再犯这样的傻了。&lt;/p&gt;
&lt;p&gt;笔芯 ^_^&lt;/p&gt;

    
    </summary>
    
      <category term="Essay" scheme="http://ucasfl.me/categories/Essay/"/>
    
    
  </entry>
  
  <entry>
    <title>D 编程语言是用于开发的绝佳语言的 5 个理由</title>
    <link href="http://ucasfl.me/2017/06/15/5-Reasons-of-D-Language-is-Good-for-Developments/"/>
    <id>http://ucasfl.me/2017/06/15/5-Reasons-of-D-Language-is-Good-for-Developments/</id>
    <published>2017-06-15T10:45:38.000Z</published>
    <updated>2017-09-02T04:38:29.067Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>D 语言的模块化、开发效率、可读性以及其它一些特性使其非常适合用于协同软件的开发。</p>
</blockquote>
<p><img src="https://opensource.com/sites/default/files/styles/image-full-size/public/images/life/code_development_programming.png?itok=eYK4UXiq" alt="Why the D programming language is great for open source development" title="Why the D programming language is great for open source development"></p>
<p><a href="https://dlang.org/" target="_blank" rel="external">D 编程语言</a>是一种静态类型的通用编程语言，它具有和 C 语言类似的语法，能够编译为本地代码。许多理由使得它很适合用于开源软件开发，下面讲到的是其中一些理由。</p>
<h3 id="模块化能力"><a href="#模块化能力" class="headerlink" title="模块化能力"></a>模块化能力</h3><p>在大多数情况下，当你有一个好的想法，你可以完全按照你的内心所想的方式通过代码来实现它。然而，有的时候，你不得让你的想法向代码妥协，而不是通过模块化代码来适应想法。D 语言支持多种<a href="https://en.wikipedia.org/wiki/Programming_paradigm" target="_blank" rel="external">编程范式</a>，包括函数式风格、命令式、面向对象、元编程、并发（演员模式），这些全都和谐共存。你可以选择任何一种方便的编程范式来将你的想法转换为代码。</p>
<p>通过使用<a href="http://ddili.org/ders/d.en/templates.html" target="_blank" rel="external">模板</a>，可以生成额外的 D 代码并在编译的过程中把它编排进去，你可以把这些代码描述成编译器生成代码的一种模式。这是一种非常有用的设计算法，无需把它们绑定到任何特定的类型。由于模版的通用性，就很容易生成平台无关的代码。通过将模板与<a href="https://dlang.org/spec/version.html" target="_blank" rel="external">条件编译</a>结合，跨平台的应用变得更加容易实现，也更容易接受来自使用不同操作系统的开发者的贡献。有了这一点，一个程序员可以通过很少的代码，利用有限的时间实现很多东西。</p>
<p><a href="http://ddili.org/ders/d.en/ranges.html" target="_blank" rel="external">range</a> 已经深度集成到了 D 语言中，相对于具体实现，它抽象出容器元素（比如数组、关联数组和链表等）是如何访问的。这个抽象使得可以在许多容器类型中设计和使用大量的算法，而无需绑定到特定的数据结构。D 的<a href="https://dlang.org/spec/arrays.html#slicing" target="_blank" rel="external">数组切片</a>是 range 的一个实现。最终，你可以用很少的时间写很少的代码，并且只需要很低的维护成本。<br><a id="more"></a></p>
<h3 id="开发效率"><a href="#开发效率" class="headerlink" title="开发效率"></a>开发效率</h3><p>大多数开源软件的代码贡献者都是基于有限的时间志愿工作的。 D 语言能够极大的提高开发效率，因为你可以用更少的时间完成更多的事情。D 的模板和 range 使得程序员在开发通用代码和可复用代码时效率更高，但这些仅仅是 D 开发效率高的其中几个优势。另外一个主要的吸引力是， D 的编译速度看起来感觉就像解释型语言一样，比如 Python、JavaScript、Ruby 和 PHP，它使得 D 能够快速成型。</p>
<p>D 可以很容易的与旧的代码进行对接，减少了移植的需要。它的设计目的是<a href="https://dlang.org/spec/interfaceToC.html" target="_blank" rel="external">与 C 代码进行自然地对接</a>，毕竟， C 语言大量用在遗留代码、精心编写而测试过的代码、库以及低级系统调用（特别是 Linux 系统）上。C++ 代码在<a href="https://dlang.org/spec/cpp_interface.html" target="_blank" rel="external"> D 中也是可调用的</a>，从而进行更大的扩展。事实上，<a href="https://code.dlang.org/packages/pyd" target="_blank" rel="external">Python</a>、<a href="https://dlang.org/spec/objc_interface.html" target="_blank" rel="external">Objective-C</a>、<a href="http://beza1e1.tuxen.de/into_luad.html" target="_blank" rel="external">Lua</a> 和 <a href="http://www.active-analytics.com/blog/interface-d-with-c-fortran/" target="_blank" rel="external">Fortran</a> 这些语言在技术层面上都是可以在 D 中使用的，有许多第三方正在努力在把 D 语言推向这些领域。这使得大量的开源库在 D 中均可使用，这符合开源软件开发的惯例。</p>
<h3 id="可读性和可维护性"><a href="#可读性和可维护性" class="headerlink" title="可读性和可维护性"></a>可读性和可维护性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="built_in">std</span>.stdio; <span class="comment">// 导入标准输入/输出模块</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    writeln(<span class="string">"Hello, World!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>D 语言的 Hello, World 演示</em></p>
<p>对于熟悉 C 语言的人来说， D 代码很容易理解。另外， D 代码的可读性很强，即使是复杂的代码。这使得很容易发现错误。可读性对于吸引贡献者来说也是很重要的，这是开源软件成长的关键。</p>
<p>在 D 中一个非常简单但很有用的<a href="https://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="external">语法糖</a>是支持使用下滑线分隔数字，这使得数字的可读性更高。这在数学上很有用：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int count = <span class="number">100</span>_000_000;</div><div class="line">double price = <span class="number">20</span>_220<span class="number">.00</span> + <span class="number">10.00</span>;</div><div class="line">int number = <span class="number">0x7FFF</span>_FFFF; <span class="comment">// 16 进制系统</span></div></pre></td></tr></table></figure>
<p><a href="https://dlang.org/spec/ddoc.html" target="_blank" rel="external">ddoc</a> 是一个内建的工具，它能够很容易的自动根据代码注释生成文档，而不需要使用额外的工具。文档写作、改进和更新变得更加简单，不具挑战性，因为它伴随代码同时生成。</p>
<p><a href="http://ddili.org/ders/d.en/contracts.html" target="_blank" rel="external">Contract</a> 能够检查代码的实现，从而确保 D 代码的行为能够像期望的那样。就像法律契约的签订是为了确保每一方在协议中做自己该做的事情，在 D 语言中的契约式编程，能够确保实现的每一个函数、类等如期望的那样产生预期的结果和行为。这样一个特性对于错误检查非常实用，特别是在开源软件中，当多个人合作一个项目的时候。契约是大项目的救星。D 语言强大的契约式编程特性是内建的，而不是后期添加的。契约不仅使得使用 D 语言更加方便，也减少了正确写作和维护困难的头痛。</p>
<h3 id="方便"><a href="#方便" class="headerlink" title="方便"></a>方便</h3><p>协同开发是具有挑战性的，因为代码经常发生变化，并且有许多移动部分。D 语言通过支持在本地范围内导入模块，从而缓解了那些问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回偶数</span></div><div class="line"><span class="keyword">int</span>[] evenNumbers(<span class="keyword">int</span>[] numbers)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// "filter" and "array" are only accessible locally</span></div><div class="line">    <span class="keyword">import</span> <span class="built_in">std</span>.algorithm: filter; </div><div class="line">    <span class="keyword">import</span> <span class="built_in">std</span>.<span class="built_in">array</span>: <span class="built_in">array</span>;</div><div class="line">    <span class="keyword">return</span> numbers.filter!(n =&gt; n%<span class="number">2</span> == <span class="number">0</span>).<span class="built_in">array</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>对 filter 使用 <code>!</code> 运算符是<a href="http://ddili.org/ders/d.en/templates.html" target="_blank" rel="external">模板参数</a>的一个语法</em></p>
<p>上面的函数可以在不破坏代码的情况下调用，因为它不依赖任何全局导入模块。像这样实现的函数都可以在后期无需破坏代码的情况下增强，这是协同开发的好东西。</p>
<p><a href="http://ddili.org/ders/d.en/ufcs.html" target="_blank" rel="external">通用函数调用语法（UFCS）</a>是 D 语言中的一个语法糖，它允许像调用一个对象的成员函数那样调用常规函数。一个函数的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cook</span><span class="params">(<span class="built_in">string</span> food, <span class="keyword">int</span> quantity)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">import</span> <span class="built_in">std</span>.stdio: writeln;</div><div class="line">    writeln(food, <span class="string">" in quantity of "</span>, quantity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它能够以通常的方式调用：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string food = <span class="string">"rice"</span><span class="comment">;</span></div><div class="line">int quantity = <span class="number">3</span><span class="comment">;</span></div><div class="line"></div><div class="line">cook(food, quantity)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>通过 UFCS，这个函数也可以像下面这样调用，看起来好像 <code>cook</code> 是一个成员函数：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string food = <span class="string">"rice"</span><span class="comment">;</span></div><div class="line">int quantity = <span class="number">3</span><span class="comment">;</span></div><div class="line"></div><div class="line">food.cook(quantity)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>在编译过程中，编译器会自动把 <code>food</code> 作为 <code>cook</code> 函数的第一个参数。UFCS 使得它能够链起来常规函数，给你的代码产生一种函数风格编程的自然感觉。UFCS 在 D 语言中被大量使用，就像在上面的 <code>evenNumbers</code> 函数中使用的 <code>filter</code> 和 <code>array</code> 函数那样。结合模板、range、条件编译和 UFCS 能够在不牺牲方便性的前提下给予你强大的力量。</p>
<p><code>auto</code> 关键词可以用来代替任何类型。编译器在编译过程中会静态推断类型。这样可以省去输入很长的类型名字，让你感觉写 D 代码就像是在写动态类型语言。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// <span class="type">Nope</span>. <span class="type">Do</span> you?</div><div class="line"><span class="type">VeryLongTypeHere</span> variable = new <span class="type">VeryLongTypeHere</span>(); </div><div class="line"></div><div class="line">// 使用 <span class="built_in">auto</span> 关键词</div><div class="line"><span class="built_in">auto</span> variable =  new <span class="type">VeryLongTypeHere</span>();</div><div class="line"><span class="built_in">auto</span> name = <span class="string">"John Doe"</span>;</div><div class="line"><span class="built_in">auto</span> age = <span class="number">12</span>;</div><div class="line"><span class="built_in">auto</span> letter  = 'e';</div><div class="line"><span class="built_in">auto</span> anArray = [<span class="number">1</span>, <span class="number">2</span>.<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>.<span class="number">5</span>]; // <span class="keyword">type</span> <span class="keyword">of</span> double[]</div><div class="line"><span class="built_in">auto</span> dictionary = [<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>, <span class="string">"three"</span>: <span class="number">3</span>]; // <span class="keyword">type</span> <span class="keyword">of</span> <span class="built_in">int</span>[<span class="built_in">string</span>]</div><div class="line"><span class="built_in">auto</span> cook(<span class="built_in">string</span> food) <span class="meta">&#123;...&#125;</span> // <span class="built_in">auto</span> <span class="keyword">for</span> a function <span class="keyword">return</span> <span class="keyword">type</span></div></pre></td></tr></table></figure>
<p>D 的<a href="http://ddili.org/ders/d.en/foreach.html" target="_blank" rel="external">foreach</a> 循环允许遍历各种不同的底层数据类型的集合和 range：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">foreach(name; [<span class="string">"John"</span>, <span class="string">"Yaw"</span>, <span class="string">"Paul"</span>, <span class="string">"Kofi"</span>, <span class="string">"Ama"</span>])</div><div class="line">&#123;</div><div class="line">    writeln(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foreach(number; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>]) <span class="meta">&#123;...&#125;</span></div><div class="line"></div><div class="line">foreach(number; <span class="number">0</span>..<span class="number">10</span>) <span class="meta">&#123;...&#125;</span> // <span class="number">0</span>..<span class="number">10</span> <span class="keyword">is</span> the syntax <span class="keyword">for</span> number <span class="built_in">range</span></div><div class="line"></div><div class="line">class <span class="type">Student</span> <span class="meta">&#123;...&#125;</span></div><div class="line"><span class="type">Student</span>[] students = [new <span class="type">Student</span>(), new <span class="type">Student</span>()];</div><div class="line">foreach(student; students) <span class="meta">&#123;...&#125;</span></div></pre></td></tr></table></figure>
<p>D 语言中内建的<a href="https://dlang.org/spec/unittest.html" target="_blank" rel="external">单元测试</a>不仅免除了使用外部工具的需要，也方便了程序员在自己的代码中执行测试。所有的测试用例都位于可定制的 <code>unittest{}</code> 块中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] evenNumbers(<span class="keyword">int</span>[] numbers)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">import</span> <span class="built_in">std</span>.algorithm: filter; </div><div class="line">    <span class="keyword">import</span> <span class="built_in">std</span>.<span class="built_in">array</span>: <span class="built_in">array</span>;</div><div class="line">    <span class="keyword">return</span> numbers.filter!(n =&gt; n%<span class="number">2</span> == <span class="number">0</span>).<span class="built_in">array</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">unittest</div><div class="line">&#123;</div><div class="line">    assert( evenNumbers([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) == [<span class="number">2</span>, <span class="number">4</span>] );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 D 语言的标准编译器 DMD，你可以通过增加 <code>-unittest</code> 编译器标志把所有的测试编译进可执行结果中。</p>
<p><a href="http://code.dlang.org/getting_started" target="_blank" rel="external">Dub</a> 是 D 语言的一个内建包管理器和构建工具，使用它可以很容易的添加来自 <a href="https://code.dlang.org/" target="_blank" rel="external">Dub package registry</a> 的第三方库。Dub 可以在编译过程中下载、编译和链接这些包，同时也会升级到新版本。</p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>除了提供多种编程范例和功能特性外，D 还提供其他的选择。它目前有三个可用的开源编译器。官方编译器 DMD 使用它自己的后端，另外两个编译器 GDC 和 LDC，分别使用 GCC 和 LLVM 后端。DMD 以编译速度块而著称，而 LDC 和 GDC 则以在很短的编译时间内生成快速生成机器代码而著称。你可以自由选择其中一个以适应你的使用情况。</p>
<p>默认情况下，D 语言是采用<a href="https://dlang.org/spec/garbage.html" target="_blank" rel="external">垃圾收集</a>的内存分配方式的。你也可以选择手动进行内存管理，如果你想的话，甚至可以进行引用计数。一切选择都是你的。</p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>在这个简要的讨论中，还有许多 D 语言好的特性没有涉及到。我强烈推荐阅读 <a href="https://dlang.org/comparison.html" target="_blank" rel="external">D 语言的特性概述</a>，这是隐藏在<a href="https://dlang.org/phobos/index.html" target="_blank" rel="external">标准库</a>中的宝藏，以及 <a href="https://dlang.org/areas-of-d-usage.html" target="_blank" rel="external">D 语言的使用区域</a>，从而进一步了解人们用它来干什么。许多组织已经<a href="https://dlang.org/orgs-using-d.html" target="_blank" rel="external">使用 D 语言来进行开发</a>。最后，如果你打算开始学习 D 语言，那么请看这本书 <em><a href="http://ddili.org/ders/d.en/index.html" target="_blank" rel="external">D 语言编程</a></em>。</p>
<p>（题图：opensource.com）</p>
<hr>
<p>via: <a href="https://opensource.com/article/17/5/d-open-source-software-development" target="_blank" rel="external">https://opensource.com/article/17/5/d-open-source-software-development</a></p>
<p>作者：<a href="https://opensource.com/users/aberba" target="_blank" rel="external">Lawrence Aberba</a><br>译者：<a href="https://github.com/ucasFL" target="_blank" rel="external">ucasFL</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;D 语言的模块化、开发效率、可读性以及其它一些特性使其非常适合用于协同软件的开发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://opensource.com/sites/default/files/styles/image-full-size/public/images/life/code_development_programming.png?itok=eYK4UXiq&quot; alt=&quot;Why the D programming language is great for open source development&quot; title=&quot;Why the D programming language is great for open source development&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dlang.org/&quot;&gt;D 编程语言&lt;/a&gt;是一种静态类型的通用编程语言，它具有和 C 语言类似的语法，能够编译为本地代码。许多理由使得它很适合用于开源软件开发，下面讲到的是其中一些理由。&lt;/p&gt;
&lt;h3 id=&quot;模块化能力&quot;&gt;&lt;a href=&quot;#模块化能力&quot; class=&quot;headerlink&quot; title=&quot;模块化能力&quot;&gt;&lt;/a&gt;模块化能力&lt;/h3&gt;&lt;p&gt;在大多数情况下，当你有一个好的想法，你可以完全按照你的内心所想的方式通过代码来实现它。然而，有的时候，你不得让你的想法向代码妥协，而不是通过模块化代码来适应想法。D 语言支持多种&lt;a href=&quot;https://en.wikipedia.org/wiki/Programming_paradigm&quot;&gt;编程范式&lt;/a&gt;，包括函数式风格、命令式、面向对象、元编程、并发（演员模式），这些全都和谐共存。你可以选择任何一种方便的编程范式来将你的想法转换为代码。&lt;/p&gt;
&lt;p&gt;通过使用&lt;a href=&quot;http://ddili.org/ders/d.en/templates.html&quot;&gt;模板&lt;/a&gt;，可以生成额外的 D 代码并在编译的过程中把它编排进去，你可以把这些代码描述成编译器生成代码的一种模式。这是一种非常有用的设计算法，无需把它们绑定到任何特定的类型。由于模版的通用性，就很容易生成平台无关的代码。通过将模板与&lt;a href=&quot;https://dlang.org/spec/version.html&quot;&gt;条件编译&lt;/a&gt;结合，跨平台的应用变得更加容易实现，也更容易接受来自使用不同操作系统的开发者的贡献。有了这一点，一个程序员可以通过很少的代码，利用有限的时间实现很多东西。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ddili.org/ders/d.en/ranges.html&quot;&gt;range&lt;/a&gt; 已经深度集成到了 D 语言中，相对于具体实现，它抽象出容器元素（比如数组、关联数组和链表等）是如何访问的。这个抽象使得可以在许多容器类型中设计和使用大量的算法，而无需绑定到特定的数据结构。D 的&lt;a href=&quot;https://dlang.org/spec/arrays.html#slicing&quot;&gt;数组切片&lt;/a&gt;是 range 的一个实现。最终，你可以用很少的时间写很少的代码，并且只需要很低的维护成本。&lt;br&gt;
    
    </summary>
    
      <category term="D" scheme="http://ucasfl.me/categories/D/"/>
    
    
      <category term="D" scheme="http://ucasfl.me/tags/D/"/>
    
  </entry>
  
  <entry>
    <title>总结：Python+MySQL</title>
    <link href="http://ucasfl.me/2017/06/13/Summary:Python+MySQL/"/>
    <id>http://ucasfl.me/2017/06/13/Summary:Python+MySQL/</id>
    <published>2017-06-13T14:45:04.000Z</published>
    <updated>2017-09-02T04:38:29.059Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近越来越懒了，写博客甚至只想贴几行代码上去。</p>
<p>直接进入正题。</p>
<p>最近在做师兄给安排的一个任务，说简单点就是用 Python 来操作 MySQL 进行一些简单的数据统计。<br><a id="more"></a></p>
<h3 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h3><p>第一步：通过 Python 连接到数据库。需要先安装一个模块 <code>MySQLdb</code>：</p>
<p>首先，访问<a href="https://pypi.python.org/pypi/MySQL-python" target="_blank" rel="external">https://pypi.python.org/pypi/MySQL-python</a>下载适合系统的安装包。</p>
<p>然后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ gunzip MySQL-python-1.2.2.tar.gz</div><div class="line">$ tar -xvf MySQL-python-1.2.2.tar</div><div class="line">$ cd MySQL-python-1.2.2</div><div class="line">$ python setup.py build</div><div class="line">$ python setup.py install</div></pre></td></tr></table></figure>
<p>第二步：连接到 MySQL 数据库：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> MySQLdb</div><div class="line">db = MySQLdb.<span class="built_in">connect</span>(<span class="string">"hostname"</span>, <span class="string">"username"</span>, <span class="string">"password"</span>, <span class="string">"database_name"</span>)</div></pre></td></tr></table></figure>
<p>第三步：执行 SQL 语句（接上）:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># example</span></div><div class="line"><span class="built_in">cursor</span> = db.<span class="built_in">cursor</span>()</div><div class="line">sql = <span class="string">"SELECT * FROM database_name"</span></div><div class="line"><span class="meta"># execute</span></div><div class="line"><span class="built_in">cursor</span>.execute(sql)</div></pre></td></tr></table></figure>
<p>第四步：Fetch 结果：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># fetch one line</span></div><div class="line"><span class="attr">result</span> = cursor.fetchone()</div><div class="line"><span class="comment"># fetch all lines</span></div><div class="line"><span class="attr">result</span> = cursor.fetchall()</div></pre></td></tr></table></figure>
<p>第五步：关闭连接：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cursor</span>.<span class="built_in">close</span>()</div></pre></td></tr></table></figure>
<p>有了这些，并且懂一些基本的 SQL 知识的话，就知道怎么用 Python 来操作数据库了。</p>
<p>下面，说一下利用 Python 从 MySQL fetch 出来的数据的类型：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> raw_name <span class="keyword">COUNT</span>(row_name) <span class="keyword">FROM</span> database_name <span class="keyword">GROUP</span> <span class="keyword">BY</span> raw_name;</div></pre></td></tr></table></figure>
<p>通过上一语句 fetch 得到的数据为字典类型：键值对为：raw_name - COUNT(raw_name) .</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> databasse_name;</div></pre></td></tr></table></figure>
<p>通过上一语句 fetch 得到的数据为元组类型，元组中的每一个元素依旧为元组。</p>
<p>知道了数据类型，就可以方便利用 Python 对数据进行处理了。</p>
<h3 id="Python-文件读写"><a href="#Python-文件读写" class="headerlink" title="Python 文件读写"></a>Python 文件读写</h3><p>后一个参数为打开方式。</p>
<ul>
<li>r：只读</li>
<li>w：写（会覆盖）</li>
<li>w+：追加</li>
<li>a：追加（append)</li>
</ul>
<p>读文件：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file_object.<span class="built_in">read</span>()</div></pre></td></tr></table></figure>
<p>写文件：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">file<span class="number">_</span><span class="keyword">object</span>.write(<span class="string">'string'</span>)</div><div class="line">file<span class="number">_</span><span class="keyword">object</span>.writelines(<span class="string">'string'</span>)</div></pre></td></tr></table></figure>
<p>关闭文件：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file_object.<span class="built_in">close</span>()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近越来越懒了，写博客甚至只想贴几行代码上去。&lt;/p&gt;
&lt;p&gt;直接进入正题。&lt;/p&gt;
&lt;p&gt;最近在做师兄给安排的一个任务，说简单点就是用 Python 来操作 MySQL 进行一些简单的数据统计。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://ucasfl.me/categories/Python/"/>
    
    
      <category term="Python/MySQL" scheme="http://ucasfl.me/tags/Python-MySQL/"/>
    
  </entry>
  
</feed>
