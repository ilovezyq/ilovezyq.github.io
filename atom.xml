<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>春暖花开</title>
  <subtitle>love, life, thinking, coding</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ucasfl.me/"/>
  <updated>2017-11-05T05:49:33.057Z</updated>
  <id>http://ucasfl.me/</id>
  
  <author>
    <name>Flynn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Gitment Test</title>
    <link href="http://ucasfl.me/2017/11/05/Gitment-test/"/>
    <id>http://ucasfl.me/2017/11/05/Gitment-test/</id>
    <published>2017-11-05T05:40:13.000Z</published>
    <updated>2017-11-05T05:49:33.057Z</updated>
    
    <content type="html"><![CDATA[<p>This page have gitment.</p>
<p>
  <div id="container"></div>
</p>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">

<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>

<script>
  var gitment = new Gitment({
    id: , // 可选。默认为 location.href
    owner: 'ucasFL',
    repo: 'BlogComment',
    oauth: {
      client_id: 'ef399b43f01e072241fd',
      client_secret: '9258aef304e43fda24e51941bb0bbfc167e4e0a5',
    },
  })
  gitment.render('container')
</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This page have gitment.&lt;/p&gt;
&lt;p&gt;
  &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/defa
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在 Linux 中如何通过命令行开启或禁用触摸板</title>
    <link href="http://ucasfl.me/2017/11/02/How-to-enable-or-disable-touchpad-in-Linux-with-command-line/"/>
    <id>http://ucasfl.me/2017/11/02/How-to-enable-or-disable-touchpad-in-Linux-with-command-line/</id>
    <published>2017-11-02T15:45:10.000Z</published>
    <updated>2017-11-02T16:12:49.183Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何在 Linux 中如何使用命令行命令来打开和关闭触摸板。</p>
<a id="more"></a>
<p>首先，需要了解一个工具：<code>xinput</code></p>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">xinput is <span class="selector-tag">a</span> utility to list available <span class="selector-tag">input</span> devices, query information</div><div class="line">about <span class="selector-tag">a</span> device and change <span class="selector-tag">input</span> device settings.</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>上面是 <code>man</code> 手册对它的描述，中文什么意思很简单。</p>
<p>要通过触摸板开启或关闭触摸板，首先要要获取触摸板的设备 ID 和属性。</p>
<p>我们可以可以先通过 <code>xinput --list</code> 命令查看有哪些输入设备。下面的结果是在我的笔记本上的输出：</p>
<figure class="highlight crmsh">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">⎡ Virtual core pointer                          <span class="attr">id=</span><span class="number">2</span>    [<span class="keyword">master</span> <span class="title">pointer</span>  (<span class="number">3</span>)]</div><div class="line">⎜   ↳ Virtual core XTEST pointer                <span class="attr">id=</span><span class="number">4</span>    [<span class="literal">slave</span>  pointer  (<span class="number">2</span>)]</div><div class="line">⎜   ↳ PixArt USB Optical Mouse                  <span class="attr">id=</span><span class="number">10</span>   [<span class="literal">slave</span>  pointer  (<span class="number">2</span>)]</div><div class="line">⎜   ↳ DELL0767:<span class="number">00</span> <span class="number">06</span>CB:<span class="number">7</span>E92 Touchpad            <span class="attr">id=</span><span class="number">12</span>   [<span class="literal">slave</span>  pointer  (<span class="number">2</span>)]</div><div class="line">⎜   ↳ SynPS/<span class="number">2</span> Synaptics TouchPad                <span class="attr">id=</span><span class="number">14</span>   [<span class="literal">slave</span>  pointer  (<span class="number">2</span>)]</div><div class="line">⎣ Virtual core keyboard                         <span class="attr">id=</span><span class="number">3</span>    [<span class="keyword">master</span> <span class="title">keyboard</span> (<span class="number">2</span>)]</div><div class="line">    ↳ Virtual core XTEST keyboard               <span class="attr">id=</span><span class="number">5</span>    [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ Power Button                              <span class="attr">id=</span><span class="number">6</span>    [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ Video Bus                                 <span class="attr">id=</span><span class="number">7</span>    [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ Power Button                              <span class="attr">id=</span><span class="number">8</span>    [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ Sleep Button                              <span class="attr">id=</span><span class="number">9</span>    [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ Integrated Webcam                         <span class="attr">id=</span><span class="number">11</span>   [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ AT Translated Set <span class="number">2</span> keyboard              <span class="attr">id=</span><span class="number">13</span>   [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ Dell WMI hotkeys                          <span class="attr">id=</span><span class="number">15</span>   [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div><div class="line">    ↳ DELL Wireless hotkeys                     <span class="attr">id=</span><span class="number">16</span>   [<span class="literal">slave</span>  keyboard (<span class="number">3</span>)]</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>可以看到，第 4 行输出即为触摸板，后面的 <code>id</code> 即为设备号。</p>
<p>下面，查看触摸板的属性：</p>
<figure class="highlight ada">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">xinput <span class="comment">--list-props 12 </span></div><div class="line">＃或</div><div class="line">xinput <span class="comment">--list-props ‘DELL0767:00 06CB:7E92 Touchpad’</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>即使用设备 <code>id</code> 或设备名作为后面的参数均可以。</p>
<p>下面是在我的笔记本上的输出：</p>
<figure class="highlight aspectj">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">Device <span class="string">'DELL0767:00 06CB:7E92 Touchpad'</span>:</div><div class="line">	Device Enabled (140):	0</div><div class="line">	Coordinate Transformation Matrix (142):	1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000</div><div class="line">	Device Accel Profile (263):	1</div><div class="line">	Device Accel Constant Deceleration (264):	2.500000</div><div class="line">	Device Accel Adaptive Deceleration (265):	1.000000</div><div class="line">	Device Accel Velocity Scaling (266):	12.500000</div><div class="line">	Synaptics Edges (288):	49, 1180, 50, 879</div><div class="line">	Synaptics Finger (289):	25, 30, 0</div><div class="line">	Synaptics Tap Time (290):	180</div><div class="line">	Synaptics Tap Move (291):	67</div><div class="line">	Synaptics Tap Durations (292):	180, 180, 100</div><div class="line">	Synaptics ClickPad (293):	1</div><div class="line">	Synaptics Middle Button Timeout (294):	0</div><div class="line">	Synaptics Two-Finger Pressure (295):	282</div><div class="line">	Synaptics Two-Finger Width (296):	7</div><div class="line">	Synaptics Scrolling Distance (297):	30, 30</div><div class="line">	Synaptics Edge Scrolling (298):	0, 0, 0</div><div class="line">	Synaptics Two-Finger Scrolling (299):	1, 1</div><div class="line">	Synaptics Move Speed (300):	1.000000, 1.750000, 0.129870, 0.000000</div><div class="line">	Synaptics Off (301):	0</div><div class="line">	Synaptics Locked Drags (302):	0</div><div class="line">	Synaptics Locked Drags Timeout (303):	5000</div><div class="line">	Synaptics Tap Action (304):	2, 3, 0, 0, 1, 3, 2</div><div class="line">	Synaptics Click Action (305):	1, 3, 0</div><div class="line">	Synaptics Circular Scrolling (306):	0</div><div class="line">	Synaptics Circular Scrolling Distance (307):	0.100000</div><div class="line">	Synaptics Circular Scrolling Trigger (308):	0</div><div class="line">	Synaptics Circular Pad (309):	0</div><div class="line">	Synaptics Palm Detection (310):	0</div><div class="line">	Synaptics Palm Dimensions (311):	10, 200</div><div class="line">	Synaptics Coasting Speed (312):	20.000000, 50.000000</div><div class="line">	Synaptics Pressure Motion (313):	30, 160</div><div class="line">	Synaptics Pressure Motion Factor (314):	1.000000, 1.000000</div><div class="line">	Synaptics Resolution Detect (315):	1</div><div class="line">	Synaptics Grab Event Device (316):	0</div><div class="line">	Synaptics Gestures (317):	1</div><div class="line">	Synaptics Capabilities (318):	1, 0, 0, 1, 1, 0, 0</div><div class="line">	Synaptics Pad Resolution (319):	12, 12</div><div class="line">	Synaptics Area (320):	0, 0, 0, 0</div><div class="line">	Synaptics Soft Button Areas (321):	614, 0, 761, 0, 0, 0, 0, 0</div><div class="line">	Synaptics Noise Cancellation (322):	7, 7</div><div class="line">	Device Product ID (258):	1739, 32402</div><div class="line">	Device Node (259):	<span class="string">"/dev/input/event15"</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>可以看到，第一个属性即为触摸板状态：1 表示开启，0 表示关闭，属性编号为 140。</p>
<p>之后，我们可以使用下面的命令来开启或关闭触摸板：</p>
<figure class="highlight dsconfig">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment"># 开启触摸板</span></div><div class="line"><span class="string">xinput </span><span class="built_in">set-prop</span> <span class="string">12 </span><span class="string">140 </span>1</div><div class="line"><span class="comment"># 关闭触摸板</span></div><div class="line"><span class="string">xinput </span><span class="built_in">set-prop</span> <span class="string">12 </span><span class="string">140 </span>0</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>其中，设备 ID 和属性编号也可替换为名字。</p>
<p>但是，每次都使用这个命令会比较麻烦，因此，可以通过一个简单的脚本来实现：</p>
<figure class="highlight bash">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> == <span class="string">"on"</span> ]; <span class="keyword">then</span></div><div class="line">	xinput <span class="built_in">set</span>-prop 12 140 1;</div><div class="line">	<span class="built_in">echo</span> <span class="string">"Touchpad successfully enabled!"</span>;</div><div class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$1</span>"</span> == <span class="string">"off"</span> ]; <span class="keyword">then</span></div><div class="line">	xinput <span class="built_in">set</span>-prop 12 140 0;</div><div class="line">	<span class="built_in">echo</span> <span class="string">"Touchpad successfully disabled!"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">	<span class="built_in">echo</span> <span class="string">"Please use the program with one of the following arguments:"</span></div><div class="line">	<span class="built_in">echo</span> <span class="string">"   (1) on  : enable the touchpad!"</span></div><div class="line">	<span class="built_in">echo</span> <span class="string">"   (2) off : disable the touchpad!"</span></div><div class="line"><span class="keyword">fi</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>将该脚本命名为 <code>touchpad</code> ，然后放到 <code>/home/user/bin</code> 目录下。然后，开启或关闭触摸板就很方便了：</p>
<figure class="highlight nginx">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment"># 开启触摸板</span></div><div class="line"><span class="attribute">touchpad</span> <span class="literal">on</span></div><div class="line"><span class="comment"># 关闭触摸板</span></div><div class="line">touchpad <span class="literal">off</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>注意，脚本中的设备 ID 和属性编号应和你的笔记本一致，<code>user</code> 为你的用户名。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍如何在 Linux 中如何使用命令行命令来打开和关闭触摸板。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ucasfl.me/categories/Linux/"/>
    
    
      <category term="Linux touchpad" scheme="http://ucasfl.me/tags/Linux-touchpad/"/>
    
  </entry>
  
  <entry>
    <title>记一下那些年使用 Linux 踩过的坑</title>
    <link href="http://ucasfl.me/2017/10/30/What-the-fuck-problem-with-Linux/"/>
    <id>http://ucasfl.me/2017/10/30/What-the-fuck-problem-with-Linux/</id>
    <published>2017-10-30T11:54:31.000Z</published>
    <updated>2017-10-31T02:48:59.013Z</updated>
    
    <content type="html"><![CDATA[<p>笔记本上装了双系统：Windows 10 + Ubuntu，刚装好 Ubuntu 不久就重新从 Windows 下分了一个盘挂载到 Ubuntu 下。如今，由于基本不再使用 Windows 系统，准确的说就只在虚拟机上使用一下 QQ、微信。于是，我又从 Windows 下分出一个盘，准备挂载到 Ubuntu 下。然而，却突然启动不进去了，直接进入了 <code>emergency mode</code>，尝试重新启动到默认模式，然后出现下面的错误信息：</p>
<a id="more"></a>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">[   84.260812] EXT4-fs (sda7): VFS: can&apos;t find ext4 filesystem.</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>错误信息很直接，说<code>sda7</code>不是<code>ext4</code>文件系统格式。</p>
<p>然后查看分区：<code>fdisk -l</code>，输出如下：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">Disk /dev/sda: 931.5 GiB, 1000204886016 bytes, 1953525168 sectors</div><div class="line">Units: sectors of 1 * 512 = 512 bytes</div><div class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</div><div class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</div><div class="line">Disklabel type: gpt</div><div class="line">Disk identifier: A3FE2E3C-3EBC-401D-8BB3-987D9B33F0EC</div><div class="line"></div><div class="line">Device          Start        End   Sectors   Size Type</div><div class="line">/dev/sda1        2048    1026047   1024000   500M EFI System</div><div class="line">/dev/sda2     1026048    1288191    262144   128M Microsoft reserved</div><div class="line">/dev/sda3     1288192  284209819 282921628 134.9G Microsoft basic data</div><div class="line">/dev/sda4   284211200  508033023 223821824 106.7G Microsoft basic data</div><div class="line">/dev/sda5   508035072  949225471 441190400 210.4G Linux filesystem</div><div class="line">/dev/sda6   949225472  965793791  16568320   7.9G Linux swap</div><div class="line">/dev/sda7   965793792 1298845695 333051904 158.8G Microsoft basic data</div><div class="line">/dev/sda8  1298845696 1718274047 419428352   200G Linux filesystem</div><div class="line">/dev/sda9  1718276096 1927991295 209715200   100G Microsoft basic datamount -o remount,rw /</div><div class="line">mount --all</div><div class="line">chown root:root /usr/bin/sudo</div><div class="line">chmod 4755 /usr/bin/sudo</div><div class="line">/dev/sda10 1927993344 1928998911   1005568   491M Windows recovery environment</div><div class="line">/dev/sda11 1928998912 1951117311  22118400  10.6G Windows recovery environment</div><div class="line">/dev/sda12 1951119360 1953523711   2404352   1.2G Windows recovery environment</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>What ? <code>/dev/sd7</code> 是 Windows 系统的 C 盘，怎么它会在启动的时候挂载呢，而且还是以 <code>ext4</code> 的文件系统格式挂载。想了半天，没发现问题。还好，机智的我赶紧看了一下 <code>/etc/fstab</code> 文件内容：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"># /etc/fstab: static file system information.</div><div class="line">#</div><div class="line"># Use &apos;blkid&apos; to print the universally unique identifier for a</div><div class="line"># device; this may be used with UUID= as a more robust way to name devices</div><div class="line"># that works even if disks are added and removed. See fstab(5).</div><div class="line">#</div><div class="line"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</div><div class="line"># / was on /dev/sda9 during installation</div><div class="line">UUID=e3a38d48-680a-49e5-a98f-ae8bb6a37293 /               ext4    errors=remount-ro 0       1</div><div class="line"># /boot/efi was on /dev/sda1 during installation</div><div class="line">UUID=FE51-6D32  /boot/efi       vfat    umask=0077      0       1</div><div class="line"># swap was on /dev/sda10 during installation</div><div class="line">UUID=c6a51fbb-d72a-4d93-9305-b75aaf6ab1fa none            swap    sw              0       0</div><div class="line">dev/sda7 home/fenglv/FILE ext4 defaults 0 1</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>？？？原来之前挂载到 Ubuntu 上的盘设备名就是 <code>/dev/sda7</code> ，添加一个新的分区后设备名变为了 <code>/dev/sda8</code>，现在的 <code>/dev/sda7</code> 对应的就是 Windows 系统的 C 盘。而我没有修改 <code>/etc/fstab</code> ，所以才导致 Linux 系统启动的时候无法将该设备挂载上。</p>
<p>修改之后终于正常启动了。</p>
<p>然而事情并没有结束。之后，<code>sudo</code> 不能使用了，错误信息如下：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">sudo: error in /etc/sudo.conf, line 0 while loading plugin `sudoers_policy&apos;</div><div class="line">sudo: /usr/lib/sudo/sudoers.so must be only be writable by owner</div><div class="line">sudo: fatal error, unable to load plugins</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>好吧，直接上网查。最后在 <a href="https://askubuntu.com/questions/637432/sudo-comes-up-with-an-error-cannot-run-anything-as-root" target="_blank" rel="external">askubunntu</a> 上找到了解决办法：启动到 <code>recovery mode</code> ，然后执行下面的命令：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">mount -o remount,rw /</div><div class="line">chmod 644 /usr/lib/sudo/sudoers.so</div><div class="line">chown -R root /usr/lib/sudo</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>至此，全部问题解决。</p>
<p>问题并没有真的结束（文章更新），之后，virtualbox 不能启动了：</p>
<figure class="highlight vim">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">VBoxHeadles<span class="variable">s:</span> Effective UID <span class="keyword">is</span> not root (euid=<span class="number">1000</span> egid=<span class="number">1000</span> uid=<span class="number">1000</span> gid=<span class="number">1000</span>)</div><div class="line">VBoxHeadles<span class="variable">s:</span> Tip! It may <span class="keyword">help</span> <span class="keyword">to</span> reinstall VirtualBox.</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>正确的做法就是按照它的提示把 virtualbox 卸了重新安装。然而，我却去修改<code>/usr/bin</code>的所有者：<code>chown -R root /usr/bin</code> 。这样以后，不但 <code>virtual box</code> 无法启动，<code>sudo</code> 又不能用了，这次的错误信息如下：</p>
<figure class="highlight armasm">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="symbol">sudo</span>: /usr/<span class="keyword">bin/sudo </span>must <span class="keyword">be </span>owned <span class="keyword">by </span>uid <span class="number">0</span> <span class="keyword">and </span>have the setuid <span class="keyword">bit </span>set</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>最后找到解决办法：再次进入 <code>recovery mode</code>，执行下面命令：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">mount -o remount,rw /</div><div class="line">mount --all</div><div class="line">chown root:root /usr/bin/sudo</div><div class="line">chmod 4755 /usr/bin/sudo</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>问题解决。</p>
<p>Linux 的权限问题真让人头疼。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔记本上装了双系统：Windows 10 + Ubuntu，刚装好 Ubuntu 不久就重新从 Windows 下分了一个盘挂载到 Ubuntu 下。如今，由于基本不再使用 Windows 系统，准确的说就只在虚拟机上使用一下 QQ、微信。于是，我又从 Windows 下分出一个盘，准备挂载到 Ubuntu 下。然而，却突然启动不进去了，直接进入了 &lt;code&gt;emergency mode&lt;/code&gt;，尝试重新启动到默认模式，然后出现下面的错误信息：&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ucasfl.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ucasfl.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 主机和 Vbox 下的 Windows 虚拟机创建共享文件夹</title>
    <link href="http://ucasfl.me/2017/10/28/Linux-host-create-share-folder-with-windows-vbox/"/>
    <id>http://ucasfl.me/2017/10/28/Linux-host-create-share-folder-with-windows-vbox/</id>
    <published>2017-10-28T06:42:12.000Z</published>
    <updated>2017-10-28T06:52:02.027Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 下，难免会使用一些 Windows 的软件，此时其中一个选择就是安装虚拟机。下面将阐述如何在 Linux 主机下创建一个和 VirtualBox 下的 Windows 虚拟机的共享文件夹。</p>
<a id="more"></a>
<p>首先确保安装好虚拟机。</p>
<p>第一步，启动虚拟机，点击左上方工具栏 -&gt; 安装增加功能 -&gt; 按照提示安装成功即可。</p>
<p>第一步，打开虚拟机设置 -&gt; 共享文件夹 -&gt; 添加路径 -&gt; 设置共享文件夹名字（假设名字为 Win7，后面会用到。）</p>
<p>第三步，重启虚拟机 -&gt; 打开 cmd -&gt; 输入命令 <code>net use x: \\vboxsvr\Win7</code> 即可。其中 <code>x</code> 为盘符，任意一个未使用的字母均可以，<code>Win7</code> 即为上面设置的共享文件夹名字。</p>
<p>这样，在主机和虚拟机之间就创建了一个共享文件夹。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Linux 下，难免会使用一些 Windows 的软件，此时其中一个选择就是安装虚拟机。下面将阐述如何在 Linux 主机下创建一个和 VirtualBox 下的 Windows 虚拟机的共享文件夹。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ucasfl.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ucasfl.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 编程风格</title>
    <link href="http://ucasfl.me/2017/10/26/Pythonic-programming-tips/"/>
    <id>http://ucasfl.me/2017/10/26/Pythonic-programming-tips/</id>
    <published>2017-10-26T04:10:08.000Z</published>
    <updated>2017-10-27T13:04:59.314Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录在学习过程掌握/学习到的一些 Python 编程的奇技淫巧，即如何写 Pythonic 的 Python 代码。因此，文章将会持续更新，更新时间不限。由于本人知识有限，文中难免会出现不足或错误的地方。</p>
<a id="more"></a>
<h3 id="多变量赋值"><a href="#多变量赋值" class="headerlink" title="多变量赋值"></a>多变量赋值</h3>
<p>变量赋值是编程语言里面最简单的语句之一，通常情况下，我们会这样做：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">a = <span class="number">1</span></div><div class="line">b = <span class="number">2</span></div><div class="line">c = <span class="number">3</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>这样便完成了对三个变量的赋值，但你可以用更简单的方式：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="元素值交换"><a href="#元素值交换" class="headerlink" title="元素值交换"></a>元素值交换</h3>
<p>在编程过程中，交换两个变量的值是非常常见的。一般情况下，我们会用下面这种方式来交换两个变量的值（尤其是对于第一门语言是C/C++的人来说）：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">t = a</div><div class="line">a = b</div><div class="line">b = t</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>这种方式是正确的，没有人敢说它不对，但事实上，在 Python 里，你可以有更简单的方式来完成这件事：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">a, b = b, a</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>没错，一行语句就够了。</p>
<p>对上面两个技巧的解释：在 Python 中，任何以逗号分隔的对象均被当作元组处理，因此<code>1, 2, 3</code>　实际上就是一个元组<code>(1, 2, 3)</code>，赋值过程可以看成是元组的解包 。交换值也是同样的，它相当于把等号右边的元组解包后赋值给了左边的变量。为了提高代码的可读性，上面的例子可以加上括号：</p>
<figure class="highlight stylus">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span> = (<span class="selector-tag">b</span>, a)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h3>
<p>假设 <code>list1</code> 是一个字符串组成的列表，现在，需要把 <code>list1</code> 中的每一个字符串的每一个小写字母找出来，形成一个新的元组。一般情况下，我们可以这样做：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">list1 = [<span class="string">'adg'</span>, <span class="string">'Adf'</span>, <span class="string">'124'</span>]</div><div class="line">list2 = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</div><div class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> i:</div><div class="line">    <span class="keyword">if</span> j &gt;= <span class="string">'a'</span> <span class="keyword">and</span> j &lt;= <span class="string">'z'</span>:</div><div class="line">      list2.append(j)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>但实际上，你只需要用一个语句就可以完成这件事：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">list2 = [j <span class="keyword">for</span> i <span class="keyword">in</span> list1 <span class="keyword">for</span> j <span class="keyword">in</span> i <span class="keyword">if</span> j &gt;= <span class="string">'a'</span> <span class="keyword">and</span> j &lt;= <span class="string">'z'</span>]</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>没错，Python 就是这么简洁。如果把上面的方括号换成圆括号，那么结果返回的就是一个迭代器，可以使用 <code>next()</code> 方法获取元素：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">list2 = (j <span class="keyword">for</span> i <span class="keyword">in</span> list1 <span class="keyword">for</span> j <span class="keyword">in</span> i <span class="keyword">if</span> j &gt;= <span class="string">'a'</span> <span class="keyword">and</span> j &lt;= <span class="string">'z'</span>)</div><div class="line">list2.next() <span class="comment"># 返回'a'</span></div><div class="line">list2.next() <span class="comment"># 返回'd'</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h3>
<p>函数的多个参数可通过一个元组传递，假设有如下函数：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span><span class="params">(x, y)</span>:</span></div><div class="line">  <span class="keyword">return</span> x + y</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>可重新定义为：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span><span class="params">(*params)</span>:</span></div><div class="line">  <span class="keyword">return</span> params[<span class="number">0</span>] + params[<span class="number">1</span>]</div><div class="line"><span class="comment">#传递参数</span></div><div class="line">add2(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="comment">#或</span></div><div class="line">tuple1 = (<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">add2(*tuple1)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>使用双星号则可以传递一个字典：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">with_star</span><span class="params">(**kwds)</span>:</span></div><div class="line">  print(kwds[<span class="string">'name'</span>], <span class="string">' is '</span>, kwds[<span class="string">'age'</span>] ,<span class="string">' years old.'</span>)</div><div class="line">args = &#123;<span class="string">'name'</span> : <span class="string">'Mrs. GUmby'</span>, <span class="string">'age'</span> : <span class="number">42</span>&#125;</div><div class="line">with_star(**args)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="使用两个列表创建字典"><a href="#使用两个列表创建字典" class="headerlink" title="使用两个列表创建字典"></a>使用两个列表创建字典</h3>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">list2 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div><div class="line">d = dict(zip(list1, list2))</div><div class="line">list1 == list(d.keys())</div><div class="line">list2 == list(d.values())</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3>
<p>多态意味着就算不知道变量所引用的对象类型是什么，也可以对它进行操作，看下面的函数：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span> <span class="params">(a, b)</span>:</span></div><div class="line">  <span class="keyword">return</span> a + b</div><div class="line">add(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 返回３</span></div><div class="line">add(<span class="string">'ab'</span>, <span class="string">'cd'</span>) <span class="comment"># 返回'abcd'</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>很多函数和运算符都是多态的，因此写程序时也应该尽量避免破坏多态，尽量不使用 <code>type, isinstance, issubclass</code> 之类会破坏多态的函数。</p>
<p>多态是 Python 式编程的核心，也被称为 “duck typing”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录在学习过程掌握/学习到的一些 Python 编程的奇技淫巧，即如何写 Pythonic 的 Python 代码。因此，文章将会持续更新，更新时间不限。由于本人知识有限，文中难免会出现不足或错误的地方。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://ucasfl.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://ucasfl.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 速查表</title>
    <link href="http://ucasfl.me/2017/10/07/Python-cheat-sheet/"/>
    <id>http://ucasfl.me/2017/10/07/Python-cheat-sheet/</id>
    <published>2017-10-07T11:20:55.000Z</published>
    <updated>2017-10-25T14:25:34.622Z</updated>
    
    <content type="html"><![CDATA[<p>本手册是 <a href="http://datasciencefree.com/python.pdf" target="_blank" rel="external">Python cheat sheet</a> 的中文翻译版。原作者：Arianne Colton and Sean Chen(data.scientist.info@gmail.com)。</p>
<p>该手册同时位于 <a href="https://github.com/ucasFL/python-cheat-sheet-Chinese-edition" target="_blank" rel="external">GitHub</a> 上，可下载 <a href="https://github.com/ucasFL/python-cheat-sheet-Chinese-edition/blob/master/python-cheat-sheet-zh-cn.pdf" target="_blank" rel="external">PDF 版</a>。</p>
<a id="more"></a>
<h2 id="惯例"><a href="#惯例" class="headerlink" title="惯例"></a>惯例</h2>
<ul>
  <li>Python 对大小写敏感；</li>
  <li>Python 的索引从 0 开始（所有编程语言均如此）；</li>
  <li>Python 使用空白符（制表符或空格）来缩进代码，而不是使用花括号。</li>
</ul>
<h2 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h2>
<ul>
  <li>获取主页帮助： <code>help()</code></li>
  <li>获取函数帮助： <code>help(str.replace)</code></li>
  <li>获取模块帮助： <code>help(re)</code></li>
</ul>
<h2 id="模块（亦称库）"><a href="#模块（亦称库）" class="headerlink" title="模块（亦称库）"></a>模块（亦称库）</h2>
<p>模块只是一个简单地以 <code>.py</code> 为后缀的文件。</p>
<ul>
  <li>列出模块内容：<code>dir(module1)</code></li>
  <li>导入模块：<code>import module</code></li>
  <li>调用模块中的函数：<code>module1.func1()</code></li>
</ul>
<p><strong>注：<code>import</code> 语句会创建一个新的名字空间，并且在该名字空间内执行 <code>.py</code> 文件中的所有语句。如果你想把模块内容导入到当前名字空间，请使用 <code>from module1 import *</code> 语句。</strong></p>
<h2 id="数值类类型"><a href="#数值类类型" class="headerlink" title="数值类类型"></a>数值类类型</h2>
<p>查看变量的数据类型：<code>type(variable)</code></p>
<h3 id="六种经常使用的数据类型"><a href="#六种经常使用的数据类型" class="headerlink" title="六种经常使用的数据类型"></a>六种经常使用的数据类型</h3>
<ol>
  <li>
    <p><strong>int/long</strong>：过大的 <code>int</code> 类型会被自动转化为 <code>long</code> 类型。</p>
  </li>
  <li>
    <p><strong>float</strong>：64 位，Python 中没有 <code>double</code> 类型。</p>
  </li>
  <li>
    <p><strong>bool</strong>：真或假。</p>
  </li>
  <li>
    <p><strong>str</strong>：在 Python 2 中默认以 ASCII 编码，而在 Python 3 中默认以 Unicode 编码；</p>
    <ul>
      <li>字符串可置于单/双/三引号中；</li>
      <li>字符串是字符的序列，因此可以像处理其他序列一样处理字符串；</li>
      <li>特殊字符可通过 <code>\</code> 或者前缀 <code>r</code> 实现：</li>
    </ul>
    <figure class="highlight python">
      <table>
        <tr>
          <td class="gutter">
            <pre><div class="line">1</div></pre>
          </td>
          <td class="code">
            <pre><div class="line">str1 = <span class="string">r'this\f?ff'</span></div></pre>
          </td>
        </tr>
      </table>
    </figure>
    <ul>
      <li>字符串可通过多种方式格式化：</li>
    </ul>
    <figure class="highlight python">
      <table>
        <tr>
          <td class="gutter">
            <pre><div class="line">1</div><div class="line">2</div></pre>
          </td>
          <td class="code">
            <pre><div class="line">template = <span class="string">'%.2f %s haha $%d'</span>;</div><div class="line">str1 = template % (<span class="number">4.88</span>, <span class="string">'hola'</span>, <span class="number">2</span>)</div></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <p><strong>NoneType(None)</strong>：Python <code>null</code> 值（只有 None 对象的一个实例中存在）。</p>
    <ul>
      <li><code>None</code> 不是一个保留关键字，而是 <strong>NoneType</strong> 的一个唯一实例。</li>
      <li><code>None</code> 通常是可选函数参数的默认值：</li>
    </ul>
    <figure class="highlight python">
      <table>
        <tr>
          <td class="gutter">
            <pre><div class="line">1</div></pre>
          </td>
          <td class="code">
            <pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(a, b, c = None)</span></span></div></pre>
          </td>
        </tr>
      </table>
    </figure>
    <ul>
      <li><code>None</code> 的常见用法：</li>
    </ul>
    <figure class="highlight python">
      <table>
        <tr>
          <td class="gutter">
            <pre><div class="line">1</div></pre>
          </td>
          <td class="code">
            <pre><div class="line"><span class="keyword">if</span> variable <span class="keyword">is</span> <span class="keyword">None</span> :</div></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <p><strong>datatime</strong>：Python 内建的 datetime 模块提供了 <code>datetime</code>、<code>data</code> 以及 <code>time</code> 类型。</p>
    <ul>
      <li><code>datetime</code> 组合了存储于 <code>date</code> 和 <code>time</code> 中的信息。</li>
    </ul>
  </li>
</ol>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">#从字符串中创建 datetime</span></div><div class="line">dt1 = datetime.strptime(<span class="string">'20091031'</span>, <span class="string">'%Y%m%d'</span>)</div><div class="line"><span class="comment">#获取 date 对象</span></div><div class="line">dt1.date()</div><div class="line"><span class="comment">#获取 time 对象</span></div><div class="line">dt1.time()</div><div class="line"><span class="comment">#将 datetime 格式化为字符串</span></div><div class="line">dt1.strftime(<span class="string">'%m/%d/%Y%H:%M'</span>)</div><div class="line"><span class="comment">#更改字段值</span></div><div class="line">dt2 = dt1.replace(minute = <span class="number">0</span>, second = <span class="number">30</span>)</div><div class="line"><span class="comment">#做差, diff 是一个 datetime.timedelta 对象</span></div><div class="line">diff = dt1 - dt2</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>注：Python 中的绝大多数对象都是可变的，只有字符串和元组例外。</strong></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2>
<p><strong>注：所有的 non-Get 函数调用，比如下面例子中的 <code>list1.sort()</code> 都是原地操作，即不会创建新的对象，除非特别声明。</strong></p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3>
<p>元组是 Python 中任何类型的对象的一个一维、固定长度、不可变的序列。</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">#创建元组</span></div><div class="line">tup1 = <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> </div><div class="line"><span class="comment"># or</span></div><div class="line">tup1 = (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</div><div class="line"><span class="comment">#创建嵌套元组</span></div><div class="line">tup1 = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>)</div><div class="line"><span class="comment">#将序列或迭代器转化为元组</span></div><div class="line">tuple([<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</div><div class="line"><span class="comment">#连接元组</span></div><div class="line">tup1 + tup2</div><div class="line"><span class="comment">#解包元组</span></div><div class="line">a, b, c = tup1</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>元组应用：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">#交换两个变量的值</span></div><div class="line">a, b = b, a</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3>
<p>列表是 Python 中任何类型的对象的一个一维、非固定长度、可变（比如内容可以被修改）的序列。</p>
<figure class="highlight">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">#创建列表</div><div class="line">list1 = [1, 'a', 3]</div><div class="line">#or</div><div class="line">list1 = list(tup1)</div><div class="line">#连接列表</div><div class="line">list1 + list2 </div><div class="line">#or</div><div class="line">list1.extend(list2)</div><div class="line">#追加到列表的末尾</div><div class="line">list1.append('b')</div><div class="line">#插入指定位置</div><div class="line">list1.insert(PosIndex, 'a')</div><div class="line">#反向插入，即弹出给定位置的值/删除</div><div class="line">ValueAtIdx = list1.pop(PosIndex)</div><div class="line">#移除列表中的第一个值, a 必须是列表中第一个值</div><div class="line">list1.remove('a')</div><div class="line">#检查成员资格</div><div class="line">3 in list1 =&gt; True or False</div><div class="line">#对列表进行排序</div><div class="line">list1.sort()</div><div class="line">#按特定方式排序</div><div class="line">list1.sort(key = len) # 按长度排序</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>使用 + 连接列表会有比较大的开支，因为这个过程中会创建一个新的列表，然后复制对象。因此，使用 <code>extend()</code> 是更明智的选择；</li>
  <li><code>insert</code> 和 <code>append</code> 相比会有更大的开支（时间/空间）；</li>
  <li>在列表中检查是否包含一个值会比在字典和集合中慢很多，因为前者需要进行线性扫描，而后者是基于哈希表的，所以只需要花费常数时间。</li>
</ul>
<h4 id="内建的-bisect-模块"><a href="#内建的-bisect-模块" class="headerlink" title="内建的 bisect 模块"></a>内建的 <code>bisect</code> 模块</h4>
<ul>
  <li>对一个排序好的列表进行二分查找或插入；</li>
  <li><code>bisect.bisect</code>找到元素在列表中的位置，<code>bisect.insort</code>将元素插入到相应位置。用法：</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">import</span> bisect</div><div class="line">list1 = list(range(<span class="number">10</span>))</div><div class="line"><span class="comment">#找到 5 在 list1 中的位置，从 1 开始，因此 position = index + 1</span></div><div class="line">bisect.bisect(list1, <span class="number">5</span>)</div><div class="line"><span class="comment">#将 3.5 插入 list1 中合适位置</span></div><div class="line">bisect.insort(list1, <span class="number">3.5</span>)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>注：<code>bisect</code> 模块中的函数并不会去检查列表是否排序好，因为这会花费很多时间。所以，对未排序好的列表使用这些函数也不会报错，但可能会返回不正确的结果。</strong></p>
<h3 id="针对序列类型的切片"><a href="#针对序列类型的切片" class="headerlink" title="针对序列类型的切片"></a>针对序列类型的切片</h3>
<p>序列类型包括 <code>str</code>、<code>array</code>、<code>tuple</code>、<code>list</code> 等。</p>
<p>用法：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">list1[start:stop]</div><div class="line"><span class="comment">#如果使用 step</span></div><div class="line">list1(start:stop:step)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>注：切片结果包含 <code>start</code> 索引，但不包含 <code>stop</code> 索引；<code>start/stop</code> 索引可以省略，如果省略，则默认为序列从开始到结束，如 <code>list1 == list1[:]</code> 。</strong></p>
<p><code>step</code> 的应用：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">#取出奇数位置的元素</span></div><div class="line">list1[::<span class="number">2</span>]</div><div class="line"><span class="comment">#反转字符串</span></div><div class="line">str1[::<span class="number">-1</span>]</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="字典（哈希映射）"><a href="#字典（哈希映射）" class="headerlink" title="字典（哈希映射）"></a>字典（哈希映射）</h3>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">#创建字典</span></div><div class="line">dict1 = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="number">2</span>: [<span class="number">3</span>,<span class="number">2</span>]&#125;</div><div class="line"><span class="comment">#从序列创建字典</span></div><div class="line">dict(zip(KeyList, ValueList))</div><div class="line"><span class="comment">#获取/设置/插入元素</span></div><div class="line">dict1[<span class="string">'key1'</span>]</div><div class="line">dict1[<span class="string">'key1'</span>] = <span class="string">'NewValue'</span></div><div class="line"><span class="comment">#get 提供默认值</span></div><div class="line">dict1.get(<span class="string">'key1'</span>, DefaultValue)</div><div class="line"><span class="comment">#检查键是否存在</span></div><div class="line"><span class="string">'key1'</span> <span class="keyword">in</span> dict1</div><div class="line"><span class="comment">#获取键列表</span></div><div class="line">dict1.keys()</div><div class="line"><span class="comment">#获取值列表</span></div><div class="line">dict1.values()</div><div class="line"><span class="comment">#更新值</span></div><div class="line">dict1.update(dict2)<span class="comment">#dict1 的值被 dict2 替换</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>如果键不存在，则会出现 <code>KeyError Exception</code> 。</li>
  <li>当键不存在时，如果 <code>get()</code>不提供默认值则会返回 <code>None</code> 。</li>
  <li>以相同的顺序返回键列表和值列表，但顺序不是特定的，又称极大可能非排序。</li>
</ul>
<h4 id="有效字典键类型"><a href="#有效字典键类型" class="headerlink" title="有效字典键类型"></a>有效字典键类型</h4>
<ul>
  <li>键必须是不可变的，比如标量类型(<code>int</code>、<code>float</code>、<code>string</code>)或者元组（元组中的所有对象也必须是不可变的）。</li>
  <li>这儿涉及的技术术语是 <code>hashability</code>。可以用函数 <code>hash()</code>来检查一个对象是否是可哈希的，比如 <code>hash(&#39;This is a string&#39;)</code> 会返回一个哈希值，而 <code>hash([1,2])</code> 则会报错（不可哈希）。</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3>
<ul>
  <li>一个集合是一些无序且唯一的元素的聚集；</li>
  <li>你可以把它看成只有键的字典；</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">#创建集合</span></div><div class="line">set([<span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>])</div><div class="line"><span class="comment">#or</span></div><div class="line">&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>&#125;</div><div class="line"><span class="comment">#子集测试</span></div><div class="line">set1.issubset(set2)</div><div class="line"><span class="comment">#超集测试</span></div><div class="line">set1.issuperset(set2)</div><div class="line"><span class="comment">#测试两个集合中的元素是否完全相同</span></div><div class="line">set1 == set2</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4>
<ul>
  <li>并（又称或）：<code>set1 | set2</code></li>
  <li>交（又称与）：<code>set1 &amp; set2</code></li>
  <li>差：<code>set1 - set2</code></li>
  <li>对称差（又称异或）：<code>set1 ^ set2</code></li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2>
<p>Python 的函数参数传递是通过<strong>引用传递</strong>。</p>
<ul>
  <li>基本形式</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(posArg1, keywordArg1 = <span class="number">1</span>, ..)</span></span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>注</strong></p>
<ul>
  <li>关键字参数必须跟在位置参数的后面；</li>
  <li>默认情况下，Python 不会“延迟求值”，表达式的值会立刻求出来。</li>
</ul>
<h3 id="函数调用机制"><a href="#函数调用机制" class="headerlink" title="函数调用机制"></a>函数调用机制</h3>
<ul>
  <li>所有函数均位于模块内部作用域。见“模块”部分。</li>
  <li>在调用函数时，参数被打包成一个元组和一个字典，函数接收一个元组 <code>args</code> 和一个字典 <code>kwargs</code>，然后在函数内部解包。</li>
</ul>
<p>“函数是对象”的常见用法：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(ops = [str.strip, user_define_func, ..], ..)</span>:</span></div><div class="line">  <span class="keyword">for</span> function <span class="keyword">in</span> ops:</div><div class="line">    value = function(value)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>
<ul>
  <li>如果函数末尾没有 <code>return</code> 语句，则不会返回任何东西。</li>
  <li>如果有多个返回值则通过一个元组来实现。</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">return</span> (value1, value2)</div><div class="line">value1, value2 = func1(..)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="匿名函数（又称-LAMBDA-函数）"><a href="#匿名函数（又称-LAMBDA-函数）" class="headerlink" title="匿名函数（又称 LAMBDA 函数）"></a>匿名函数（又称 LAMBDA 函数）</h3>
<ul>
  <li>什么是匿名函数？</li>
</ul>
<p>匿名函数是一个只包含一条语句的简单函数。</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">lambda</span> x : x * <span class="number">2</span></div><div class="line"><span class="comment">#def func1(x) : return x * 2</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>匿名函数的应用：’curring’，又称利用已存在函数的部分参数来派生新的函数。</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">ma60 = <span class="keyword">lambda</span> x : pd.rolling_mean(x, <span class="number">60</span>)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="一些有用的函数（针对数据结构）"><a href="#一些有用的函数（针对数据结构）" class="headerlink" title="一些有用的函数（针对数据结构）"></a>一些有用的函数（针对数据结构）</h3>
<ul>
  <li><code>enumerate()</code> 返回一个序列<code>(i, value)</code>元组，<code>i</code> 是当前 <code>item</code> 的索引。</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(collection):</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>应用：创建一个序列中值与其在序列中的位置的字典映射（假设每一个值都是唯一的）。</p>
<ul>
  <li><code>sort()</code>可以从任意序列中返回一个排序好的序列。</li>
</ul>
<figure class="highlight">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">sorted([2, 1, 3]) =&gt; [1, 2, 3]</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>应用：</p>
<figure class="highlight">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">sorted(set('abc bcd')) =&gt; [' ',</div><div class="line">'a', 'b', 'c', 'd']</div><div class="line"># 返回一个字符串排序后无重复的字母序列</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li><code>zip()</code>函数可以把许多列表、元组或其他序列的元素配对起来创建一系列的元组。</li>
</ul>
<figure class="highlight">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">zip(seq1, seq2) =&gt; [('seq1_1', 'seq2_1'), (..), ..]</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ol>
  <li><code>zip()</code>可以接收任意数量的序列作为参数，但是产生的元素的数目取决于最短的序列。</li>
</ol>
<p>应用：多个序列同时迭代：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> enumerate(zip(seq1, seq2)):</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ol>
  <li><code>unzip</code>：另一种思考方式是把一些行转化为一些列：</li>
</ol>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">seq1, seq2 = zip(zipOutput)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li><code>reversed()</code> 将一个序列的元素以逆序迭代。</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">list(reversed(range(<span class="number">10</span>)))</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong><code>reversed()</code> 会返回一个迭代器，<code>list()</code> 使之成为一个列表。</strong></p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2>
<ul>
  <li>用于 <code>if-else</code> 条件中的操作符：</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">#检查两个变量是否是相同的对象</span></div><div class="line">var1 <span class="keyword">is</span> var2</div><div class="line"><span class="comment">#检查两个变量是否是不同的对象</span></div><div class="line">var1 <span class="keyword">is</span> <span class="keyword">not</span> var2</div><div class="line"><span class="comment">#检查两个变量的值是否相等</span></div><div class="line">var1 == var2</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>注：Python 中使用 <code>and</code>、<code>or</code>、<code>not</code> 来组合条件，而不是使用 <code>&amp;&amp;</code>、<code>||</code>、<code>!</code> 。</strong></p>
<ul>
  <li><code>for</code>循环的常见用法：</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">#可迭代对象（list、tuple）或迭代器</span></div><div class="line"><span class="keyword">for</span> element <span class="keyword">in</span> iterator:</div><div class="line"><span class="comment">#如果元素是可以解包的序列</span></div><div class="line"><span class="keyword">for</span> a, b, c <span class="keyword">in</span> iterator:</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li><code>pass</code>：无操作语句，在不需要进行任何操作的块中使用。</li>
  <li>三元表达式，又称简洁的 <code>if-else</code>，基本形式：</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">value = true-expr <span class="keyword">if</span> condition <span class="keyword">else</span> false-expr</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>Python 中没有 <code>switch/case</code> 语句，请使用 <code>if/elif</code>。</li>
</ul>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2>
<ul>
  <li><strong>对象（object）</strong>是 Python 中所有类型的根。</li>
  <li>万物（数字、字符串、函数、类、模块等）皆为对象，每个对象均有一个类型（type）。对象变量是一个指向变量在内存中位置的指针。</li>
  <li>所有对象均为<strong>引用计数</strong>。</li>
</ul>
<figure class="highlight">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">sys.getrefcount(5) =&gt; x</div><div class="line">a = 5, b = a</div><div class="line">#上式会在等号的右边创建一个对象的引用，因此 a 和 b 均指向 5</div><div class="line">sys.getrefcount(5)</div><div class="line">=&gt; x + 2</div><div class="line">del(a); sys.getrefcount(5) =&gt; x + 1</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>类的基本形式：</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span><span class="params">(object)</span>:</span></div><div class="line">  <span class="comment"># 'self' 等价于 Java/C++ 中的 'this'</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">    self.name = name</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">memberFunc1</span><span class="params">(self, arg1)</span>:</span></div><div class="line">      ..</div><div class="line"><span class="meta">  @staticmethod</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">classFunc2</span><span class="params">(arg1)</span>:</span></div><div class="line">    ..</div><div class="line">obj1 = MyObject(<span class="string">'name1'</span>)</div><div class="line">obj1.memberFunc1(<span class="string">'a'</span>)</div><div class="line">MyObject.classFunc2(<span class="string">'b'</span>)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>有用的交互式工具：</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">dir(variable1) <span class="comment">#列出对象的所有可用方法</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h2 id="常见字符串操作"><a href="#常见字符串操作" class="headerlink" title="常见字符串操作"></a>常见字符串操作</h2>
<figure class="highlight">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">#通过分隔符连接列表/元组</div><div class="line">', '.join([ 'v1', 'v2', 'v3']) =&gt; 'v1, v2, v3'</div><div class="line"></div><div class="line">#格式化字符串</div><div class="line">string1 = 'My name is &#123;0&#125;　&#123;name&#125;'</div><div class="line">newString1 = string1.format('Sean', name =　'Chen')</div><div class="line"></div><div class="line">#分裂字符串</div><div class="line">sep = '-';</div><div class="line">stringList1 =　string1.split(sep)</div><div class="line"></div><div class="line">#获取子串</div><div class="line">start = 1;</div><div class="line">string1[start:8]</div><div class="line"></div><div class="line">#补 '0' 向右对齐字符串</div><div class="line">month = '5';</div><div class="line">month.zfill(2) =&gt; '05'</div><div class="line">month = '12';</div><div class="line">month.zfill(2) =&gt; '12'</div><div class="line">month.zfill(3) =&gt; '012'</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2>
<ul>
  <li>基本形式：</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">try</span>:</div><div class="line">  ..</div><div class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</div><div class="line">  <span class="keyword">print</span> e</div><div class="line"><span class="keyword">except</span> (TypeError, AnotherError):</div><div class="line">  ..</div><div class="line"><span class="keyword">except</span>:</div><div class="line">  ..</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">  .. <span class="comment"># 清理，比如 close db;</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>手动引发异常：</li>
</ul>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">raise</span> AssertionError <span class="comment"># 断言失败</span></div><div class="line"><span class="keyword">raise</span> SystemExit</div><div class="line"><span class="comment"># 请求程序退出</span></div><div class="line"><span class="keyword">raise</span> RuntimeError(<span class="string">'错误信息 :..'</span>)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h2 id="对列表、字典和元组的深入理解"><a href="#对列表、字典和元组的深入理解" class="headerlink" title="对列表、字典和元组的深入理解"></a>对列表、字典和元组的深入理解</h2>
<p>语法糖（syntactic sugar）会使代码变得更加易读易写。</p>
<h3 id="对列表的理解"><a href="#对列表的理解" class="headerlink" title="对列表的理解"></a>对列表的理解</h3>
<p>将一些元素通过一个简短的语句传入一个过滤器进行过滤和转化，然后可以组成一个新的列表。</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">#基本形式</span></div><div class="line">[expr <span class="keyword">for</span> val <span class="keyword">in</span> collection <span class="keyword">if</span> condition]</div><div class="line"><span class="comment">#ShortCut</span></div><div class="line">result = []</div><div class="line"><span class="keyword">for</span> val <span class="keyword">in</span> collection:</div><div class="line">  <span class="keyword">if</span> condition:</div><div class="line">    result.append(expr)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>可以省略过滤条件，只留下表达式。</p>
<h3 id="对字典的理解"><a href="#对字典的理解" class="headerlink" title="对字典的理解"></a>对字典的理解</h3>
<p>基本形式：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">&#123;key-expr : value-expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="对集合的理解"><a href="#对集合的理解" class="headerlink" title="对集合的理解"></a>对集合的理解</h3>
<p>基本形式：和列表一样，只是应该使用 <code>()</code> 而不是 <code>[]</code> 。</p>
<h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3>
<p>基本形式：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">[expr <span class="keyword">for</span> val <span class="keyword">in</span> collection <span class="keyword">for</span> innerVal <span class="keyword">in</span> val <span class="keyword">if</span> condition]</div></pre>
      </td>
    </tr>
  </table>
</figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本手册是 &lt;a href=&quot;http://datasciencefree.com/python.pdf&quot;&gt;Python cheat sheet&lt;/a&gt; 的中文翻译版。原作者：Arianne Colton and Sean Chen(data.scientist.info@gmail.com)。&lt;/p&gt;
&lt;p&gt;该手册同时位于 &lt;a href=&quot;https://github.com/ucasFL/python-cheat-sheet-Chinese-edition&quot;&gt;GitHub&lt;/a&gt; 上，可下载 &lt;a href=&quot;https://github.com/ucasFL/python-cheat-sheet-Chinese-edition/blob/master/python-cheat-sheet-zh-cn.pdf&quot;&gt;PDF 版&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://ucasfl.me/categories/Python/"/>
    
    
      <category term="Python cheat-sheet" scheme="http://ucasfl.me/tags/Python-cheat-sheet/"/>
    
  </entry>
  
  <entry>
    <title>关于 Linux 你可能不是非常了解的七件事</title>
    <link href="http://ucasfl.me/2017/10/06/Seven-things-you-may-not-know-so-far-about-Linux/"/>
    <id>http://ucasfl.me/2017/10/06/Seven-things-you-may-not-know-so-far-about-Linux/</id>
    <published>2017-10-06T04:51:31.000Z</published>
    <updated>2017-10-06T04:53:32.058Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i0.wp.com/opensourceforu.com/wp-content/uploads/2015/12/Linux-Kernel-sys-visual5.jpg?resize=750%2C563" alt="Hidden features of Linux"></p>
<p>使用 Linux 最酷的事情之一就是随着时间的推移，你可以不断获得新的知识。每天，你都可能会遇到一个新的实用工具，或者只是一个不太熟悉的奇技淫巧，但是却非常有用。这些零碎的东西并不总是能够改变生活，但是却是专业知识的基础。</p>
<p>即使是专家，也不可能事事皆知。无论你有多少经验，可能总会有更多的东西需要你去学习。所以，在这儿我列出了七件关于 Linux 你可能不知道的事情。</p>
<a id="more"></a>
<h3 id="一个查找命令历史的交互模式"><a href="#一个查找命令历史的交互模式" class="headerlink" title="一个查找命令历史的交互模式"></a>一个查找命令历史的交互模式</h3>
<p>你可能对 <code>history</code> 命令非常熟悉，它会读取 bash 历史，然后以编号列表的方式输出到标准输出（<code>stdout</code>）。然而，如果你在 <code>curl</code> 命令的海洋里寻找一个特定的链接（URL），那么这个列表并不总是那么容易阅读的。</p>
<p>你还可以有另一个选择，Linux 有一个交互式的反向搜索可以帮助你解决这个问题。你可以通过快捷键 <code>ctrl+r</code>启动交互模式，然后进入一个交互提示中，它将会根据你提供的字符串来向后搜索 bash 历史，你可以通过再次按下 <code>ctrl+r</code> 向后搜索更老的命令，或者按下 <code>ctrl+s</code> 向前搜索。</p>
<p>注意，<code>ctrl+s</code> 有时会与 XON/XOFF 流控制冲突，即 XON/XOFF 流控制也会使用该快捷键。你可以通过运行 <code>stty -ixon</code> 命令来禁用该快捷键。在你的个人电脑上，这通常是有用的，但是在禁用前，确保你不需要 XON/XOFF 。</p>
<h3 id="Cron-不是安排任务的唯一方式"><a href="#Cron-不是安排任务的唯一方式" class="headerlink" title="Cron 不是安排任务的唯一方式"></a>Cron 不是安排任务的唯一方式</h3>
<p>Cron 任务对于任何水平的系统管理员，无论是毫无经验的初学者，还是经验丰富的专家来说，都是非常有用的。但是，如果你需要安排一个一次性的任务，那么 <code>at</code> 命令为你提供了一个快捷的方式来创建任务，从而你不需要接触 crontab 。</p>
<p><code>at</code> 命令的运行方式是在后面紧跟着你想要运行任务的运行时间。时间是灵活的，因为它支持许多时间格式。包括下面这些例子：</p>
<figure class="highlight ada">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">at</span> <span class="number">12</span>:<span class="number">00</span> PM September <span class="number">30</span> <span class="number">2017</span></div><div class="line"><span class="keyword">at</span> now + <span class="number">1</span> hour</div><div class="line"><span class="keyword">at</span> <span class="number">9</span>:<span class="number">00</span> AM tomorrow</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>当你以带参数的方式输入 <code>at</code> 命令以后，将会提示你该命令将在你的 Linux 系统上运行。这可能是一个备份脚本，一套维护任务，或者甚至是一个普通的 bash 命令。如果要结束任务，可以按 <code>ctrl+d</code> 。</p>
<p>另外，你可以使用 <code>atq</code> 命令查看当前用户的所有任务，或者使用 <code>sudo atq</code> 查看所有用户的任务。它将会展示出所有排定好的任务，并且每个任务都伴有一个 ID 。如果你想取消一个排定好的任务，可以使用 <code>atrm</code> 命令，并且以任务 ID 作为参数。</p>
<h3 id="你可以按照功能搜索命令，而不仅仅是通过名字"><a href="#你可以按照功能搜索命令，而不仅仅是通过名字" class="headerlink" title="你可以按照功能搜索命令，而不仅仅是通过名字"></a>你可以按照功能搜索命令，而不仅仅是通过名字</h3>
<p>记住命令的名字非常困难，特别是对于初学者来说。幸运的是，Linux 附带了一个通过名字和描述来搜索 man 页面的工具。</p>
<p>下次，如果你没有记住你想要使用的工具的名称，你可以尝试使用 <code>apropos</code> 命令加上你想要干的事情的描述。比如，<code>apropos build filesystem</code> 将会返回一系列名字和描述包括了 “build” 和 “filesystem” 单词的工具。</p>
<p><code>apropos</code> 命令接受一个或多个字符串作为参数，但同时它也有其他参数，比如你可以使用 <code>-r</code> 参数，从而通过正则表达式来搜索。</p>
<h3 id="一个允许你来管理系统版本的替代系统"><a href="#一个允许你来管理系统版本的替代系统" class="headerlink" title="一个允许你来管理系统版本的替代系统"></a>一个允许你来管理系统版本的替代系统</h3>
<p>如果你曾进行过软件开发，你就会明白跨项目管理不同版本的语言的支持的重要性。许多 Linux 发行版都有工具可以来处理不同的内建版本。</p>
<p>可执行文件比如 <code>java</code> 往往符号链接到目录 <code>/etc/alternatives</code> 下。反过来，该目录会将符号链接存储为二进制文件并提供一个管理这些链接的接口。Java 可能是替代系统最常管理的语言，但是，经过一些配置，它也可以作为其他应用程序替代品，比如 NVM 和 RVM （NVM 和 RVM 分别是 NodeJS 和 Ruby 的版本管理器）。</p>
<p>在基于 Debian 的系统中，你可以使用 <code>update-alternatives</code> 命令创建和管理这些链接。在 CentOS 中，这个工具就叫做 <code>alternatives</code> 。通过更改你的 alternatives 文件中的链接，你便可以安装一个语言的多个版本，并且在不同的情况下使用不同的二进制。这个替代系统也提供了对任何你可能在命令行运行的程序的支持。</p>
<h3 id="shred-命令是更加安全的删除文件方式"><a href="#shred-命令是更加安全的删除文件方式" class="headerlink" title="shred 命令是更加安全的删除文件方式"></a><code>shred</code> 命令是更加安全的删除文件方式</h3>
<p>我们大多数时候总是使用 <code>rm</code> 命令来删除文件。但是文件去哪儿了呢？真相是 <code>rm</code> 命令所做的事情并不是像你所想像的那样，它仅仅删除了文件系统和硬盘上的数据的硬链接。硬盘上的数据依旧存在，直到被另一个应用重写覆盖。对于非常敏感的数据来说，这会带来一个很大的安全隐患。</p>
<p><code>shred</code> 命令是 <code>rm</code> 命令的升级版。当你使用 <code>shred</code> 命令删除一个文件之后，文件中的数据会被多次随机覆写。甚至有一个选项可以在随机覆写之后对所有的数据进行清零。</p>
<p>如果你想安全的删除一个文件并且以零覆盖，那么可以使用下面的命令：</p>
<p><code>shred -u -z [file name]</code></p>
<p>同时，你也可以使用 <code>-n</code> 选项和一个数字作为参数，从而指定在随机覆盖数据的时候迭代多少次。</p>
<h3 id="通过自动更正来避免输入很长的无效文件路径"><a href="#通过自动更正来避免输入很长的无效文件路径" class="headerlink" title="通过自动更正来避免输入很长的无效文件路径"></a>通过自动更正来避免输入很长的无效文件路径</h3>
<p>有多少次，你输入一个文件的绝对路径，然而却看到“没有该文件或目录”的消息。任何人都会明白输入一个很长的字符串的痛苦。幸运的是，有一个很简单的解决办法。</p>
<p>内建的 <code>shopt</code> 命令允许你设置不同的选项来改变 shell 的行为。设置 <code>cdspell</code> 选项是避免输入文件路径时一个字母出错的头痛的一个简单方式。你可以通过运行 <code>shopt -s cdspell</code> 命令来启用该选项。启用该选项后，当你想要切换目录时，会自动更正为最匹配的目录。</p>
<p>Shell 选项是节省时间的一个好方法（更不用说减少麻烦），此外还有许许多多的其他选项。如果想查看你的系统中所有选项的完整列表，可以运行不带参数的 <code>shopt</code> 命令。需要注意的是，这是 bash 的特性，如果你运行 zsh 或者其他可供选择的 shell，可能无法使用。</p>
<h3 id="通过子-shell-返回到当前目录"><a href="#通过子-shell-返回到当前目录" class="headerlink" title="通过子 shell 返回到当前目录"></a>通过子 shell 返回到当前目录</h3>
<p>如果你曾经配置过一个比较复杂的系统，那么你可能会发现你需要频繁的更换目录，从而很难跟踪你所在的位置。如果在运行完一个命令后自动返回到当前位置，不是很好吗？</p>
<p>Linux 系统实际上提供了一个解决该问题的方法，并且非常简单。如果你想通过 <code>cd</code> 命令进入另一个目录完成一些任务，然后再返回当前工作目录，那么你可以将命令置于括号中。你可以在你的 Linux 系统上尝试下面这个命令。记住你当前的工作目录，然后运行：</p>
<figure class="highlight lisp">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">(<span class="name">cd</span> /etc <span class="symbol">&amp;&amp;</span> ls -a)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>该命令会输出 <code>/etc</code> 目录的内容。现在，检查你的当前工作目录。它和执行该命令前的目录一样，而不是 <code>/etc</code> 目录。</p>
<p>它是如何工作的呢？运行一个括号中的命令会创建一个子 shell 或一个当前 shell 进程的复刻副本。该子 shell 可以访问所有的父变量，反之则不行。所以请记住，你是在运行一个非常复杂的单行命令。</p>
<p>在并行处理中经常使用子 shell ，但是在命令行中，它也能为你带来同样的力量，从而使你在浏览文件系统时更加容易。</p>
<hr>
<p>via: <a href="http://opensourceforu.com/2017/09/top-7-things-linux-may-not-known-far/" target="_blank" rel="external">http://opensourceforu.com/2017/09/top-7-things-linux-may-not-known-far/</a></p>
<p>作者：<a href="http://opensourceforu.com/author/phil-zona/" target="_blank" rel="external">PHIL ZONA</a><br>译者：<a href="https://github.com/ucasFL" target="_blank" rel="external">ucasFL</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i0.wp.com/opensourceforu.com/wp-content/uploads/2015/12/Linux-Kernel-sys-visual5.jpg?resize=750%2C563&quot; alt=&quot;Hidden features of Linux&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用 Linux 最酷的事情之一就是随着时间的推移，你可以不断获得新的知识。每天，你都可能会遇到一个新的实用工具，或者只是一个不太熟悉的奇技淫巧，但是却非常有用。这些零碎的东西并不总是能够改变生活，但是却是专业知识的基础。&lt;/p&gt;
&lt;p&gt;即使是专家，也不可能事事皆知。无论你有多少经验，可能总会有更多的东西需要你去学习。所以，在这儿我列出了七件关于 Linux 你可能不知道的事情。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ucasfl.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ucasfl.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 下代理服务器失败无法上网的解决办法</title>
    <link href="http://ucasfl.me/2017/09/25/Setting-Proxy-For-google-chrome-in-Ubuntu/"/>
    <id>http://ucasfl.me/2017/09/25/Setting-Proxy-For-google-chrome-in-Ubuntu/</id>
    <published>2017-09-25T00:56:12.000Z</published>
    <updated>2017-09-25T01:11:48.338Z</updated>
    
    <content type="html"><![CDATA[<p>在 Ubuntu 上装了一个 Xfce 桌面，前段时间一直在使用 Xfce 桌面，今天切换回 GNOME 桌面以后，发现 google-chrome 无法上网了，说是代理服务器有问题，按照它的提示在设置中进行设置，结果打开代理服务器设置时，又出现下面的信息：</p>
<figure class="highlight livecodeserver">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">When running Google Chrome under <span class="keyword">a</span> supported desktop environment, <span class="keyword">the</span> <span class="keyword">system</span> proxy settings will be used. However, either your <span class="keyword">system</span> is <span class="keyword">not</span> supported <span class="keyword">or</span> there was <span class="keyword">a</span> problem launching your <span class="keyword">system</span> configuration.</div><div class="line"></div><div class="line">But you can still configure via <span class="keyword">the</span> <span class="keyword">command</span> <span class="title">line</span>. <span class="title">Please</span> <span class="title">see</span> <span class="title">man</span> <span class="title">google-chrome-stable</span> <span class="title">for</span> <span class="title">more</span> <span class="title">information</span> <span class="title">on</span> <span class="title">flags</span> <span class="title">and</span> <span class="title">environment</span> <span class="title">variables</span>.</div></pre>
      </td>
    </tr>
  </table>
</figure>
<a id="more"></a>
<p>因此，无法在浏览器中进行设置。</p>
<p>后来找到了解决办法：直接对桌面图标进行设置。</p>
<p>首先，在 root 下用 vim 编辑器打开 <code>/usr/share/applications/google-chrome.destop</code>，或者直接<code>sudo vim /usr/share/applications/google-chrome.destop</code></p>
<p>打开后显示下面的内容：</p>
<figure class="highlight ini">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="section">[Desktop Entry]</span></div><div class="line"><span class="attr">Version</span>=<span class="number">1.0</span></div><div class="line"><span class="attr">Name</span>=Google Chrome</div><div class="line"><span class="attr">GenericName</span>=Web Browser</div><div class="line"><span class="attr">Comment</span>=Access the Internet</div><div class="line"><span class="attr">Exec</span>=/usr/bin/google-chrome-stable %U</div><div class="line"><span class="attr">Terminal</span>=<span class="literal">false</span></div><div class="line"><span class="attr">Icon</span>=google-chrome</div><div class="line"><span class="attr">Type</span>=Application</div><div class="line"><span class="attr">Categories</span>=Network;WebBrowser;</div><div class="line"><span class="attr">MimeType</span>=text/html;text/xml;application/xhtml_xml;image/webp;x-scheme-handler/http;x-scheme-handler/https;x-scheme-handler/ftp;</div><div class="line"><span class="attr">Actions</span>=NewWindow;NewPrivateWindow;</div><div class="line"><span class="section"></span></div><div class="line">[Desktop Action NewWindow]</div><div class="line"><span class="attr">Name</span>=New Window</div><div class="line"><span class="attr">Exec</span>=/usr/bin/google-chrome-stable </div><div class="line"><span class="section"></span></div><div class="line">[Desktop Action NewPrivateWindow]</div><div class="line"><span class="attr">Name</span>=New Incognito Window</div><div class="line"><span class="attr">Exec</span>=/usr/bin/google-chrome-stable --incognito</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>在第六行的后面加上<code>--proxy-auto-detect</code>，变为如下：</p>
<figure class="highlight ini">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="section">[Desktop Entry]</span></div><div class="line"><span class="attr">Version</span>=<span class="number">1.0</span></div><div class="line"><span class="attr">Name</span>=Google Chrome</div><div class="line"><span class="attr">GenericName</span>=Web Browser</div><div class="line"><span class="attr">Comment</span>=Access the Internet</div><div class="line"><span class="attr">Exec</span>=/usr/bin/google-chrome-stable %U --proxy-auto-detect</div><div class="line"><span class="attr">Terminal</span>=<span class="literal">false</span></div><div class="line"><span class="attr">Icon</span>=google-chrome</div><div class="line"><span class="attr">Type</span>=Application</div><div class="line"><span class="attr">Categories</span>=Network;WebBrowser;</div><div class="line"><span class="attr">MimeType</span>=text/html;text/xml;application/xhtml_xml;image/webp;x-scheme-handler/http;x-scheme-handler/https;x-scheme-handler/ftp;</div><div class="line"><span class="attr">Actions</span>=NewWindow;NewPrivateWindow;</div><div class="line"><span class="section"></span></div><div class="line">[Desktop Action NewWindow]</div><div class="line"><span class="attr">Name</span>=New Window</div><div class="line"><span class="attr">Exec</span>=/usr/bin/google-chrome-stable </div><div class="line"><span class="section"></span></div><div class="line">[Desktop Action NewPrivateWindow]</div><div class="line"><span class="attr">Name</span>=New Incognito Window</div><div class="line"><span class="attr">Exec</span>=/usr/bin/google-chrome-stable --incognito</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>保存退出，再次打开 google-chrome，便可以正常上网了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Ubuntu 上装了一个 Xfce 桌面，前段时间一直在使用 Xfce 桌面，今天切换回 GNOME 桌面以后，发现 google-chrome 无法上网了，说是代理服务器有问题，按照它的提示在设置中进行设置，结果打开代理服务器设置时，又出现下面的信息：&lt;/p&gt;
&lt;figure class=&quot;highlight livecodeserver&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;
        &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;
      &lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;
        &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;When running Google Chrome under &lt;span class=&quot;keyword&quot;&gt;a&lt;/span&gt; supported desktop environment, &lt;span class=&quot;keyword&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;system&lt;/span&gt; proxy settings will be used. However, either your &lt;span class=&quot;keyword&quot;&gt;system&lt;/span&gt; is &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; supported &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; there was &lt;span class=&quot;keyword&quot;&gt;a&lt;/span&gt; problem launching your &lt;span class=&quot;keyword&quot;&gt;system&lt;/span&gt; configuration.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;But you can still configure via &lt;span class=&quot;keyword&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;line&lt;/span&gt;. &lt;span class=&quot;title&quot;&gt;Please&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;see&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;man&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;google-chrome-stable&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;more&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;information&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;flags&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;environment&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;variables&lt;/span&gt;.&lt;/div&gt;&lt;/pre&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
    
    </summary>
    
      <category term="Browser" scheme="http://ucasfl.me/categories/Browser/"/>
    
    
      <category term="Google-chrome proxy" scheme="http://ucasfl.me/tags/Google-chrome-proxy/"/>
    
  </entry>
  
  <entry>
    <title>Linux 文件系统概览</title>
    <link href="http://ucasfl.me/2017/09/23/Introduction-to-Linux-FileSystem/"/>
    <id>http://ucasfl.me/2017/09/23/Introduction-to-Linux-FileSystem/</id>
    <published>2017-09-23T04:48:42.000Z</published>
    <updated>2017-09-23T04:51:21.162Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/community-penguins-osdc-lead.png?itok=BmqsAF4A" alt="Introduction to Linux filesystems" title="Introduction to Linux filesystems"></p>
<p>本文旨在高屋建瓴地来讨论 Linux 文件系统概念，而不是对某种特定的文件系统，比如 EXT4 是如何工作的进行具体的描述。另外，本文也不是一个文件系统命令的教程。</p>
<p>每台通用计算机都需要将各种数据存储在硬盘驱动器（HDD）或其他类似设备上，比如 USB 存储器。这样做有两个原因。首先，当计算机关闭以后，内存（RAM）会失去存于它里面的内容。尽管存在非易失类型的 RAM，在计算机断电以后还能把数据存储下来（比如采用 USB 闪存和固态硬盘的闪存），但是，闪存和标准的、易失性的 RAM，比如 DDR3 以及其他相似类型的 RAM 相比，要贵很多。</p>
<p>数据需要存储在硬盘驱动上的另一个原因是，即使是标准的 RAM 也要比普通硬盘贵得多。尽管 RAM 和硬盘的价格都在迅速下降，但是 RAM 的价格依旧在以字节为单位来计算。让我们进行一个以字节为单位的快速计算：基于 16 GB 大的 RAM 的价格和 2 TB 大的硬盘驱动的价格。计算显示 RAM 的价格大约比硬盘驱动贵 71 倍。今天，一个典型的 RAM 的价格大约是 0.000000004373750 美元/每字节。</p>
<p>直观的展示一下在很久以前 RAM 的价格，在计算机发展的非常早的时期，其中一种类型的 RAM 是基于在 CRT 屏幕上的点。这种 RAM 非常昂贵，大约 1 美元/每字节。</p>
<a id="more"></a>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3>
<p>你可能听过其他人以各种不同和令人迷惑的方式谈论过文件系统。文件系统这个单词本身有多重含义，你需要从一个讨论或文件的上下文中理解它的正确含义。</p>
<p>我将根据我所观察到的在不同情况下使用“文件系统”这个词来定义它的不同含义。注意，尽管我试图遵循标准的“官方”含义，但是我打算基于它的不同用法来定义这个术语（如下）。这就是说我将在本文的后续章节中进行更详细的探讨。</p>
<ol>
  <li>始于顶层 root（/）目录的整个 Linux 目录结构。</li>
  <li>特定类型的数据存储格式，比如 EXT3、EXT4、BTRFS 以及 XFS 等等。Linux 支持近百种类型的文件系统，包括一些非常老的以及一些最新的。每一种文件系统类型都使用它自己独特的元数据结构来定义数据是如何存储和访问的。</li>
  <li>用特定类型的文件系统格式化后的分区或逻辑卷，可以挂载到 Linux 文件系统的指定挂载点上。</li>
</ol>
<h3 id="文件系统的基本功能"><a href="#文件系统的基本功能" class="headerlink" title="文件系统的基本功能"></a>文件系统的基本功能</h3>
<p>磁盘存储是文件系统必须的功能，它与之伴生的有一些有趣而且不可或缺的细节。很明显，文件系统是用来为非易失数据的存储提供空间，这是它的基本功能。然而，它还有许多从需求出发的重要功能。</p>
<p>所有文件系统都需要提供一个名字空间，这是一种命名和组织方法。它定义了文件应该如何命名、文件名的最大长度，以及所有可用字符集中可用于文件名中字符集子集。它也定义了一个磁盘上数据的逻辑结构，比如使用目录来组织文件而不是把所有文件聚集成一个单一的、巨大的文件混合体。</p>
<p>定义名字空间以后，元数据结构是为该名字空间提供逻辑基础所必须的。这包括所需数据结构要能够支持分层目录结构，同时能够通过结构来确定硬盘空间中的块是已用的或可用的，支持修改文件或目录的名字，提供关于文件大小、创建时间、最后访问或修改时间等信息，以及位置或数据所属的文件在磁盘空间中的位置。其他的元数据用来存储关于磁盘细分的高级信息，比如逻辑卷和分区。这种更高层次的元数据以及它所代表的结构包含描述文件系统存储在驱动器或分区中的信息，但与文件系统元数据无关，与之独立。</p>
<p>文件系统也需要一个应用程序接口（API），从而提供了对文件系统对象，比如文件和目录进行操作的系统功能调用的访问。API 也提供了诸如创建、移动和删除文件的功能。它也提供了算法来确定某些信息，比如文件存于文件系统中的位置。这样的算法可以用来解释诸如磁盘速度和最小化磁盘碎片等术语。</p>
<p>现代文件系统还提供一个安全模型，这是一个定义文件和目录的访问权限的方案。Linux 文件系统安全模型确保用户只能访问自己的文件，而不能访问其他用户的文件或操作系统本身。</p>
<p>最后一块组成部分是实现这些所有功能所需要的软件。Linux 使用两层软件实现的方式来提高系统和程序员的效率。</p>
<p><img src="https://opensource.com/sites/default/files/filesystem_diagram.png" alt=""></p>
<p><em>图片 1：Linux 两层文件系统软件实现。</em></p>
<p>这两层中的第一层是 Linux 虚拟文件系统。虚拟文件系统提供了内核和开发者访问所有类型文件系统的的单一命令集。虚拟文件系统软件通过调用特殊设备驱动来和不同类型的文件系统进行交互。特定文件系统的设备驱动是第二层实现。设备驱动程序将文件系统命令的标准集解释为在分区或逻辑卷上的特定类型文件系统命令。</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3>
<p>作为一个通常来说非常有条理的处女座，我喜欢将东西存储在更小的、有组织的小容器中，而不是存于同一个大容器中。目录的使用使我能够存储文件并在我想要查看这些文件的时候也能够找到它们。目录也被称为文件夹，之所以被称为文件夹，是因为其中的文件被类比存放于物理桌面上。</p>
<p>在 Linux 和其他许多操作系统中，目录可以被组织成树状的分层结构。在 <a href="http://www.pathname.com/fhs/" target="_blank" rel="external">Linux 文件系统层次标准</a>中定义了 Linux 的目录结构（LCTT 译注：可参阅<a href="https://linux.cn/article-6132-1.html" target="_blank" rel="external">这篇</a>）。当通过目录引用来访问目录时，更深层目录名字是通过正斜杠（/）来连接，从而形成一个序列，比如 <code>/var/log</code> 和 <code>/var/spool/mail</code>  。这些被称为路径。</p>
<p>下表提供了标准的、众所周知的、预定义的顶层 Linux 目录及其用途的简要清单。</p>
<table>
  <thead>
    <tr>
      <th>目录</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>/ (root 文件系统)</strong></td>
      <td>root 文件系统是文件系统的顶级目录。它必须包含在挂载其它文件系统前需要用来启动 Linux 系统的全部文件。它必须包含需要用来启动剩余文件系统的全部可执行文件和库。文件系统启动以后，所有其他文件系统作为 root 文件系统的子目录挂载到标准的、预定义好的挂载点上。</td>
    </tr>
    <tr>
      <td><strong>/bin</strong></td>
      <td><code>/bin</code> 目录包含用户的可执行文件。</td>
    </tr>
    <tr>
      <td>/boot</td>
      <td>包含启动 Linux 系统所需要的静态引导程序和内核可执行文件以及配置文件。</td>
    </tr>
    <tr>
      <td><strong>/dev</strong></td>
      <td>该目录包含每一个连接到系统的硬件设备的设备文件。这些文件不是设备驱动，而是代表计算机上的每一个计算机能够访问的设备。</td>
    </tr>
    <tr>
      <td><strong>/etc</strong></td>
      <td>包含主机计算机的本地系统配置文件。</td>
    </tr>
    <tr>
      <td>/home</td>
      <td>主目录存储用户文件，每一个用户都有一个位于 <code>/home</code> 目录中的子目录（作为其主目录）。</td>
    </tr>
    <tr>
      <td><strong>/lib</strong></td>
      <td>包含启动系统所需要的共享库文件。</td>
    </tr>
    <tr>
      <td>/media</td>
      <td>一个挂载外部可移动设备的地方，比如主机可能连接了一个 USB 驱动器。</td>
    </tr>
    <tr>
      <td>/mnt</td>
      <td>一个普通文件系统的临时挂载点（如不可移动的介质），当管理员对一个文件系统进行修复或在其上工作时可以使用。</td>
    </tr>
    <tr>
      <td>/opt</td>
      <td>可选文件，比如供应商提供的应用程序应该安装在这儿。</td>
    </tr>
    <tr>
      <td><strong>/root</strong></td>
      <td>这不是 root（<code>/</code>）文件系统。它是 root 用户的主目录。</td>
    </tr>
    <tr>
      <td><strong>/sbin</strong></td>
      <td>系统二进制文件。这些是用于系统管理的可执行文件。</td>
    </tr>
    <tr>
      <td>/tmp</td>
      <td>临时目录。被操作系统和许多程序用来存储临时文件。用户也可能临时在这儿存储文件。注意，存储在这儿的文件可能在任何时候在没有通知的情况下被删除。</td>
    </tr>
    <tr>
      <td>/usr</td>
      <td>该目录里面包含可共享的、只读的文件，包括可执行二进制文件和库、man 文件以及其他类型的文档。</td>
    </tr>
    <tr>
      <td>/var</td>
      <td>可变数据文件存储在这儿。这些文件包括日志文件、MySQL 和其他数据库的文件、Web 服务器的数据文件、邮件以及更多。</td>
    </tr>
  </tbody>
</table>
<p><em>表 1：Linux 文件系统层次结构的顶层</em></p>
<p>这些目录以及它们的子目录如表 1 所示，在所有子目录中，粗体的目录组成了 root 文件系统的必需部分。也就是说，它们不能创建为一个分离的文件系统并且在开机时进行挂载。这是因为它们（特别是它们包含的内容）必须在系统启动的时候出现，从而系统才能正确启动。</p>
<p><code>/media</code> 目录和 <code>/mnt</code> 目录是 root 文件系统的一部分，但是它们从来不包含任何数据，因为它们只是一个临时挂载点。</p>
<p>表 1 中剩下的非粗体的目录不需要在系统启动过程中出现，但会在之后挂载到 root 文件系统上，在开机阶段，它们为主机进行准备，从而执行有用的工作。</p>
<p>请参考官方 <a href="http://www.pathname.com/fhs/" target="_blank" rel="external">Linux 文件系统层次标准</a>（FHS）网页来了解这些每一个目录以及它们的子目录的更多细节。维基百科上也有关于 <a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard" target="_blank" rel="external">FHS</a> 的一个很好的介绍。应该尽可能的遵循这些标准，从而确保操作和功能的一致性。无论在主机上使用什么类型的文件系统，该层次目录结构都是相同的。</p>
<h3 id="Linux-统一目录结构"><a href="#Linux-统一目录结构" class="headerlink" title="Linux 统一目录结构"></a>Linux 统一目录结构</h3>
<p>在一些非 Linux 操作系统的个人电脑上，如果有多个物理硬盘驱动器或多个分区，每一个硬盘或分区都会分配一个驱动器号。知道文件或程序位于哪一个硬盘驱动器上是很有必要的，比如 <code>C:</code> 或 <code>D:</code> 。然后，你可以在命令中使用驱动器号，以 <code>D:</code> 为例，为了进入 <code>D:</code> 驱动器，你可以使用 <code>cd</code> 命令来更改工作目录为正确的目录，从而定位需要的文件。每一个硬盘驱动器都有自己单独的、完整的目录树。</p>
<p>Linux 文件系统将所有物理硬盘驱动器和分区统一为一个目录结构。它们均从顶层 root 目录（<code>/</code>）开始。所有其它目录以及它们的子目录均位于单一的 Linux 根目录下。这意味着只有一棵目录树来搜索文件和程序。</p>
<p>因为只有一个文件系统，所以 <code>/home</code>、<code>/tmp</code>、<code>/var</code>、<code>/opt</code> 或 <code>/usr</code> 能够创建在和 root（<code>/</code>）文件系统不同的物理硬盘驱动器、分区或逻辑分区上，然后挂载到一个挂载点（目录）上，从而作为 root 文件系统树的一部分。甚至可移动驱动器，比如 USB 驱动器或一个外接的 USB 或 ESATA 硬盘驱动器均可以挂载到 root 文件系统上，成为目录树不可或缺的部分。</p>
<p>当从 Linux 发行版的一个版本升级到另一个版本或从一个发行版更改到另一个发行版的时候，就会很清楚地看到这样创建到不同分区的好处。通常情况下，除了任何像 Fedora 中的 <code>dnf-upgrade</code> 之类的升级工具，会明智地在升级过程中偶尔重新格式化包含操作系统的硬盘驱动来删除那些长期积累的垃圾。如果 <code>/home</code> 目录是 root 文件系统的一部分（位于同一个硬盘驱动器），那么它也会被格式化，然后需要通过之前的备份恢复。如果 /home 目录作为一个分离的文件系统，那么安装程序将会识别到，并跳过它的格式化。对于存储数据库、邮箱、网页和其它可变的用户以及系统数据的
  <code>/var</code> 目录也是这样的。</p>
<p>将 Linux 系统目录树的某些部分作为一个分离的文件系统还有一些其他原因。比如，在很久以前，我还不知道将所有需要的 Linux 目录均作为 root（<code>/</code>）文件系统的一部分可能存在的问题，于是，一些非常大的文件填满了 <code>/home</code> 目录。因为 <code>/home</code> 目录和 <code>/tmp</code> 目录均不是分离的文件系统，而是 root 文件系统的简单子目录，整个 root 文件系统就被填满了。于是就不再有剩余空间可以让操作系统用来存储临时文件或扩展已存在数据文件。首先，应用程序开始抱怨没有空间来保存文件，然后，操作系统也开始异常行动。启动到单用户模式，并清除了
  <code>/home</code> 目录中的多余文件之后，终于又能够重新工作了。然后，我使用非常标准的多重文件系统设置来重新安装 Linux 系统，从而避免了系统崩溃的再次发生。</p>
<p>我曾经遇到一个情况，Linux 主机还在运行，但是却不允许用户通过 GUI 桌面登录。我可以通过使用<a href="https://en.wikipedia.org/wiki/Virtual_console" target="_blank" rel="external">虚拟控制台</a>之一，通过命令行界面（CLI）本地登录，然后远程使用 SSH 。问题的原因是因为 <code>/tmp</code> 文件系统满了，因此 GUI 桌面登录时所需要的一些临时文件不能被创建。因为命令行界面登录不需要在 <code>/tmp</code> 目录中创建文件，所以无可用空间并不会阻止我使用命令行界面来登录。在这种情况下，<code>/tmp</code>  目录是一个分离的文件系统，在 <code>/tmp</code> 所位于的逻辑卷上还有大量的可用空间。我简单地<a href="https://opensource.com/business/16/9/linux-users-guide-lvm" target="_blank" rel="external">扩展了 /tmp 逻辑卷</a>的容量到能够容纳主机所需要的临时文件，于是问题便解决了。注意，这个解决方法不需要重启，当 <code>/tmp</code> 文件系统扩大以后，用户就可以登录到桌面了。</p>
<p>当我在一家很大的科技公司当实验室管理员的时候，遇到过另外一个故障。开发者将一个应用程序安装到了一个错误的位置（<code>/var</code>）。结果该应用程序崩溃了，因为 <code>/var</code> 文件系统满了，由于缺乏空间，存储于 <code>/var/log</code> 中的日志文件无法附加新的日志消息。然而，系统仍然在运行，因为 root 文件系统和 <code>/tmp</code> 文件系统还没有被填满。删除了该应用程序并重新安装在 <code>/opt</code> 文件系统后，问题便解决了。</p>
<h3 id="文件系统类型"><a href="#文件系统类型" class="headerlink" title="文件系统类型"></a>文件系统类型</h3>
<p>Linux 系统支持大约 100 种分区类型的读取，但是只能对很少的一些进行创建和写操作。但是，可以挂载不同类型的文件系统在同一个 root 文件系统上，并且是很常见的。在这样的背景下，我们所说的文件系统一词是指在硬盘驱动器或逻辑卷上的一个分区中存储和管理用户数据所需要的结构和元数据。能够被 Linux 系统的 <code>fdisk</code> 命令识别的文件系统类型的完整列表<a href="https://www.win.tue.nl/~aeb/partitions/partition_types-1.html" target="_blank" rel="external">在此</a>，你可以感受一下
  Linux 系统对许多类型的系统的高度兼容性。David Both 居住在美国北卡罗纳州的首府罗利，是一个 Linux 开源贡献者。他已经从事 IT 行业 40 余年，在 IBM 教授 OS/2 20 余年。1981 年，他在 IBM 开发了第一个关于最初的 IBM 个人电脑的培训课程。他也曾在 Red Hat 教授 RHCE 课程，也曾供职于 MCI worldcom，Cico 以及北卡罗纳州等。他已经为 Linux 开源社区工作近 20 年。</p>
<p>Linux 支持读取这么多类型的分区系统的主要目的是为了提高兼容性，从而至少能够与一些其他计算机系统的文件系统进行交互。下面列出了在 Fedora 中创建一个新的文件系统时的所有可选类型：</p>
<ul>
  <li>btrfs</li>
  <li><strong>cramfs</strong></li>
  <li><strong>ext2</strong></li>
  <li><strong>ext3</strong></li>
  <li><strong>ext4</strong></li>
  <li>fat</li>
  <li>gfs2</li>
  <li>hfsplus</li>
  <li>minix</li>
  <li><strong>msdos</strong></li>
  <li>ntfs</li>
  <li>reiserfs</li>
  <li><strong>vfat</strong></li>
  <li>xfs</li>
</ul>
<p>其他发行版支持创建的文件系统类型不同。比如，CentOS 6 只支持创建上表中标为黑体的文件系统类型。</p>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3>
<p>在 Linux 系统上“<ruby>挂载<rt>mount</rt></ruby>”文件系统的术语是指在计算机发展的早期，磁带或可移动的磁盘组需要需要物理地挂载到一个合适的驱动器设备上。当通过物理的方式放置到驱动器上以后，操作系统会逻辑地挂载位于磁盘上的文件系统，从而操作系统、应用程序和用户才能够访问文件系统中的内容。</p>
<p>一个挂载点简单的来说就是一个目录，就像任何其它目录一样，是作为 root 文件系统的一部分创建的。所以，比如，home 文件系统是挂载在目录 <code>/home</code> 下。文件系统可以被挂载到其他非 root 文件系统的挂载点上，但是这并不常见。</p>
<p>在 Linux 系统启动阶段的最初阶段，root 文件系统就会被挂载到 root 目录下（<code>/</code>）。其它文件系统在之后通过 SystemV 下的 <code>rc</code> 或更新一些的 Linux 发行版中的 <code>systemd</code> 等 Linux 启动程序挂载。在启动进程中文件系统的挂载是由 <code>/etc/fstab</code> 配置文件管理的。一个简单的记忆方法是，fstab 代表“<ruby>文件系统表<rt>file system table</rt></ruby>”，它包含了需要挂载的文件系统的列表，这些文件系统均指定了挂载点，以及针对特定文件系统可能需要的选项。</p>
<p>使用 <code>mount</code> 命令可以把文件系统挂载到一个已有的目录/挂载点上。通常情况下，任何作为挂载点的目录都应该是空的且不包含任何其他文件。Linux 系统不会阻止用户挂载一个已被挂载了文件系统的目录或将文件系统挂载到一个包含文件的目录上。如果你将文件系统挂载到一个已有的目录或文件系统上，那么其原始内容将会被隐藏，只有新挂载的文件系统的内容是可见的。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3>
<p>我希望通过这篇文章，阐明了围绕文件系统这个术语的一些可能的模糊之处。我花费了很长的时间，以及在一个良师的帮助下才真正理解和欣赏到 Linux 文件系统的复杂性、优雅性和功能以及它的全部含义。</p>
<p>如果你有任何问题，请写到下面的评论中，我会尽力来回答它们。</p>
<h3 id="下个月"><a href="#下个月" class="headerlink" title="下个月"></a>下个月</h3>
<p>Linux 的另一个重要概念是：<a href="https://opensource.com/life/15/9/everything-is-a-file" target="_blank" rel="external">万物皆为文件</a>。这个概念对用户和系统管理员来说有一些有趣和重要的实际应用。当我说完这个理由之后，你可能会想阅读我的文章：<a href="https://opensource.com/life/15/9/everything-is-a-file" target="_blank" rel="external">万物皆为文件</a>，这篇文章会在我下个月计划写的关于 <code>/dev</code>  目录的文章之前写完。（LCTT 译注，也可参阅<a href="https://linux.cn/article-7669-1.html" target="_blank" rel="external">这篇</a>）</p>
<p>（题图 : 原始图片来自 Rikki Endsley. <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="external">CC BY-SA 4.0</a>）</p>
<hr>
<p>via: <a href="https://opensource.com/life/16/10/introduction-linux-filesystems" target="_blank" rel="external">https://opensource.com/life/16/10/introduction-linux-filesystems</a></p>
<p>作者：<a href="https://opensource.com/users/dboth" target="_blank" rel="external">David Both</a><br>译者：<a href="https://github.com/ucasFL" target="_blank" rel="external">ucasFL</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/community-penguins-osdc-lead.png?itok=BmqsAF4A&quot; alt=&quot;Introduction to Linux filesystems&quot; title=&quot;Introduction to Linux filesystems&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文旨在高屋建瓴地来讨论 Linux 文件系统概念，而不是对某种特定的文件系统，比如 EXT4 是如何工作的进行具体的描述。另外，本文也不是一个文件系统命令的教程。&lt;/p&gt;
&lt;p&gt;每台通用计算机都需要将各种数据存储在硬盘驱动器（HDD）或其他类似设备上，比如 USB 存储器。这样做有两个原因。首先，当计算机关闭以后，内存（RAM）会失去存于它里面的内容。尽管存在非易失类型的 RAM，在计算机断电以后还能把数据存储下来（比如采用 USB 闪存和固态硬盘的闪存），但是，闪存和标准的、易失性的 RAM，比如 DDR3 以及其他相似类型的 RAM 相比，要贵很多。&lt;/p&gt;
&lt;p&gt;数据需要存储在硬盘驱动上的另一个原因是，即使是标准的 RAM 也要比普通硬盘贵得多。尽管 RAM 和硬盘的价格都在迅速下降，但是 RAM 的价格依旧在以字节为单位来计算。让我们进行一个以字节为单位的快速计算：基于 16 GB 大的 RAM 的价格和 2 TB 大的硬盘驱动的价格。计算显示 RAM 的价格大约比硬盘驱动贵 71 倍。今天，一个典型的 RAM 的价格大约是 0.000000004373750 美元/每字节。&lt;/p&gt;
&lt;p&gt;直观的展示一下在很久以前 RAM 的价格，在计算机发展的非常早的时期，其中一种类型的 RAM 是基于在 CRT 屏幕上的点。这种 RAM 非常昂贵，大约 1 美元/每字节。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://ucasfl.me/categories/Linux/"/>
    
    
      <category term="FileSystem Linux" scheme="http://ucasfl.me/tags/FileSystem-Linux/"/>
    
  </entry>
  
  <entry>
    <title>C 语言中变量的段</title>
    <link href="http://ucasfl.me/2017/09/12/the-Section-of-Variables/"/>
    <id>http://ucasfl.me/2017/09/12/the-Section-of-Variables/</id>
    <published>2017-09-12T02:16:42.000Z</published>
    <updated>2017-09-12T02:27:19.318Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3>
<p>在 C 语言中，不同的变量位于不同的段，下面进行简单分析。</p>
<p>看下面一个简单的 C 程序：</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">char</span> *myname=<span class="string">"Bao Yungang"</span>;</div><div class="line"><span class="keyword">char</span> gdata[<span class="number">128</span>];</div><div class="line"><span class="keyword">char</span> bdata[<span class="number">16</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</div><div class="line">main() &#123;</div><div class="line">	<span class="keyword">char</span> * ldata[<span class="number">16</span>];	</div><div class="line">	<span class="keyword">char</span> * ddata;</div><div class="line"></div><div class="line">	ddata = <span class="built_in">malloc</span>(<span class="number">16</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"myname:%llX\n"</span>, myname);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"main: %llX\n"</span>, main);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"gdata: %llX\nbdata:%llX\nldata:%llx\n&amp;ddata:%llx\nddata: %llx\n"</span>,</div><div class="line">		gdata,bdata,ldata,&amp;ddata,ddata);</div><div class="line">	<span class="built_in">free</span>(ddata);</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>我们分析一下程序中出现的变量所位于的段。</p>
<a id="more"></a>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3>
<p>首先，根据所学知识进行分析：</p>
<ul>
  <li><code>myname</code> 变量是一个全局变量，并且进行了初始化，指向一个字符串常量。因此，<code>myname</code> 变量本身位于<em>数据段：</em><code>.data</code></li>
  <li><code>myname</code>所<strong>指向的字符串</strong>是一个字符串常量，根据 C 语言知识，是只读的，所以应位于<em>只读数据段：</em><code>.rodata</code></li>
  <li><code>gdata</code>是一个为进行初始化的全局变量，因此位于<em>BSS段（Block Started by Symbol）</em>。</li>
  <li><code>bdata</code>和<code>myname</code>一样是初始化了的全局变量，因此位于数据段。</li>
  <li><code>ldata</code>是一个<code>main</code>函数中的局部变量，因此位于<em>栈中。</em></li>
  <li><code>ddata</code>变量自身也是<code>main</code>函数中的一个局部变量，因此也位于<em>栈中。</em></li>
  <li><code>ddata</code>所<strong>指向的内存空间</strong>是通过<code>malloc</code>函数动态分配的，因此位于<em>堆中。</em></li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3>
<p>下面，通过<code>objdump</code>来进行验证：</p>
<p>首先，使用<code>gcc</code>来编译源程序(Ubuntu 16.04.4 + gcc 5.4.0)：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">gcc -save-temps addr_space.c</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>通过添加 <code>-save-temps</code>选项来生成中间文件。</p>
<p>下面，使用 <code>objdump</code> 来查看段信息：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">objdump -D ./a.out</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>通过<code>-D</code>选项显示出所有段的内容。</p>
<ul>
  <li>首先看<code>bdata</code> 和<code>myname</code> ，我们可以直接在 <code>.data</code> 段看到：</li>
</ul>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">Disassembly of section .data:</div><div class="line"></div><div class="line">0000000000601040 &lt;__data_start&gt;:</div><div class="line">	...</div><div class="line"></div><div class="line">0000000000601048 &lt;__dso_handle&gt;:</div><div class="line">	...</div><div class="line"></div><div class="line">0000000000601050 &lt;myname&gt;:</div><div class="line">  601050:	68 07 40 00 00       	pushq  $0x4007</div><div class="line">	...</div><div class="line"></div><div class="line">0000000000601060 &lt;bdata&gt;:</div><div class="line">  601060:	01 02                	add    %eax,(%rdx)</div><div class="line">  601062:	03 04 00             	add    (%rax,%rax,1),%eax</div><div class="line">	...</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>对于 <code>gdata</code> ，也可以直接在 <code>.bss</code> 段看到：</li>
</ul>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">Disassembly of section .bss:</div><div class="line"></div><div class="line">0000000000601080 &lt;completed.7585&gt;:</div><div class="line">	...</div><div class="line"></div><div class="line">00000000006010a0 &lt;gdata&gt;:</div><div class="line">	...</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>下面看<code>myname</code> 所指向的字符串常量。</li>
</ul>
<p>首先，运行程序，输出如下：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">myname:400768</div><div class="line">main: 400626</div><div class="line">gdata: 6010A0</div><div class="line">bdata:601060</div><div class="line">ldata:7ffc84068960</div><div class="line">ddata:1490010</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>由运行结果知，<code>myname</code>的值为 400768，它即为 <code>myname</code>所指向的字符串常量的地址。然后我们在 <code>objdump</code>的输出内容中搜索该地址，得到它位于 <code>.rodata</code>中：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">Disassembly of section .rodata:</div><div class="line"></div><div class="line">0000000000400760 &lt;_IO_stdin_used&gt;:</div><div class="line">  400760:	01 00                	add    %eax,(%rax)</div><div class="line">  400762:	02 00                	add    (%rax),%al</div><div class="line">  400764:	00 00                	add    %al,(%rax)</div><div class="line">  400766:	00 00                	add    %al,(%rax)</div><div class="line">  400768:	42 61                	rex.X (bad) </div><div class="line">  40076a:	6f                   	outsl  %ds:(%rsi),(%dx)</div><div class="line">  40076b:	20 59 75             	and    %bl,0x75(%rcx)</div><div class="line">  40076e:	6e                   	outsb  %ds:(%rsi),(%dx)</div><div class="line">  40076f:	67 61                	addr32 (bad) </div><div class="line">  400771:	6e                   	outsb  %ds:(%rsi),(%dx)</div><div class="line">  400772:	67 00 6d 79          	add    %ch,0x79(%ebp)</div><div class="line">  400776:	6e                   	outsb  %ds:(%rsi),(%dx)</div><div class="line">  400777:	61                   	(bad)  </div><div class="line">  400778:	6d                   	insl   (%dx),%es:(%rdi)</div><div class="line">  400779:	65 3a 25 6c 6c 58 0a 	cmp    %gs:0xa586c6c(%rip),%ah        # a9873ec &lt;_end+0xa3862cc&gt;</div><div class="line">  400780:	00 6d 61             	add    %ch,0x61(%rbp)</div><div class="line">  400783:	69 6e 3a 20 25 6c 6c 	imul   $0x6c6c2520,0x3a(%rsi),%ebp</div><div class="line">  40078a:	58                   	pop    %rax</div><div class="line">  40078b:	0a 00                	or     (%rax),%al</div><div class="line">  40078d:	00 00                	add    %al,(%rax)</div><div class="line">  40078f:	00 67 64             	add    %ah,0x64(%rdi)</div><div class="line">  400792:	61                   	(bad)  </div><div class="line">  400793:	74 61                	je     4007f6 &lt;__GNU_EH_FRAME_HDR+0x36&gt;</div><div class="line">  400795:	3a 20                	cmp    (%rax),%ah</div><div class="line">  400797:	25 6c 6c 58 0a       	and    $0xa586c6c,%eax</div><div class="line">  40079c:	62                   	(bad)  </div><div class="line">  40079d:	64 61                	fs (bad) </div><div class="line">  40079f:	74 61                	je     400802 &lt;__GNU_EH_FRAME_HDR+0x42&gt;</div><div class="line">  4007a1:	3a 25 6c 6c 58 0a    	cmp    0xa586c6c(%rip),%ah        # a987413 &lt;_end+0xa3862f3&gt;</div><div class="line">  4007a7:	6c                   	insb   (%dx),%es:(%rdi)</div><div class="line">  4007a8:	64 61                	fs (bad) </div><div class="line">  4007aa:	74 61                	je     40080d &lt;__GNU_EH_FRAME_HDR+0x4d&gt;</div><div class="line">  4007ac:	3a 25 6c 6c 78 0a    	cmp    0xa786c6c(%rip),%ah        # ab8741e &lt;_end+0xa5862fe&gt;</div><div class="line">  4007b2:	64 64 61             	fs fs (bad) </div><div class="line">  4007b5:	74 61                	je     400818 &lt;__GNU_EH_FRAME_HDR+0x58&gt;</div><div class="line">  4007b7:	3a 25 6c 6c 78 0a    	cmp    0xa786c6c(%rip),%ah        # ab87429 &lt;_end+0xa586309&gt;</div><div class="line">	...</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>因此，说明 <code>myname</code>指向的字符串常量位于 <code>.rodata</code> 中。事实上，看中间一栏，从 400768 开始，到 400772 的第一个数结束，其中的内容 <code>42 61 6f 20 59 75 6e 67 61 6e 67</code>对应的 ASCII 码就是字符串 “Bao Yungang” 。</p>
<ul>
  <li>对于 <code>ldata</code> 和 <code>ddata</code> 以及 <code>ddata</code> 所指向的分配空间，很难直接从 <code>objdump</code> 的输出中看出来。我们再把 <code>ddata</code>变量本身的地址也打印出来：</li>
</ul>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">myname:400768</div><div class="line">main: 400626</div><div class="line">gdata: 6010A0</div><div class="line">bdata:601060</div><div class="line">ldata:7ffe92607930</div><div class="line">&amp;ddata:7ffe92607928</div><div class="line">ddata: 221a010</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>我们看到，<code>ldata</code>和<code>ddata</code>的地址非常大，而 <code>ddata</code>所指向的分配空间的地址相对来说要小很多，这其实也一定程度上验证了我们的结论，根据我们已知的结论，在程序执行过程中，函数中的局部变量是在函数压栈以后，在栈中分配的，而 <code>malloc</code> 函数分配的空间则是在堆中进行分配的，而栈是从上往下长（高地址到低地址），堆则相反，是从下往上长（低地址到高地址），因此，栈中的变量地址较大，而堆中的则较小，所以，程序运行结果与之相符。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;
&lt;p&gt;在 C 语言中，不同的变量位于不同的段，下面进行简单分析。&lt;/p&gt;
&lt;p&gt;看下面一个简单的 C 程序：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;
        &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;
      &lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;
        &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *myname=&lt;span class=&quot;string&quot;&gt;&quot;Bao Yungang&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; gdata[&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; bdata[&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;main() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * ldata[&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;];	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * ddata;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	ddata = &lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;myname:%llX\n&quot;&lt;/span&gt;, myname);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;main: %llX\n&quot;&lt;/span&gt;, main);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;gdata: %llX\nbdata:%llX\nldata:%llx\n&amp;amp;ddata:%llx\nddata: %llx\n&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		gdata,bdata,ldata,&amp;amp;ddata,ddata);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(ddata);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;p&gt;我们分析一下程序中出现的变量所位于的段。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://ucasfl.me/categories/C-C/"/>
    
    
      <category term="C Section" scheme="http://ucasfl.me/tags/C-Section/"/>
    
  </entry>
  
  <entry>
    <title>编译器简介： 在 Siri 前时代如何与计算机对话</title>
    <link href="http://ucasfl.me/2017/09/12/Introduction-to-Compiler/"/>
    <id>http://ucasfl.me/2017/09/12/Introduction-to-Compiler/</id>
    <published>2017-09-12T02:16:15.000Z</published>
    <updated>2017-09-12T02:25:39.505Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pbs.twimg.com/media/C_5qf8aXkAAvSXC.jpg" alt="了解在编译器的世界里前端和后端的新意义"></p>
<p>简单说来，一个<ruby>编译器<rt>compiler</rt></ruby>不过是一个可以翻译其他程序的程序。传统的编译器可以把源代码翻译成你的计算机能够理解的可执行机器代码。（一些编译器将源代码翻译成别的程序语言，这样的编译器称为源到源翻译器或<ruby>转化器<rt>transpilers</rt></ruby>。）<a href="http://llvm.org/" target="_blank" rel="external">LLVM</a> 是一个广泛使用的编译器项目，包含许多模块化的编译工具。</p>
<p>传统的编译器设计包含三个部分：</p>
<p><img src="https://nicoleorchard.com/img/blog/compilers/compiler1.jpg" alt=""></p>
<ul>
  <li><ruby>前端<rt>Frontend</rt></ruby>将源代码翻译为<ruby>中间表示<rt>intermediate representation </rt></ruby> (IR)* 。<a href="http://clang.llvm.org/" target="_blank" rel="external">clang</a> 是 LLVM 中用于 C 家族语言的前端工具。</li>
  <li><ruby>优化器<rt>Optimizer</rt></ruby>分析 IR 然后将其转化为更高效的形式。<a href="http://llvm.org/docs/CommandGuide/opt.html" target="_blank" rel="external">opt</a> 是 LLVM 的优化工具。</li>
  <li><ruby>后端<rt>Backend</rt></ruby>通过将 IR 映射到目标硬件指令集从而生成机器代码。<a href="http://llvm.org/docs/CommandGuide/llc.html" target="_blank" rel="external">llc</a> 是 LLVM 的后端工具。</li>
</ul>
<p>注：LLVM 的 IR 是一种和汇编类似的低级语言。然而，它抽离了特定硬件信息。</p>
<a id="more"></a>
<h3 id="Hello-Compiler"><a href="#Hello-Compiler" class="headerlink" title="Hello, Compiler"></a>Hello, Compiler</h3>
<p>下面是一个打印 “Hello, Compiler!” 到标准输出的简单 C 程序。C 语法是人类可读的，但是计算机却不能理解，不知道该程序要干什么。我将通过三个编译阶段使该程序变成机器可执行的程序。</p>
<figure class="highlight cpp">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">// compile_me.c</span></div><div class="line"><span class="comment">// Wave to the compiler. The world can wait.</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Hello, Compiler!\n"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4>
<p>正如我在上面所提到的，<code>clang</code> 是 LLVM 中用于 C 家族语言的前端工具。Clang 包含 <ruby>C 预处理器<rt>C preprocessor</rt></ruby>、<ruby>词法分析器<rt>lexer</rt></ruby>、<ruby>语法解析器<rt>parser</rt></ruby>、<ruby>语义分析器<rt>semantic analyzer</rt></ruby>和 <ruby>IR 生成器<rt>IR generator</rt></ruby>。</p>
<p><strong>C 预处理器</strong>在将源程序翻译成 IR 前修改源程序。预处理器处理外部包含文件，比如上面的 <code>#include &lt;stdio.h&gt;</code>。 它将会把这一行替换为 <code>stdio.h</code> C 标准库文件的完整内容，其中包含 <code>printf</code> 函数的声明。</p>
<p>通过运行下面的命令来查看预处理步骤的输出：</p>
<figure class="highlight css">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="selector-tag">clang</span> <span class="selector-tag">-E</span> <span class="selector-tag">compile_me</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">preprocessed</span><span class="selector-class">.i</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>词法分析器</strong>（或<ruby>扫描器<rt>scanner</rt></ruby>或<ruby>分词器<rt>tokenizer</rt></ruby>）将一串字符转化为一串单词。每一个单词或<ruby>记号<rt>token</rt></ruby>，被归并到五种语法类别之一：标点符号、关键字、标识符、文字或注释。</p>
<p>compile_me.c 的分词过程：</p>
<p><img src="https://nicoleorchard.com/img/blog/compilers/lexer.jpg" alt=""></p>
<p><strong>语法分析器</strong>确定源程序中的单词流是否组成了合法的句子。在分析记号流的语法后，它会输出一个<ruby>抽象语法树<rt>abstract syntax tree</rt></ruby>（AST）。Clang 的 AST 中的节点表示声明、语句和类型。</p>
<p>compile_me.c 的语法树：</p>
<p><img src="https://nicoleorchard.com/img/blog/compilers/tree.jpg" alt=""></p>
<p><strong>语义分析器</strong>会遍历抽象语法树，从而确定代码语句是否有正确意义。这个阶段会检查类型错误。如果 <code>compile_me.c</code> 的 main 函数返回 <code>&quot;zero&quot;</code>而不是 <code>0</code>， 那么语义分析器将会抛出一个错误，因为 <code>&quot;zero&quot;</code> 不是 <code>int</code> 类型。</p>
<p><strong>IR 生成器</strong>将抽象语法树翻译为 IR。</p>
<p>对 compile_me.c 运行 clang 来生成 LLVM IR：</p>
<figure class="highlight css">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="selector-tag">clang</span> <span class="selector-tag">-S</span> <span class="selector-tag">-emit-llvm</span> <span class="selector-tag">-o</span> <span class="selector-tag">llvm_ir</span><span class="selector-class">.ll</span> <span class="selector-tag">compile_me</span><span class="selector-class">.c</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>在 <code>llvm_ir.ll</code> 中的 main 函数：</p>
<figure class="highlight llvm">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">; llvm_ir.ll</span></div><div class="line"><span class="title">@.str</span> = <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">18</span> <span class="keyword">x</span> <span class="keyword">i8</span>] <span class="keyword">c</span><span class="string">"Hello, Compiler!\0A\00"</span>, <span class="keyword">align</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">define</span> <span class="keyword">i32</span> <span class="title">@main</span>() &#123;</div><div class="line">  <span class="symbol">%1</span> = <span class="keyword">alloca</span> <span class="keyword">i32</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- memory allocated on the stack</span></div><div class="line">  <span class="keyword">store</span> <span class="keyword">i32</span> <span class="number">0</span>, <span class="keyword">i32</span>* <span class="symbol">%1</span>, <span class="keyword">align</span> <span class="number">4</span></div><div class="line">  <span class="symbol">%2</span> = <span class="keyword">call</span> <span class="keyword">i32</span> (<span class="keyword">i8</span>*, ...) <span class="title">@printf</span>(<span class="keyword">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">18</span> <span class="keyword">x</span> <span class="keyword">i8</span>], [<span class="number">18</span> <span class="keyword">x</span> <span class="keyword">i8</span>]* <span class="title">@.str</span>, <span class="keyword">i32</span> <span class="number">0</span>, <span class="keyword">i32</span> <span class="number">0</span>))</div><div class="line">  <span class="keyword">ret</span> <span class="keyword">i32</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">declare</span> <span class="keyword">i32</span> <span class="title">@printf</span>(<span class="keyword">i8</span>*, ...)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h4 id="优化程序"><a href="#优化程序" class="headerlink" title="优化程序"></a>优化程序</h4>
<p>优化程序的工作是基于其对程序的运行时行为的理解来提高代码效率。优化程序将 IR 作为输入，然后生成改进后的 IR 作为输出。LLVM 的优化工具 <code>opt</code> 将会通过标记 <code>-O2</code>（大写字母 <code>o</code>，数字 2）来优化处理器速度，通过标记 <code>Os</code>（大写字母 <code>o</code>，小写字母 <code>s</code>）来减少指令数目。</p>
<p>看一看上面的前端工具生成的 LLVM IR 代码和运行下面的命令生成的结果之间的区别：</p>
<figure class="highlight vim">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">opt</span> -O2 -S llvm_ir.<span class="keyword">ll</span> -<span class="keyword">o</span> optimized.<span class="keyword">ll</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>在 <code>optimized.ll</code> 中的 main 函数：</p>
<figure class="highlight llvm">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">optimized.ll</div><div class="line"></div><div class="line"><span class="title">@str</span> = <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">17</span> <span class="keyword">x</span> <span class="keyword">i8</span>] <span class="keyword">c</span><span class="string">"Hello, Compiler!\00"</span></div><div class="line"></div><div class="line"><span class="keyword">define</span> <span class="keyword">i32</span> <span class="title">@main</span>() &#123;</div><div class="line">  <span class="symbol">%puts</span> = <span class="keyword">tail</span> <span class="keyword">call</span> <span class="keyword">i32</span> <span class="title">@puts</span>(<span class="keyword">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">17</span> <span class="keyword">x</span> <span class="keyword">i8</span>], [<span class="number">17</span> <span class="keyword">x</span> <span class="keyword">i8</span>]* <span class="title">@str</span>, <span class="keyword">i64</span> <span class="number">0</span>, <span class="keyword">i64</span> <span class="number">0</span>))</div><div class="line">  <span class="keyword">ret</span> <span class="keyword">i32</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">declare</span> <span class="keyword">i32</span> <span class="title">@puts</span>(<span class="keyword">i8</span>* <span class="keyword">nocapture</span> <span class="keyword">readonly</span>)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>优化后的版本中， main 函数没有在栈中分配内存，因为它不使用任何内存。优化后的代码中调用 <code>puts</code> 函数而不是 <code>printf</code> 函数，因为程序中并没有使用 <code>printf</code> 函数的格式化功能。</p>
<p>当然，优化程序不仅仅知道何时可以把 <code>printf</code> 函数用 <code>puts</code> 函数代替。优化程序也能展开循环并内联简单计算的结果。考虑下面的程序，它将两个整数相加并打印出结果。</p>
<figure class="highlight cpp">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">// add.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>, c = a + b;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%i + %i = %i\n"</span>, a, b, c);</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>下面是未优化的 LLVM IR：</p>
<figure class="highlight llvm">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="title">@.str</span> = <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">14</span> <span class="keyword">x</span> <span class="keyword">i8</span>] <span class="keyword">c</span><span class="string">"%i + %i = %i\0A\00"</span>, <span class="keyword">align</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">define</span> <span class="keyword">i32</span> <span class="title">@main</span>() &#123;</div><div class="line">  <span class="symbol">%1</span> = <span class="keyword">alloca</span> <span class="keyword">i32</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- allocate stack space for var a</span></div><div class="line">  <span class="symbol">%2</span> = <span class="keyword">alloca</span> <span class="keyword">i32</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- allocate stack space for var b</span></div><div class="line">  <span class="symbol">%3</span> = <span class="keyword">alloca</span> <span class="keyword">i32</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- allocate stack space for var c</span></div><div class="line">  <span class="keyword">store</span> <span class="keyword">i32</span> <span class="number">5</span>, <span class="keyword">i32</span>* <span class="symbol">%1</span>, <span class="keyword">align</span> <span class="number">4</span>  <span class="comment">; &lt;- store 5 at memory location %1</span></div><div class="line">  <span class="keyword">store</span> <span class="keyword">i32</span> <span class="number">10</span>, <span class="keyword">i32</span>* <span class="symbol">%2</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- store 10 at memory location %2</span></div><div class="line">  <span class="symbol">%4</span> = <span class="keyword">load</span> <span class="keyword">i32</span>, <span class="keyword">i32</span>* <span class="symbol">%1</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- load the value at memory address %1 into register %4</span></div><div class="line">  <span class="symbol">%5</span> = <span class="keyword">load</span> <span class="keyword">i32</span>, <span class="keyword">i32</span>* <span class="symbol">%2</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- load the value at memory address %2 into register %5</span></div><div class="line">  <span class="symbol">%6</span> = <span class="keyword">add</span> <span class="keyword">nsw</span> <span class="keyword">i32</span> <span class="symbol">%4</span>, <span class="symbol">%5</span> <span class="comment">; &lt;- add the values in registers %4 and %5\. put the result in register %6</span></div><div class="line">  <span class="keyword">store</span> <span class="keyword">i32</span> <span class="symbol">%6</span>, <span class="keyword">i32</span>* <span class="symbol">%3</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- put the value of register %6 into memory address %3</span></div><div class="line">  <span class="symbol">%7</span> = <span class="keyword">load</span> <span class="keyword">i32</span>, <span class="keyword">i32</span>* <span class="symbol">%1</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- load the value at memory address %1 into register %7</span></div><div class="line">  <span class="symbol">%8</span> = <span class="keyword">load</span> <span class="keyword">i32</span>, <span class="keyword">i32</span>* <span class="symbol">%2</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- load the value at memory address %2 into register %8</span></div><div class="line">  <span class="symbol">%9</span> = <span class="keyword">load</span> <span class="keyword">i32</span>, <span class="keyword">i32</span>* <span class="symbol">%3</span>, <span class="keyword">align</span> <span class="number">4</span> <span class="comment">; &lt;- load the value at memory address %3 into register %9</span></div><div class="line">  <span class="symbol">%10</span> = <span class="keyword">call</span> <span class="keyword">i32</span> (<span class="keyword">i8</span>*, ...) <span class="title">@printf</span>(<span class="keyword">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">14</span> <span class="keyword">x</span> <span class="keyword">i8</span>], [<span class="number">14</span> <span class="keyword">x</span> <span class="keyword">i8</span>]* <span class="title">@.str</span>, <span class="keyword">i32</span> <span class="number">0</span>, <span class="keyword">i32</span> <span class="number">0</span>), <span class="keyword">i32</span> <span class="symbol">%7</span>, <span class="keyword">i32</span> <span class="symbol">%8</span>, <span class="keyword">i32</span> <span class="symbol">%9</span>)</div><div class="line">  <span class="keyword">ret</span> <span class="keyword">i32</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">declare</span> <span class="keyword">i32</span> <span class="title">@printf</span>(<span class="keyword">i8</span>*, ...)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>下面是优化后的 LLVM IR：</p>
<figure class="highlight llvm">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="title">@.str</span> = <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">14</span> <span class="keyword">x</span> <span class="keyword">i8</span>] <span class="keyword">c</span><span class="string">"%i + %i = %i\0A\00"</span>, <span class="keyword">align</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">define</span> <span class="keyword">i32</span> <span class="title">@main</span>() &#123;</div><div class="line">  <span class="symbol">%1</span> = <span class="keyword">tail</span> <span class="keyword">call</span> <span class="keyword">i32</span> (<span class="keyword">i8</span>*, ...) <span class="title">@printf</span>(<span class="keyword">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">14</span> <span class="keyword">x</span> <span class="keyword">i8</span>], [<span class="number">14</span> <span class="keyword">x</span> <span class="keyword">i8</span>]* <span class="title">@.str</span>, <span class="keyword">i64</span> <span class="number">0</span>, <span class="keyword">i64</span> <span class="number">0</span>), <span class="keyword">i32</span> <span class="number">5</span>, <span class="keyword">i32</span> <span class="number">10</span>, <span class="keyword">i32</span> <span class="number">15</span>)</div><div class="line">  <span class="keyword">ret</span> <span class="keyword">i32</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">declare</span> <span class="keyword">i32</span> <span class="title">@printf</span>(<span class="keyword">i8</span>* <span class="keyword">nocapture</span> <span class="keyword">readonly</span>, ...)</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>优化后的 main 函数本质上是未优化版本的第 17 行和 18 行，伴有变量值内联。<code>opt</code> 计算加法，因为所有的变量都是常数。很酷吧，对不对？</p>
<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4>
<p>LLVM 的后端工具是 <code>llc</code>。它分三个阶段将 LLVM IR 作为输入生成机器代码。</p>
<ul>
  <li><strong>指令选择</strong>是将 IR 指令映射到目标机器的指令集。这个步骤使用虚拟寄存器的无限名字空间。</li>
  <li><strong>寄存器分配</strong>是将虚拟寄存器映射到目标体系结构的实际寄存器。我的 CPU 是 x86 结构，它只有 16 个寄存器。然而，编译器将会尽可能少的使用寄存器。</li>
  <li><strong>指令安排</strong>是重排操作，从而反映出目标机器的性能约束。</li>
</ul>
<p>运行下面这个命令将会产生一些机器代码：</p>
<figure class="highlight css">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="selector-tag">llc</span> <span class="selector-tag">-o</span> <span class="selector-tag">compiled-assembly</span><span class="selector-class">.s</span> <span class="selector-tag">optimized</span><span class="selector-class">.ll</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<figure class="highlight cos">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">_main:</div><div class="line">	pushq	<span class="built_in">%rbp</span></div><div class="line">	movq	<span class="built_in">%rsp</span>, <span class="built_in">%rbp</span></div><div class="line">	leaq	L_str(<span class="built_in">%rip</span>), <span class="built_in">%rdi</span></div><div class="line">	callq	_puts</div><div class="line">	xorl	<span class="built_in">%eax</span>, <span class="built_in">%eax</span></div><div class="line">	popq	<span class="built_in">%rbp</span></div><div class="line">	retq</div><div class="line">L_str:</div><div class="line">	.asciz	<span class="string">"Hello, Compiler!"</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>这个程序是 x86 汇编语言，它是计算机所说的语言，并具有人类可读语法。某些人最后也许能理解我。</p>
<hr>
<p>相关资源：</p>
<ol>
  <li><a href="https://www.amazon.com/Engineering-Compiler-Second-Keith-Cooper/dp/012088478X" target="_blank" rel="external">设计一个编译器</a></li>
  <li><a href="https://www.amazon.com/Getting-Started-LLVM-Core-Libraries/dp/1782166920" target="_blank" rel="external">开始探索 LLVM 核心库</a></li>
</ol>
<hr>
<p>via: <a href="https://nicoleorchard.com/blog/compilers" target="_blank" rel="external">https://nicoleorchard.com/blog/compilers</a></p>
<p>作者：<a href="https://nicoleorchard.com/" target="_blank" rel="external">Nicole Orchard</a><br>译者：<a href="https://github.com/ucasFL" target="_blank" rel="external">ucasFL</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://pbs.twimg.com/media/C_5qf8aXkAAvSXC.jpg&quot; alt=&quot;了解在编译器的世界里前端和后端的新意义&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单说来，一个&lt;ruby&gt;编译器&lt;rt&gt;compiler&lt;/rt&gt;&lt;/ruby&gt;不过是一个可以翻译其他程序的程序。传统的编译器可以把源代码翻译成你的计算机能够理解的可执行机器代码。（一些编译器将源代码翻译成别的程序语言，这样的编译器称为源到源翻译器或&lt;ruby&gt;转化器&lt;rt&gt;transpilers&lt;/rt&gt;&lt;/ruby&gt;。）&lt;a href=&quot;http://llvm.org/&quot;&gt;LLVM&lt;/a&gt; 是一个广泛使用的编译器项目，包含许多模块化的编译工具。&lt;/p&gt;
&lt;p&gt;传统的编译器设计包含三个部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nicoleorchard.com/img/blog/compilers/compiler1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;ruby&gt;前端&lt;rt&gt;Frontend&lt;/rt&gt;&lt;/ruby&gt;将源代码翻译为&lt;ruby&gt;中间表示&lt;rt&gt;intermediate representation &lt;/rt&gt;&lt;/ruby&gt; (IR)* 。&lt;a href=&quot;http://clang.llvm.org/&quot;&gt;clang&lt;/a&gt; 是 LLVM 中用于 C 家族语言的前端工具。&lt;/li&gt;
  &lt;li&gt;&lt;ruby&gt;优化器&lt;rt&gt;Optimizer&lt;/rt&gt;&lt;/ruby&gt;分析 IR 然后将其转化为更高效的形式。&lt;a href=&quot;http://llvm.org/docs/CommandGuide/opt.html&quot;&gt;opt&lt;/a&gt; 是 LLVM 的优化工具。&lt;/li&gt;
  &lt;li&gt;&lt;ruby&gt;后端&lt;rt&gt;Backend&lt;/rt&gt;&lt;/ruby&gt;通过将 IR 映射到目标硬件指令集从而生成机器代码。&lt;a href=&quot;http://llvm.org/docs/CommandGuide/llc.html&quot;&gt;llc&lt;/a&gt; 是 LLVM 的后端工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：LLVM 的 IR 是一种和汇编类似的低级语言。然而，它抽离了特定硬件信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Compiler" scheme="http://ucasfl.me/categories/Compiler/"/>
    
    
      <category term="Compiler LLVM" scheme="http://ucasfl.me/tags/Compiler-LLVM/"/>
    
  </entry>
  
  <entry>
    <title>Npm 安装 Hexo 失败的解决办法</title>
    <link href="http://ucasfl.me/2017/09/02/Fix-Error-With-Install-Hexo/"/>
    <id>http://ucasfl.me/2017/09/02/Fix-Error-With-Install-Hexo/</id>
    <published>2017-09-02T05:12:32.000Z</published>
    <updated>2017-09-04T08:28:14.369Z</updated>
    
    <content type="html"><![CDATA[<p>用 npm 安装 Hexo 时候出现错误，使用 sudo 安装依旧不行。</p>
<p>错误如下：</p>
<a id="more"></a>
<figure class="highlight livescript">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">/usr/local/bin/hexo<span class="function"> -&gt;</span> /usr/local/lib/node_modules/hexo-cli/bin/hexo</div><div class="line"></div><div class="line">&gt; dtrace-provider@<span class="number">0.8</span>.<span class="number">5</span> install /usr/local/lib/node_modules/hexo-cli/node_modules/dtrace-provider</div><div class="line">&gt; node scripts/install.js</div><div class="line"></div><div class="line"></div><div class="line">&gt; hexo-util@<span class="number">0.6</span>.<span class="number">1</span> postinstall /usr/local/lib/node_modules/hexo-cli/node_modules/hexo-util</div><div class="line">&gt; <span class="built_in">npm</span> run build:highlight</div><div class="line"></div><div class="line"></div><div class="line">&gt; hexo-util@<span class="number">0.6</span>.<span class="number">1</span> build:highlight /usr/local/lib/node_modules/hexo-cli/node_modules/hexo-util</div><div class="line">&gt; node scripts/build_highlight_alias.js &gt; highlight_alias.json</div><div class="line"></div><div class="line">sh: <span class="number">1</span>: cannot create highlight_alias.json: Permission denied</div><div class="line"><span class="built_in">npm</span> ERR! code ELIFECYCLE</div><div class="line"><span class="built_in">npm</span> ERR! errno <span class="number">2</span></div><div class="line"><span class="built_in">npm</span> ERR! hexo-util@<span class="number">0.6</span>.<span class="number">1</span> build:highlight: `node scripts/build_highlight_alias.js &gt; highlight_alias.json`</div><div class="line"><span class="built_in">npm</span> ERR! Exit status <span class="number">2</span></div><div class="line"><span class="built_in">npm</span> ERR! </div><div class="line"><span class="built_in">npm</span> ERR! Failed at the hexo-util@<span class="number">0.6</span>.<span class="number">1</span> build:highlight script.</div><div class="line"><span class="built_in">npm</span> ERR! This <span class="keyword">is</span> probably <span class="keyword">not</span> a problem <span class="keyword">with</span> <span class="built_in">npm</span>. There <span class="keyword">is</span> likely additional logging output above.</div><div class="line"></div><div class="line">┌──────────────────────────────────────────────────────────┐</div><div class="line">│                 <span class="built_in">npm</span> update check failed                  │</div><div class="line">│           Try running <span class="keyword">with</span> sudo <span class="keyword">or</span> get access            │</div><div class="line">│           <span class="keyword">to</span> the local update config store via           │</div><div class="line">│ sudo chown -R $USER:$(id -gn $USER) <span class="regexp">/home/fenglv/</span>.config │</div><div class="line">└──────────────────────────────────────────────────────────┘</div><div class="line"></div><div class="line"><span class="built_in">npm</span> ERR! A complete log <span class="keyword">of</span> <span class="keyword">this</span> run can be found in:</div><div class="line"><span class="built_in">npm</span> ERR!     <span class="regexp">/home/fenglv/</span>.<span class="built_in">npm</span>/_logs/<span class="number">2017</span>-<span class="number">09</span>-<span class="number">02</span>T05_00_49_566Z-debug.log</div><div class="line"><span class="built_in">npm</span> WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@<span class="number">1.1</span>.<span class="number">2</span> (node_modules/hexo-cli/node_modules/fsevents):</div><div class="line"><span class="built_in">npm</span> WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform <span class="keyword">for</span> fsevents@<span class="number">1.1</span>.<span class="number">2</span>: wanted &#123;<span class="string">"os"</span>:<span class="string">"darwin"</span>,<span class="string">"arch"</span>:<span class="string">"any"</span>&#125; (current: &#123;<span class="string">"os"</span>:<span class="string">"linux"</span>,<span class="string">"arch"</span>:<span class="string">"x64"</span>&#125;)</div><div class="line"></div><div class="line"><span class="built_in">npm</span> ERR! code ELIFECYCLE</div><div class="line"><span class="built_in">npm</span> ERR! errno <span class="number">2</span></div><div class="line"><span class="built_in">npm</span> ERR! hexo-util@<span class="number">0.6</span>.<span class="number">1</span> postinstall: `<span class="built_in">npm</span> run build:highlight`</div><div class="line"><span class="built_in">npm</span> ERR! Exit status <span class="number">2</span></div><div class="line"><span class="built_in">npm</span> ERR! </div><div class="line"><span class="built_in">npm</span> ERR! Failed at the hexo-util@<span class="number">0.6</span>.<span class="number">1</span> postinstall script.</div><div class="line"><span class="built_in">npm</span> ERR! This <span class="keyword">is</span> probably <span class="keyword">not</span> a problem <span class="keyword">with</span> <span class="built_in">npm</span>. There <span class="keyword">is</span> likely additional logging output above.</div><div class="line"></div><div class="line"><span class="built_in">npm</span> ERR! A complete log <span class="keyword">of</span> <span class="keyword">this</span> run can be found in:</div><div class="line"><span class="built_in">npm</span> ERR!     <span class="regexp">/home/fenglv/</span>.<span class="built_in">npm</span>/_logs/<span class="number">2017</span>-<span class="number">09</span>-<span class="number">02</span>T05_00_53_335Z-debug.log</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>解决办法：参见<a href="https://docs.npmjs.com/getting-started/fixing-npm-permissions" target="_blank" rel="external">npm 官网</a></p>
<figure class="highlight bash">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">sudo chown -R <span class="variable">$USER</span> $(npm config get prefix)/&#123;lib/node_modules,bin,share&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>问题解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 npm 安装 Hexo 时候出现错误，使用 sudo 安装依旧不行。&lt;/p&gt;
&lt;p&gt;错误如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://ucasfl.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://ucasfl.me/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>听说过时间表，但是你是否知道“哈希表”</title>
    <link href="http://ucasfl.me/2017/09/02/Hash-Tables/"/>
    <id>http://ucasfl.me/2017/09/02/Hash-Tables/</id>
    <published>2017-09-02T04:44:26.000Z</published>
    <updated>2017-09-02T04:55:22.911Z</updated>
    
    <content type="html"><![CDATA[<p>探索<ruby>哈希表<rt>hash table</rt></ruby>的世界并理解其底层的机制是非常有趣的，并且将会受益匪浅。所以，让我们了解它，并从头开始探索吧。</p>
<p>哈希表是许多现代软件应用程序中一种常见的数据结构。它提供了类似字典的功能，使你能够在其中执行插入、删除和删除等操作。这么说吧，比如我想找出“苹果”的定义是什么，并且我知道该定义被存储在了我定义的哈希表中。我将查询我的哈希表来得到定义。它在哈希表内的记录看起来可能像：<code>&quot;苹果&quot; =&gt; &quot;一种拥有水果之王之称的绿色水果&quot;</code>。这里，“苹果”是我的关键字，而“一种拥有水果之王之称的水果”是与之关联的值。</p>
<a id="more"></a>
<p>还有一个例子可以让我们更清楚，哈希表的内容如下：</p>
<figure class="highlight coq">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="string">"面包"</span> =&gt; <span class="string">"固体"</span></div><div class="line"><span class="string">"水"</span> =&gt; <span class="string">"液体"</span></div><div class="line"><span class="string">"汤"</span> =&gt; <span class="string">"液体"</span></div><div class="line"><span class="string">"玉米片"</span> =&gt; <span class="string">"固体"</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>我想知道<em>面包</em>是固体还是液体，所以我将查询哈希表来获取与之相关的值，该哈希表将返回“固体”给我。现在，我们大致了解了哈希表是如何工作的。使用哈希表需要注意的另一个重要概念是每一个关键字都是唯一的。如果到了明天，我拥有一个面包奶昔（它是液体），那么我们需要更新哈希表，把“固体”改为“液体”来反映哈希表的改变。所以，我们需要添加一条记录到字典中：关键字为“面包”，对应的值为“液体”。你能发现下面的表发生了什么变化吗？（LCTT 译注：不知道这个“面包奶昔”是一种什么食物，大约是一种面包做的奶昔，总之你就理解成作者把液体的“面包奶昔”当成一种面包吧。）</p>
<figure class="highlight coq">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="string">"面包"</span> =&gt; <span class="string">"液体"</span></div><div class="line"><span class="string">"水"</span> =&gt; <span class="string">"液体"</span></div><div class="line"><span class="string">"汤"</span> =&gt; <span class="string">"液体"</span></div><div class="line"><span class="string">"玉米片"</span> =&gt; <span class="string">"固体"</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>没错，“面包”对应的值被更新为了“液体”。</p>
<p><strong>关键字是唯一的</strong>，我的面包不能既是液体又是固体。但是，是什么使得该数据结构与其他数据结构相比如此特殊呢？为什么不使用一个<a href="https://en.wikipedia.org/wiki/Array_data_type" target="_blank" rel="external">数组</a>来代替呢？它取决于问题的本质。对于某一个特定的问题，使用数组来描述可能会更好，因此，我们需要注意的关键点就是，<strong>我们应该选择最适合问题的数据结构</strong>。例如，如果你需要做的只是存储一个简单的杂货列表，那么使用数组会很适合。考虑下面的两个问题，两个问题的本质完全不同。</p>
<ol>
  <li>我需要一个水果的列表</li>
  <li>我需要一个水果的列表以及各种水果的价格（每千克）</li>
</ol>
<p>正如你在下面所看到的，用数组来存储水果的列表可能是更好的选择。但是，用哈希表来存储每一种水果的价格看起来是更好的选择。</p>
<figure class="highlight ada">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">//示例数组</div><div class="line">[<span class="string">"苹果"</span>, <span class="string">"桔子"</span>, <span class="string">"梨子"</span>, <span class="string">"葡萄"</span>]   </div><div class="line">//示例哈希表  </div><div class="line">&#123; <span class="string">"苹果"</span> : 3.05,</div><div class="line">  <span class="string">"桔子"</span> : 5.5,</div><div class="line">  <span class="string">"梨子"</span> : 8.4,</div><div class="line">  <span class="string">"葡萄"</span> : 12.4  </div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>实际上，有许多的机会需要<a href="https://en.wikipedia.org/wiki/Hash_table#Uses" target="_blank" rel="external">使用</a>哈希表。</p>
<h3 id="时间以及它对你的意义"><a href="#时间以及它对你的意义" class="headerlink" title="时间以及它对你的意义"></a>时间以及它对你的意义</h3>
<p><a href="https://www.hackerearth.com/practice/basic-programming/complexity-analysis/time-and-space-complexity/tutorial/" target="_blank" rel="external">这是对时间复杂度和空间复杂度的一个复习</a>。</p>
<p>平均情况下，在哈希表中进行搜索、插入和删除记录的时间复杂度均为 <code>O(1)</code> 。实际上，<code>O(1)</code> 读作“大 O 1”，表示常数时间。这意味着执行每一种操作的运行时间不依赖于数据集中数据的数量。我可以保证，查找、插入和删除项目均只花费常数时间，“当且仅当”哈希表的实现方式正确时。如果实现不正确，可能需要花费很慢的 <code>O(n)</code> 时间，尤其是当所有的数据都映射到了哈希表中的同一位置/点。</p>
<h3 id="构建一个好的哈希表"><a href="#构建一个好的哈希表" class="headerlink" title="构建一个好的哈希表"></a>构建一个好的哈希表</h3>
<p>到目前为止，我们已经知道如何使用哈希表了，但是如果我们想<strong>构建</strong>一个哈希表呢？本质上我们需要做的就是把一个字符串（比如 “狗”）映射到一个哈希代码（一个生成的数），即映射到一个数组的索引。你可能会问，为什么不直接使用索引呢？为什么要这么麻烦呢？因为通过这种方式我们可以直接查询 “狗” 并立即得到 “狗” 所在的位置，<code>String name = Array[&quot;狗&quot;] // 名字叫拉斯</code>。而使用索引查询名称时，可能出现的情况是我们不知道名称所在的索引。比如，<code>String name = Array[10] // 该名字现在叫鲍勃</code>  - 那不是我的狗的名字。这就是把一个字符串映射到一个哈希代码的益处（对应于一个数组的索引而言）。我们可以通过使用模运算符和哈希表的大小来计算出数组的索引：<code>index = hash_code % table_size</code>。 </p>
<p>我们需要避免的另一种情况是两个关键字映射到同一个索引，这叫做<strong>哈希碰撞</strong>，如果哈希函数实现的不好，这很容易发生。实际上，每一个输入比输出多的哈希函数都有可能发生碰撞。通过下面的同一个函数的两个输出来展示一个简单的碰撞：</p>
<figure class="highlight cpp">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">int</span> cat_idx = hashCode(<span class="string">"猫"</span>) % table_size; <span class="comment">//cat_idx 现在等于 1</span></div><div class="line"><span class="keyword">int</span> dog_idx = hashCode(<span class="string">"狗"</span>) % table_size; <span class="comment">//dog_idx 也等于 1</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>我们可以看到，现在两个数组的索引均是 1 。这样将会出现两个值相互覆盖，因为它们被写到了相同的索引中。如果我们查找 “猫” 的值，将会返回 “拉斯” ，但是这并不是我们想要的。有许多可以<a href="https://en.wikipedia.org/wiki/Hash_table#Collision_resolution" target="_blank" rel="external">解决哈希碰撞</a>的方法，但是更受欢迎的一种方法叫做<strong>链接</strong>。链接的想法就是对于数组的每一个索引位置都有一个链表，如果碰撞发生，值就被存到链表中。因此，在前面的例子中，我们将会得到我们需要的值，但是我们需要搜索数组中索引为
  1 的位置上的链表。伴有链接的哈希实现需要 <code>O(1 + α)</code> 时间，其中 α 是装载因子，它可以表示为 n/k，其中 n 是哈希表中的记录数目，k 是哈希表中可用位置的数目。但是请记住，只有当你给出的关键字非常随机时，这一结论才正确（依赖于 <a href="https://en.wikipedia.org/wiki/SUHA_(computer_science" target="_blank" rel="external">SUHA</a>）。</p>
<p>这是做了一个很大的假设，因为总是有可能任何不相等的关键字都散列到同一点。这一问题的一个解决方法是去除哈希表中关键字对随机性的依赖，转而把随机性集中于关键字是如何被散列的，从而减少矛盾发生的可能性。这被称为……</p>
<h3 id="通用散列"><a href="#通用散列" class="headerlink" title="通用散列"></a>通用散列</h3>
<p>这个观念很简单，从<ruby>通用散列<rt>universal hash</rt></ruby>家族集合随机选择一个哈希函数 h 来计算哈希代码。换句话来说，就是选择任何一个随机的哈希函数来散列关键字。通过这种方法，两个不同的关键字的散列结果相同的可能性将非常低（LCTT 译注：原文是“not be the same”，应是笔误）。我只是简单的提一下，如果不相信我那么请相信<a href="https://en.wikipedia.org/wiki/Universal_hashing#Mathematical_guarantees" target="_blank" rel="external">数学</a>。实现这一方法时需要注意的另一件事是如果选择了一个不好的通用散列家族，它会把时间和空间复杂度拖到
  <code>O(U)</code>，其中 U 是散列家族的大小。而其中的挑战就是找到一个不需要太多时间来计算，也不需要太多空间来存储的哈希家族。</p>
<h3 id="上帝哈希函数"><a href="#上帝哈希函数" class="headerlink" title="上帝哈希函数"></a>上帝哈希函数</h3>
<p>追求完美是人的天性。我们是否能够构建一个<em>完美的哈希函数</em>，从而能够把关键字映射到整数集中，并且几乎<em>没有碰撞</em>。好消息是我们能够在一定程度上做到，但是我们的数据必须是静态的（这意味着在一定时间内没有插入/删除/更新）。一个实现完美哈希函数的方法就是使用 <ruby>2 级哈希<rt>2-Level Hashing</rt></ruby>，它基本上是我们前面讨论过的两种方法的组合。它使用<em>通用散列</em>来选择使用哪个哈希函数，然后通过<em>链接</em>组合起来，但是这次不是使用链表数据结构，而是使用另一个哈希表。让我们看一看下面它是怎么实现的：
  </p>
<p><a href="http://www.zeroequalsfalse.press/2017/02/20/hashtables/Diagram.png" target="_blank" rel="external"><img src="http://www.zeroequalsfalse.press/2017/02/20/hashtables/Diagram.png" alt="2-Level Hashing" title="2-Level Hashing"></a> </p>
<p><strong>但是这是如何工作的以及我们如何能够确保无需关心碰撞？</strong></p>
<p>它的工作方式与<a href="https://en.wikipedia.org/wiki/Birthday_problem" target="_blank" rel="external">生日悖论</a>相反。它指出，在随机选择的一堆人中，会有一些人生日相同。但是如果一年中的天数远远大于人数（平方以上），那么有极大的可能性所有人的生日都不相同。所以这二者是如何相关的？对于每一个链接哈希表，其大小均为第一级哈希表大小的平方。那就是说，如果有两个元素被散列到同一个点，那么链接哈希表的大小将为 4 。大多数时候，链接哈希表将会非常稀疏/空。</p>
<p>重复下面两步来确保无需担心碰撞：</p>
<ul>
  <li>从通用散列家族中选择一个哈希函数来计算</li>
  <li>如果发生碰撞，那么继续从通用散列家族中选择另一个哈希函数来计算</li>
</ul>
<p>字面上看就是这样（这是一个 <code>O(n^2)</code> 空间的解）。如果需要考虑空间问题，那么显然需要另一个不同的方法。但是值得庆幸的是，该过程平均只需要进行<strong>两次</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
<p>只有具有一个好的哈希函数才能算得上是一个好的哈希表。在同时保证功能实现、时间和空间的提前下构建一个完美的哈希函数是一件很困难的事。我推荐你在解决问题的时候首先考虑哈希表，因为它能够为你提供巨大的性能优势，而且它能够对应用程序的可用性产生显著差异。哈希表和完美哈希函数常被用于实时编程应用中，并且在各种算法中都得到了广泛应用。你见或者不见，哈希表就在这儿。</p>
<hr>
<p>via: <a href="http://www.zeroequalsfalse.press/2017/02/20/hashtables/" target="_blank" rel="external">http://www.zeroequalsfalse.press/2017/02/20/hashtables/</a></p>
<p>作者：<a href="http://www.zeroequalsfalse.press/about" target="_blank" rel="external">Marty Jacobs</a><br>译者：<a href="https://github.com/ucasFL" target="_blank" rel="external">ucasFL</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;探索&lt;ruby&gt;哈希表&lt;rt&gt;hash table&lt;/rt&gt;&lt;/ruby&gt;的世界并理解其底层的机制是非常有趣的，并且将会受益匪浅。所以，让我们了解它，并从头开始探索吧。&lt;/p&gt;
&lt;p&gt;哈希表是许多现代软件应用程序中一种常见的数据结构。它提供了类似字典的功能，使你能够在其中执行插入、删除和删除等操作。这么说吧，比如我想找出“苹果”的定义是什么，并且我知道该定义被存储在了我定义的哈希表中。我将查询我的哈希表来得到定义。它在哈希表内的记录看起来可能像：&lt;code&gt;&amp;quot;苹果&amp;quot; =&amp;gt; &amp;quot;一种拥有水果之王之称的绿色水果&amp;quot;&lt;/code&gt;。这里，“苹果”是我的关键字，而“一种拥有水果之王之称的水果”是与之关联的值。&lt;/p&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Hash-table" scheme="http://ucasfl.me/tags/Hash-table/"/>
    
  </entry>
  
  <entry>
    <title>通过开源书籍学习 Ruby 编程</title>
    <link href="http://ucasfl.me/2017/09/02/Open-Source-Ruby-Books/"/>
    <id>http://ucasfl.me/2017/09/02/Open-Source-Ruby-Books/</id>
    <published>2017-09-02T04:44:13.000Z</published>
    <updated>2017-09-02T04:55:43.099Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/Ruby-Montage.png?w=565&amp;ssl=1" alt=""></p>
<h3 id="开源的-Ruby-书籍"><a href="#开源的-Ruby-书籍" class="headerlink" title="开源的 Ruby 书籍"></a>开源的 Ruby 书籍</h3>
<p>Ruby 是由 Yukihiro “Matz” Matsumoto 开发的一门通用目的、脚本化、结构化、灵活且完全面向对象的编程语言。它具有一个完全动态类型系统，这意味着它的大多数类型检查是在运行的时候进行，而非编译的时候。因此程序员不必过分担心是整数类型还是字符串类型。Ruby 会自动进行内存管理，它具有许多和 Python、Perl、Lisp、Ada、Eiffel 和 Smalltalk 相同的特性。</p>
<p>Ruby on Rails 框架对于 Ruby 的流行起到了重要作用，它是一个全栈 Web 框架，目前已被用来创建许多受欢迎的应用，包括 Basecamp、GitHub、Shopify、Airbnb、Twitch、SoundCloud、Hulu、Zendesk、Square 和 Highise 。</p>
<p>Ruby 具有很高的可移植性性，在 Linux、Windows、Mac OS X、Cygwin、FreeBSD、NetBSD、OpenBSD、BSD/OS、Solaris、Tru64 UNIX、HP-UX 以及其他许多系统上均可运行。目前，Ruby 在 TIOBE 编程社区排名 12 。</p>
<p>这篇文章有 9 本很优秀的推荐书籍，有针对包括初学者、中级程序员和高级程序员的书籍。当然，所有的书籍都是在开源许可下发布的。</p>
<a id="more"></a>
<p>这篇文章是<a href="https://www.ossblog.org/opensourcebooks/" target="_blank" rel="external"> OSSBlog 的系列文章开源编程书籍</a>的一部分。</p>
<h3 id="《Ruby-Best-Practices》"><a href="#《Ruby-Best-Practices》" class="headerlink" title="《Ruby Best Practices》"></a>《<a href="https://github.com/practicingruby/rbp-book/tree/gh-pages/pdfs" target="_blank" rel="external">Ruby Best Practices</a>》</h3>
<p><img src="https://i0.wp.com/www.ossblog.org/wp-content/uploads/2017/03/RubyBestPractices.jpg?resize=200%2C262&amp;ssl=1" alt="Ruby Best Practices"> </p>
<p>作者： Gregory Brown (328 页)</p>
<p>《Ruby Best Practices》适合那些希望像有经验的 Ruby 专家一样使用 Ruby 的程序员。本书是由 Ruby 项目 Prawn 的开发者所撰写的，它阐述了如何使用 Ruby 设计美丽的 API 和特定领域语言，以及如何利用函数式编程想法和技术，从而简化代码，提高效率。</p>
<p>《Ruby Best Practices》 更多的内容是关于如何使用 Ruby 来解决问题，它阐述的是你应该使用的最佳解决方案。这本书不是针对 Ruby 初学者的，所以对于编程新手也不会有太多帮助。这本书的假想读者应该对 Ruby 的相应技术有一定理解，并且拥有一些使用 Ruby 来开发软件的经验。</p>
<p>这本书分为两部分，前八章组成本书的核心部分，后三章附录作为补充材料。</p>
<p>这本书提供了大量的信息：</p>
<ul>
  <li>通过测试驱动代码 - 涉及了大量的测试哲学和技术。使用 mocks 和 stubs</li>
  <li>通过利用 Ruby 神秘的力量来设计漂亮的 API：灵活的参数处理和代码块</li>
  <li>利用动态工具包向开发者展示如何构建灵活的界面，实现单对象行为，扩展和修改已有代码，以及程序化地构建类和模块</li>
  <li>文本处理和文件管理集中于正则表达式，文件、临时文件标准库以及文本处理策略实战</li>
  <li>函数式编程技术优化了模块代码组织、存储、无穷目录以及更高顺序程序。</li>
  <li>理解代码如何出错以及为什么会出错，阐述如何处理日志记录</li>
  <li>通过利用 Ruby 的多语言能力削弱文化屏障</li>
  <li>熟练的项目维护</li>
</ul>
<p>本书为开源书籍，在 CC NC-SA 许可证下发布。</p>
<p><a href="https://github.com/practicingruby/rbp-book/tree/gh-pages/pdfs" target="_blank" rel="external">在此下载《Ruby Best Practices》</a>。 </p>
<h3 id="《I-Love-Ruby》"><a href="#《I-Love-Ruby》" class="headerlink" title="《I Love Ruby》"></a>《<a href="https://mindaslab.github.io/I-Love-Ruby/" target="_blank" rel="external">I Love Ruby</a>》</h3>
<p> <img src="https://i2.wp.com/www.ossblog.org/wp-content/uploads/2017/03/LoveRuby.png?resize=200%2C282&amp;ssl=1" alt="I Love Ruby"></p>
<p>作者： Karthikeyan A K (246 页)</p>
<p>《I Love Ruby》以比传统的介绍更高的深度阐述了基本概念和技术。该方法为编写有用、正确、易维护和高效的 Ruby 代码提供了一个坚实的基础。</p>
<p>章节内容涵盖：</p>
<ul>
  <li>变量</li>
  <li>字符串</li>
  <li>比较和逻辑</li>
  <li>循环</li>
  <li>数组</li>
  <li>哈希和符号</li>
  <li>Ranges</li>
  <li>函数</li>
  <li>变量作用域</li>
  <li>类 &amp; 对象</li>
  <li>Rdoc</li>
  <li>模块和 Mixins</li>
  <li>日期和时间</li>
  <li>文件</li>
  <li>Proc、匿名 和 块</li>
  <li>多线程</li>
  <li>异常处理</li>
  <li>正则表达式</li>
  <li>Gems</li>
  <li>元编程</li>
</ul>
<p>在 GNU 自由文档许可证之下，你可以复制、发布和修改本书，1.3 或任何之后版本由自由软件基金会发布。</p>
<p><a href="https://mindaslab.github.io/I-Love-Ruby/" target="_blank" rel="external">点此下载《I Love Ruby》</a>。</p>
<h3 id="Programming-Ruby-–-The-Pragmatic-Programmer’s-Guide"><a href="#Programming-Ruby-–-The-Pragmatic-Programmer’s-Guide" class="headerlink" title="Programming Ruby – The Pragmatic Programmer’s Guide"></a><a href="http://ruby-doc.com/docs/ProgrammingRuby/" target="_blank" rel="external">Programming Ruby – The Pragmatic Programmer’s Guide</a></h3>
<p><img src="https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/ProgrammingRuby.jpeg?resize=200%2C248&amp;ssl=1" alt="Programming Ruby - The Pragmatic Programmer&#39;s Guide"> </p>
<p>作者： David Thomas, Andrew Hunt (HTML)</p>
<p>《Programming Ruby – The Pragmatic Programmer’s Guide》是一本 Ruby 编程语言的教程和参考书。使用 Ruby，你将能够写出更好的代码，更加有效率，并且使编程变成更加享受的体验。</p>
<p>内容涵盖以下部分：</p>
<ul>
  <li>类、对象和变量</li>
  <li>容器、块和迭代器</li>
  <li>标准类型</li>
  <li>更多方法</li>
  <li>表达式</li>
  <li>异常、捕获和抛出</li>
  <li>模块</li>
  <li>基本输入和输出</li>
  <li>线程和进程</li>
  <li>何时抓取问题</li>
  <li>Ruby 和它的世界、Web、Tk 和 微软 Windows</li>
  <li>扩展 Ruby</li>
  <li>映像、对象空间和分布式 Ruby</li>
  <li>标准库</li>
  <li>面向对象设计库</li>
  <li>网络和 Web 库</li>
  <li>嵌入式文件</li>
  <li>交互式 Ruby shell</li>
</ul>
<p>这本书的第一版在开放发布许可证 1.0 版或更新版的许可下发布。本书更新后的第二版涉及 Ruby 1.8 ，并且包括所有可用新库的描述，但是它不是在免费发行许可证下发布的。</p>
<p><a href="http://ruby-doc.com/docs/ProgrammingRuby/" target="_blank" rel="external">点此下载《Programming Ruby – The Pragmatic Programmer’s Guide》</a>。</p>
<h3 id="《Why’s-Poignant-Guide-to-Ruby》"><a href="#《Why’s-Poignant-Guide-to-Ruby》" class="headerlink" title="《Why’s (Poignant) Guide to Ruby》"></a>《<a href="http://poignant.guide/" target="_blank" rel="external">Why’s (Poignant) Guide to Ruby</a>》</h3>
<p><img src="https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/WhysGuideRuby.jpg?resize=200%2C218&amp;ssl=1" alt="Why’s (Poignant) Guide to Ruby"> </p>
<p>作者：why the lucky stiff (176 页)</p>
<p>《Why’s (poignant) Guide to Ruby》是一本 Ruby 编程语言的介绍书籍。该书包含一些冷幽默，偶尔也会出现一些和主题无关的内容。本书包含的笑话在 Ruby 社区和卡通角色中都很出名。</p>
<p>本书的内容包括：</p>
<ul>
  <li>关于本书</li>
  <li>Kon’nichi wa, Ruby</li>
  <li>一个快速（希望是无痛苦的）的 Ruby 浏览（伴随卡通角色）：Ruby 核心概念的基本介绍</li>
  <li>代码浮动小叶：评估和值，哈希和列表</li>
  <li>组成规则的核心部分：case/when、while/until、变量作用域、块、方法、类定义、类属性、对象、模块、IRB 中的内省、dup、self 和 rbconfig 模块</li>
  <li>中心：元编程、正则表达式</li>
  <li>当你打算靠近胡须时：在已存在类中发送一个新方法</li>
  <li>天堂演奏</li>
</ul>
<p>本书在 CC-SA 许可证许可下可用。</p>
<p><a href="http://poignant.guide/" target="_blank" rel="external">点此下载《Why’s (poignant) Guide to Ruby》</a>。</p>
<h3 id="《Ruby-Hacking-Guide》"><a href="#《Ruby-Hacking-Guide》" class="headerlink" title="《Ruby Hacking Guide》"></a>《<a href="http://ruby-hacking-guide.github.io/" target="_blank" rel="external">Ruby Hacking Guide</a>》</h3>
<p><img src="https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/RubyHackingGuide.png?resize=200%2C250&amp;ssl=1" alt="Ruby Hacking Guide"> </p>
<p>作者： Minero Aoki ，翻译自 Vincent Isambart 和 Clifford Escobar Caoille (HTML)</p>
<p>通过阅读本书可以达成下面的目标：</p>
<ul>
  <li>拥有关于 Ruby 结构的知识</li>
  <li>掌握一般语言处理的知识</li>
  <li>收获阅读源代码的技能</li>
</ul>
<p>本书分为四个部分：</p>
<ul>
  <li>对象</li>
  <li>动态分析</li>
  <li>评估</li>
  <li>外部评估</li>
</ul>
<p>要想从本书中收获最多的东西，需要具备一定 C 语言的知识和基本的面向对象编程知识。本书在 CC-NC-SA 许可证许可下发布。</p>
<p>原书的官方支持网站为 <a href="http://i.loveruby.net/ja/rhg/" target="_blank" rel="external">i.loveruby.net/ja/rhg/</a></p>
<p><a href="http://ruby-hacking-guide.github.io/" target="_blank" rel="external">点此下载《Ruby Hacking Guide》</a></p>
<h3 id="《The-Book-Of-Ruby》"><a href="#《The-Book-Of-Ruby》" class="headerlink" title="《The Book Of Ruby》"></a>《<a href="http://www.sapphiresteel.com/ruby-programming/The-Book-Of-Ruby.html" target="_blank" rel="external">The Book Of Ruby</a>》</h3>
<p><img src="https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/BookRuby.jpg?resize=200%2C270&amp;ssl=1" alt="The Book Of Ruby"> </p>
<p>作者： How Collingbourne (425 页)</p>
<p>《The Book Of Ruby》是一本免费的 Ruby 编程高级教程。</p>
<p>《The Book Of Ruby》以 PDF 文件格式提供，并且每一个章节的所有例子都伴有可运行的源代码。同时，也有一个介绍来阐述如何在 Steel 或其他任何你喜欢的编辑器/IDE 中运行这些 Ruby 代码。它主要集中于 Ruby 语言的 1.8.x 版本。</p>
<p>本书被分成很小的块。每一个章节介绍一个主题，并且分成几个不同的子话题。每一个编程主题由一个或多个小的自包含、可运行的 Ruby 程序构成。</p>
<ul>
  <li>字符串、数字、类和对象 - 获取输入和输出、字符串和外部评估、数字和条件测试：if … then、局部变量和全局变量、类和对象、实例变量、消息、方法、多态性、构造器和检属性和类变量 - 超类和子类，超类传参，访问器方法，’set‘ 访问器，属性读写器、超类的方法调用，以及类变量</li>
  <li>类等级、属性和类变量 - 超类和子类，超类传参，访问器方法，’set‘ 访问器，属性读写器、超类的方法调用，以及类变量</li>
  <li>字符串和 Ranges - 用户自定义字符串定界符、引号等更多</li>
  <li>数组和哈希 - 展示如何创建一系列对象</li>
  <li>循环和迭代器 - for 循环、代码块、while 循环、while 修改器以及 until 循环</li>
  <li>条件语句 - If..Then..Else、And..Or..Not、If..Elsif、unless、if 和 unless 修改器、以及 case 语句</li>
  <li>方法 - 类方法、类变量、类方法是用来干什么的、Ruby 构造器、单例方法、单例类、重载方法以及更多</li>
  <li>传递参数和返回值 - 实例方法、类方法、单例方法、返回值、返回多重值、默认参数和多重参数、赋值和常量传递以及更多</li>
  <li>异常处理 - 涉及 rescue、ensure、else、错误数量、retry 和 raise</li>
  <li>块、Procs 和 匿名 - 阐述为什么它们对 Ruby 来说很特殊</li>
  <li>符号 - 符号和字符串、符号和变量以及为什么应该使用符号</li>
  <li>模块和 Mixins</li>
  <li>文件和 IO - 打开和关闭文件、文件和目录、复制文件、目录询问、一个关于递归的讨论以及按大小排序</li>
  <li>YAML - 包括嵌套序列，保存 YAML 数据以及更多</li>
  <li>Marshal - 提供一个保存和加载数据的可选择方式</li>
  <li>正则表达式 - 进行匹配、匹配群组以及更多</li>
  <li>线程 - 向你展示如何同时运行多个任务</li>
  <li>调试和测试 - 涉及交互式 Ruby shell（IRB.exe）、debugging 和 单元测试</li>
  <li>Ruby on Rails - 浏览一个创建博客的实践指南</li>
  <li>动态编程 - 自修改程序、重运算魔法、特殊类型的运算、添加变量和方法以及更多</li>
</ul>
<p>本书由 SapphireSteel Software 发布，SapphireSteel Software 是用于 Visual Studio 的 Ruby In Steel 集成开发环境的开发者。读者可以复制和发布本书的文本和代码（免费版）</p>
<p><a href="http://www.sapphiresteel.com/ruby-programming/The-Book-Of-Ruby.html" target="_blank" rel="external">点此下载《The Book Of Ruby》</a></p>
<h3 id="《The-Little-Book-Of-Ruby》"><a href="#《The-Little-Book-Of-Ruby》" class="headerlink" title="《The Little Book Of Ruby》"></a>《<a href="http://www.sapphiresteel.com/ruby-programming/The-Book-Of-Ruby.html" target="_blank" rel="external">The Little Book Of Ruby</a>》</h3>
<p> <img src="https://i0.wp.com/www.ossblog.org/wp-content/uploads/2017/03/TheLittleBookRuby.png?resize=200%2C259&amp;ssl=1" alt="The Little Book of Ruby"> </p>
<p>作者： Huw Collingbourne (87 页)</p>
<p>《The Little Book of Ruby》是一本一步接一步的 Ruby 编程教程。它指导读者浏览 Ruby 的基础。另外，它分享了《The Book of Ruby》一书的内容，但是它旨在作为一个简化的教程来阐述 Ruby 的主要特性。</p>
<p>章节内容涵盖：</p>
<ul>
  <li>字符串和方法 - 包括外部评估。详细描述了 Ruby 方法的语法</li>
  <li>类和对象 - 阐述如何创建一个新类型的对象</li>
  <li>类等级 - 一个特殊类型的类，其为一些其他类的简化并且继承了其他一些类的特性</li>
  <li>访问器、属性、类变量 - 访问器方法，属性读写器，属性创建变量，调用超类方法以及类变量探索</li>
  <li>数组 - 学习如何创建一系列对象：数组包括多维数组</li>
  <li>哈希 - 涉及创建哈希表，为哈希表建立索引以及哈希操作等</li>
  <li>循环和迭代器 - for 循环、块、while 循环、while 修饰器以及 until 循环</li>
  <li>条件语句 - If..Then..Else、And..Or..Not、If..Elsif、unless、if 和 unless 修饰器以及 case 语句</li>
  <li>模块和 Mixins - 包括模块方法、模块作为名字空间模块实例方法、模块或 ‘mixins’、来自文件的模块和预定义模块</li>
  <li>保存文件以及更多内容</li>
</ul>
<p>本书可免费复制和发布，只需保留原始文本且注明版权信息。</p>
<p><a href="http://www.sapphiresteel.com/ruby-programming/The-Book-Of-Ruby.html" target="_blank" rel="external">点此下载《The Little Book of Ruby》</a></p>
<h3 id="《Kestrels-Quirky-Birds-and-Hopeless-Egocentricity》"><a href="#《Kestrels-Quirky-Birds-and-Hopeless-Egocentricity》" class="headerlink" title="《Kestrels, Quirky Birds, and Hopeless Egocentricity》"></a>《<a href="https://leanpub.com/combinators" target="_blank" rel="external">Kestrels, Quirky Birds, and Hopeless Egocentricity</a>》</h3>
<p>
  <img src="https://i2.wp.com/www.ossblog.org/wp-content/uploads/2017/03/KestrelsQuirkyBirds.jpeg?resize=200%2C259&amp;ssl=1" alt="Kestrels, Quirky Birds, and Hopeless Egocentricity"> </p>
<p>作者： Reg “raganwald” Braithwaite (123 页)</p>
<p>《Kestrels, Quirky Birds, and Hopeless Egocentricity》是通过收集 “Raganwald” Braithwaite 的关于组合逻辑、Method Combinators 以及 Ruby 元编程的系列文章而形成的一本方便的电子书。</p>
<p>本书提供了通过使用 Ruby 编程语言来应用组合逻辑的一个基本介绍。组合逻辑是一种数学表示方法，它足够强大，从而用于解决集合论问题以及计算中的问题。</p>
<p>在这本书中，读者会会探讨到一些标准的 Combinators，并且对于每一个 Combinators，书中都用 Ruby 编程语言写程序探讨了它的一些结果。在组合逻辑上，Combinators 之间组合并相互改变，书中的 Ruby 例子注重组合和修改 Ruby 代码。通过像 K Combinator 和 .tap 方法这样的简单例子，本书阐述了元编程的理念和递归 Combinators 。</p>
<p>本书在 MIT 许可证许可下发布。</p>
<p><a href="https://leanpub.com/combinators" target="_blank" rel="external">点此下载《Kestrels, Quirky Birds, and Hopeless Egocentricity》</a></p>
<h3 id="《Ruby-Programming》"><a href="#《Ruby-Programming》" class="headerlink" title="《Ruby Programming》"></a>《<a href="https://en.wikibooks.org/wiki/Ruby_Programming" target="_blank" rel="external">Ruby Programming</a>》</h3>
<p> <img src="https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/RubyProgrammingWikibooks.png?resize=200%2C285&amp;ssl=1" alt="Ruby Programming"> </p>
<p>作者： Wikibooks.org (261 页)</p>
<p>Ruby 是一种解释性、面向对象的编程语言。</p>
<p>本书被分为几个部分，从而方便按顺序阅读。</p>
<ul>
  <li>开始 - 向读者展示如何在其中一个操作系统环境中安装并开始使用 Ruby </li>
  <li>Ruby 基础 - 阐述 Ruby 语法的主要特性。它涵盖了字符串、编码、写方法、类和对象以及异常等内容</li>
  <li>Ruby 语义参考</li>
  <li>内建类</li>
  <li>可用模块，涵盖一些标准库</li>
  <li>中级 Ruby 涉及一些稍微高级的话题</li>
</ul>
<p>本书在 CC-SA 3.0 本地化许可证许可下发布。</p>
<p><a href="https://en.wikibooks.org/wiki/Ruby_Programming" target="_blank" rel="external">点此下载《Ruby Programming》</a></p>
<hr>
<p>无特定顺序，我将在结束前推荐一些没有在开源许可证下发布但可以免费下载的 Ruby 编程书籍。</p>
<ul>
  <li><a href="http://www.humblelittlerubybook.com/" target="_blank" rel="external">Mr. Neighborly 的 Humble Little Ruby Book</a> – 一个易读易学的 Ruby 完全指南。</li>
  <li><a href="https://launchschool.com/books/ruby" target="_blank" rel="external">Introduction to Programming with Ruby</a> – 学习编程的基础知识，一切从零开始。</li>
  <li><a href="https://launchschool.com/books/oo_ruby" target="_blank" rel="external">Object Oriented Programming with Ruby</a> – 学习编程的基础知识，一切从零开始。</li>
  <li><a href="https://launchschool.com/books/core_ruby_tools" target="_blank" rel="external">Core Ruby Tools</a> – 对 Ruby 的四个核心工具 Gems、Ruby Version Managers、Bundler 和 Rake 进行了简短的概述。</li>
  <li><a href="https://learnrubythehardway.org/book/" target="_blank" rel="external">Learn Ruby the Hard Way, 3rd Edition</a> – 一本适合初学者的入门书籍。</li>
  <li><a href="https://pine.fm/LearnToProgram" target="_blank" rel="external">Learn to Program</a> – 来自 Chris Pine。</li>
  <li><a href="http://www.techotopia.com/index.php/Ruby_Essentials" target="_blank" rel="external">Ruby Essentials</a> – 一个准确且简单易学的 Ruby 学习指南。</li>
</ul>
<hr>
<p>via: <a href="https://www.ossblog.org/study-ruby-programming-with-open-source-books/" target="_blank" rel="external">https://www.ossblog.org/study-ruby-programming-with-open-source-books/</a></p>
<p>作者：<a href="https://www.ossblog.org/author/steve/" target="_blank" rel="external">Steve Emms</a><br>译者：<a href="https://github.com/ucasFL" target="_blank" rel="external">ucasFL</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i1.wp.com/www.ossblog.org/wp-content/uploads/2017/03/Ruby-Montage.png?w=565&amp;amp;ssl=1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;开源的-Ruby-书籍&quot;&gt;&lt;a href=&quot;#开源的-Ruby-书籍&quot; class=&quot;headerlink&quot; title=&quot;开源的 Ruby 书籍&quot;&gt;&lt;/a&gt;开源的 Ruby 书籍&lt;/h3&gt;
&lt;p&gt;Ruby 是由 Yukihiro “Matz” Matsumoto 开发的一门通用目的、脚本化、结构化、灵活且完全面向对象的编程语言。它具有一个完全动态类型系统，这意味着它的大多数类型检查是在运行的时候进行，而非编译的时候。因此程序员不必过分担心是整数类型还是字符串类型。Ruby 会自动进行内存管理，它具有许多和 Python、Perl、Lisp、Ada、Eiffel 和 Smalltalk 相同的特性。&lt;/p&gt;
&lt;p&gt;Ruby on Rails 框架对于 Ruby 的流行起到了重要作用，它是一个全栈 Web 框架，目前已被用来创建许多受欢迎的应用，包括 Basecamp、GitHub、Shopify、Airbnb、Twitch、SoundCloud、Hulu、Zendesk、Square 和 Highise 。&lt;/p&gt;
&lt;p&gt;Ruby 具有很高的可移植性性，在 Linux、Windows、Mac OS X、Cygwin、FreeBSD、NetBSD、OpenBSD、BSD/OS、Solaris、Tru64 UNIX、HP-UX 以及其他许多系统上均可运行。目前，Ruby 在 TIOBE 编程社区排名 12 。&lt;/p&gt;
&lt;p&gt;这篇文章有 9 本很优秀的推荐书籍，有针对包括初学者、中级程序员和高级程序员的书籍。当然，所有的书籍都是在开源许可下发布的。&lt;/p&gt;
    
    </summary>
    
      <category term="Ruby" scheme="http://ucasfl.me/categories/Ruby/"/>
    
    
      <category term="Ruby" scheme="http://ucasfl.me/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>外部排序</title>
    <link href="http://ucasfl.me/2017/08/08/External-Sort/"/>
    <id>http://ucasfl.me/2017/08/08/External-Sort/</id>
    <published>2017-08-08T04:53:19.000Z</published>
    <updated>2017-09-02T04:38:29.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主存储器与外部存储器"><a href="#主存储器与外部存储器" class="headerlink" title="主存储器与外部存储器"></a>主存储器与外部存储器</h3>
<p>外存储器与内存储器相比,优点是:</p>
<ul>
  <li>价格较低</li>
  <li>永久的存储能力</li>
</ul>
<p>缺点:</p>
<ul>
  <li>访问外存储器上的数据比访问内存要慢5 ~ 6 个数量级</li>
</ul>
<p>因此，要求我们在开发系统时必须考虑如何使外存访<br>问次数达到最少。</p>
<a id="more"></a>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3>
<ul>
  <li>磁盘存储器通常称为直接存取设备,或随机存取设备,它访问外存上文件的任一记录的时间几乎相同。</li>
  <li>磁盘存储器可以顺序存取,也可以随机存取。</li>
  <li>每个记录盘面上有很多磁道,数据就存放在这些磁道上。它们在记录盘面上形成一个个同心圆。</li>
  <li>每个记录盘面都有一个读写磁头。所有记录盘面的读写磁头都安装在同一个动臂上,随动臂向内或向外做径向移动,从一个磁道移到另一个磁道。</li>
  <li>任一时刻,所有记录盘面的读写磁头停留在各个记录盘面的半径相同的磁道上。</li>
  <li>各个记录盘面上半径相同的磁道合在一起称为柱面。一个磁道可以划分为若干段,称为扇区,一个扇区就是一次读写的最小数据量。这样,对磁盘存储器来说,从大到小的存储单位是:柱面号、盘片号、磁道号和扇区。</li>
  <li>在磁盘组上一次读写的时间主要为:</li>
</ul>
<p>$$t<em>{io} = t</em>{seek} + t<em>{latency} +n\cdot t</em>{wm}$$<br>其中, $t<em>{seek}$ 平均寻查时间,是把磁头定位到要求柱面所需时间。$t</em>{latency}$ 平均等待时间,是将磁头定位到指定块所需时间。$t_{wm}$ 是传输一个扇区数据所需的时间。</p>
<ul>
  <li>在磁盘组上一次读 / 写的时间主要花在寻找时间上。因此,在磁盘上存放信息时应将相关信息放在同一柱面或邻近柱面上,以求在读 / 写信息时尽量减少磁头来回移动的次数,以避免不必要的寻找时间。</li>
</ul>
<h3 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h3>
<p>当待排序的记录数目特别多时,在内存中不能一次处理,必须把它们以文件的形式存放于外存,排序时再把它们一部分一部分调入内存进行处理。这样,在排序过程中必须不断地在内存与外存之间传送数据。这种基于外部存储设备(或文件)的排序技术就是外排序。</p>
<h4 id="外排序的基本过程"><a href="#外排序的基本过程" class="headerlink" title="外排序的基本过程"></a>外排序的基本过程</h4>
<p>基于磁盘进行的排序多使用归并排序方法。其排序过程主要分为两个阶段:</p>
<ol>
  <li>按可用内存大小,将外存上含 n 个记录的文件划分为若干长度为 $l$ 的段 , 用某种内排序方法对各段进行排序。经过排序的段叫做归并段 (Run) 。当它们生成后就被写到外存中去。</li>
  <li>把1生成的初始归并段加以归并 , 一趟趟扩大归并段和减少归并段数 , 直至得到整个有序文件为止。</li>
</ol>
<ul>
  <li>
    <p>归并排序时间$t_{ES}$为：</p>
    <p>$t<em>{ES}=m\times t</em>{IS}+d\times t<em>{IO}+S\times n\cdot t</em>{mg}$</p>
    <p>其中，$t_{IS}$是得到一个初始段需要的内部排序时间；$m$为初始归并段的个数；</p>
    <p>$t<em>{IO}$是进行一次外存读/写时间的均值；$d$为总的读/写次数；$n\cdot t</em>{mg}$是对$n$个记录进行内部归并所需时间；$S$为归并的趟数。</p>
  </li>
  <li>
    <p>$t<em>{IO}$远远大于$t</em>{IS}$和$t_{mg}$，因此，要加快外排序的速度，应着眼于减小$d$ 。</p>
  </li>
  <li>
    <p>增大归并路数 , 可减少归并趟数 , 从而减少总读写磁盘次数 d 。</p>
  </li>
</ul>
<h3 id="K-路平衡归并"><a href="#K-路平衡归并" class="headerlink" title="K-路平衡归并"></a>K-路平衡归并</h3>
<p>做K-路平衡归并时，如果有m个初始归并段，相应的归并树有logkm+1(logkm上取整)层，需要归并logkm(上取整)趟。</p>
<h4 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h4>
<p>败者树是一棵正则的完全二叉树。其中</p>
<ul>
  <li>每个叶结点存放各归并段在归并过程中当前参加比较的记录;</li>
  <li>每个非叶结点记忆它两个子女结点中记录排序码大的结点 ( 即败者 ) ;</li>
</ul>
<p>因此,根结点中记忆树中当前记录排序码最小的结点 ( 最小记录 ) 。</p>
<ul>
  <li>败者树与胜者树的区别在于一个选择了败者 ( 排序码大者)，一个选择了胜者(排序码小者)</li>
</ul>
<p><strong>K-路平衡归并排序算法</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxValue = ;	<span class="comment">//当作无穷大值使用</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kwaymerge</span><span class="params">(Element *r, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, q; </div><div class="line">  r = <span class="keyword">new</span> Element[k];		<span class="comment">//败者树中的k个记录</span></div><div class="line">  <span class="keyword">int</span> *key = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];	<span class="comment">//记录的排序码	</span></div><div class="line">  <span class="keyword">int</span> *loser = <span class="keyword">new</span> <span class="keyword">int</span>[k];	<span class="comment">//存放败者树</span></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) &#123;           <span class="comment">//叶结点的值</span></div><div class="line">    InputRecord(r[i]);  key[i] = r[i].key; &#125;;</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) loser[i] = k;</div><div class="line">  key[k] = -Maxvalue;		<span class="comment">//初始化	</span></div><div class="line">  <span class="keyword">for</span> (i = k<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) </div><div class="line">    adjust (key, loser, k, i);    <span class="comment">//从key[k-1]到key[0]调整形成败者树</span></div><div class="line">  <span class="keyword">while</span> (key[loser[<span class="number">0</span>]] != MaxValue) &#123;      <span class="comment">//选冠军</span></div><div class="line">    q = loser[<span class="number">0</span>];			 <span class="comment">//取当前最小记录</span></div><div class="line">    OutputRecord(r[q]);		 <span class="comment">//写到输出归并段</span></div><div class="line">    InputRecord(r[q]);		 <span class="comment">//读入下一个记录</span></div><div class="line">    key[q] = r[q].key;</div><div class="line">    adjust (key, loser, k, q); 	 <span class="comment">//从key[q]起调整</span></div><div class="line">  &#125;</div><div class="line">  Output end of run marker; 	 <span class="comment">//输出段结束标志</span></div><div class="line">  <span class="keyword">delete</span> []r;  </div><div class="line">  <span class="keyword">delete</span> []key;</div><div class="line">  <span class="keyword">delete</span> []loser;</div><div class="line">&#125;; </div><div class="line"><span class="comment">//败者树的调整算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span> <span class="params">(<span class="keyword">int</span> key[]; <span class="keyword">int</span> loser[]; <span class="keyword">int</span> k; <span class="keyword">int</span> q)</span> </span>&#123;</div><div class="line"><span class="comment">// 从败者树某叶结点 key[q] 起到根进行比较 , 将最小</span></div><div class="line"><span class="comment">// key 记录所在归并段的段号记入 loser[0] 。</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> t = (k+q)/<span class="number">2</span>; t &gt; <span class="number">0</span>; t /= <span class="number">2</span>)</div><div class="line"><span class="comment">//t 是 q 的双亲</span></div><div class="line">    <span class="keyword">if</span> (key[loser[t]] &lt; key[q]) &#123;</div><div class="line"><span class="comment">// 败者记入 loser[t] ,胜者记入 q</span></div><div class="line">      <span class="keyword">int</span> temp = q; q = loser[t]; loser[t] = temp;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//q 与 loser[t] 交换</span></div><div class="line">  loser[<span class="number">0</span>] = q;</div><div class="line">&#125;;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>每选出一个当前排序码最小的记录 , 就需要在将它送入输出缓冲区之后 , 从相应归并段的输入缓冲区中取出下一个参加归并的记录 , 替换已经取走的最小记录 , 再从叶结点到根结点 , 沿某一特定路径进行调整 , 将下一个排序码最小记录的归并段号调整到 loser[0] 中。</li>
  <li>段结束标志 MaxNum 升入 loser[0], 排序完成。</li>
  <li>归并路数 k 不是越大越好。归并路数 k 增大 , 相应需增加输入缓冲区个数。如果可供使用的内存空间不变 , 势必要减少每个输入缓冲区的容量 , 使内外存交换数据的次数增大。</li>
</ul>
<p><strong>初始归并段的生成</strong></p>
<ul>
  <li>为减少读写磁盘次数 , 除增加归并路数 k 外 ,还可减少初始归并段个数 m 。在总记录数 n一定时 , 要减少 m , 必须增大初始归并段长度。</li>
  <li>如果规定每个初始归并段等长 , 则此长度应根据生成它的内存工作区空间大小而定 , 因而 m的减少也就受到了限制。</li>
  <li>为了突破这个限制 , 可采用败者树来生成初始归并段。在使用同样大内存工作区的情况下 ,可以生成平均比原来等长情况下大一倍的初始归并段 , 从而减少初始归并段个数。</li>
</ul>
<h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3>
<p>归并树是描述归并过程的 m 叉树。因为每一次做 m路归并都需要有 m 个归并段参加 , 因此 , 归并树是只有度为 0 和度为 m 的结点的正则 m 叉树。</p>
<p>在归并树中：</p>
<ul>
  <li>各叶结点代表参加归并的各初始归并段</li>
  <li>叶结点上的权值即为该初始归并段中的记录个数</li>
  <li>根结点代表最终生成的归并段</li>
  <li>叶结点到根结点的路径长度表示在归并过程中的读记录次数</li>
  <li>各非叶结点代表归并出来的新归并段</li>
  <li>归并树的带权路径长度 WPL 即为归并过程中的总读记录数。因而,在归并过程中总的读写记录次数为 2*WPL 。</li>
</ul>
<p>不同的归并方案所对应的归并树的带权路径长度各不相同。为了使得总的读写次数达到最少 , 需要改变归并方案 , 重新组织归并树。可将 Huffman 树的思想扩充到 m 叉树的情形。在归并树中 , 让记录个数少的初始归并段最先归并 , 记录个数多的初始归并段最晚归并 , 就可建立总读写次数达到最少的最佳归并树。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主存储器与外部存储器&quot;&gt;&lt;a href=&quot;#主存储器与外部存储器&quot; class=&quot;headerlink&quot; title=&quot;主存储器与外部存储器&quot;&gt;&lt;/a&gt;主存储器与外部存储器&lt;/h3&gt;
&lt;p&gt;外存储器与内存储器相比,优点是:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;价格较低&lt;/li&gt;
  &lt;li&gt;永久的存储能力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;访问外存储器上的数据比访问内存要慢5 ~ 6 个数量级&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，要求我们在开发系统时必须考虑如何使外存访&lt;br&gt;问次数达到最少。&lt;/p&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Data-Structures" scheme="http://ucasfl.me/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>内部排序</title>
    <link href="http://ucasfl.me/2017/08/08/Inner-Sort/"/>
    <id>http://ucasfl.me/2017/08/08/Inner-Sort/</id>
    <published>2017-08-08T04:51:50.000Z</published>
    <updated>2017-09-02T04:38:29.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3>
<ul>
  <li>排序:将一组杂乱无章的数据按一定的规律顺次排列起来。</li>
</ul>
<p>假设含 n 个记录的序列为 { R1, R2, … , Rn }其相应的关键字序列为 { K1, K2, … , Kn }这些关键字相互之间可以进行比较,即在它们之间存在着这样一个关系 :</p>
<p>Kp1≤Kp2≤…≤Kpn<br>按此固有关系将上式记录序列重新排列,即使序列成为一个按关键字排序的 序列:{ Rp1, Rp2, … , Rpn }的操作称作排序。</p>
<ul>
  <li>排序算法的稳定性 : 当输入含重复关键字时,重复元素在输入、输出序列中的相对次序是否保持不变。</li>
  <li>内排序与外排序 : 内排序是指在 整个排序过程 数据元素全部存放在内存、 不需要访问外存便能完成 的排序, 称此类排序为内部排序 ; 反之,若参加排序的记录数量很大 ,不能同时存放在内存,必须根据排序过程的要求,不断在内、外存之间移动的排序, 称为外部排序。</li>
  <li>排序算法的分类 :内部排序算法很多。但就其全面性能而言,很难认为哪种方法是最好的。没一种方法都有各自的优缺点,适合在不同环境下使用。插入排序、交换排序、选择排序、归并排序、计数排序等等 &lt; 按排序过程中依据的不同原则 &gt;</li>
</ul>
<a id="more"></a>
<p><strong>待排记录数据类型定义</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">//待排记录的数据类型定义如下 :</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000 <span class="comment">// 待排顺序表最大长度</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType; <span class="comment">// 关键字类型为整数类型</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  KeyType key;<span class="comment">// 关键字项</span></div><div class="line">  InfoType otherinfo; <span class="comment">// 其它数据项</span></div><div class="line">&#125; RcdType;<span class="comment">// 记录类型</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  RcdType r[MAXSIZE+<span class="number">1</span>]; <span class="comment">// r[0] 闲置</span></div><div class="line">  <span class="keyword">int</span> length;<span class="comment">// 顺序表长度</span></div><div class="line">&#125; SqList;<span class="comment">// 顺序表类型</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3>
<p>基于交换的排序方法。</p>
<ul>
  <li>观察：有序/无序序列中，任意/总有一对相邻元素顺序/逆序</li>
  <li>扫描交换：依次比较每一对相邻元素，如有必要，交换之</li>
</ul>
<p>经一轮扫描交换后，最大元素必然就位；经一轮扫描交换后，问题的规模缩减至n-1。</p>
<ul>
  <li>若整趟扫描都没有进行交换，则排序完成。</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(Elem R[ ], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">   i = n;<span class="comment">//首先从n位置排序</span></div><div class="line">   <span class="keyword">bool</span> sorted = <span class="literal">false</span>;</div><div class="line">   <span class="keyword">while</span> (!sorted) &#123;<span class="comment">//第[i..n]大元素已排序，寻找 第i-1大元素</span></div><div class="line">         sorted = <span class="literal">true</span>;</div><div class="line">         <span class="keyword">for</span> (j = <span class="number">1</span>;  j &lt; i;  j++) <span class="comment">//从[1..i-1]寻找第i-1大元素</span></div><div class="line">             <span class="keyword">if</span> (R[j+<span class="number">1</span>].key &lt; R[j].key) &#123; <span class="comment">//将大的记录向后移</span></div><div class="line">                  Swap(R[j], R[j+<span class="number">1</span>]);</div><div class="line">                  sorted = <span class="literal">false</span>;  <span class="comment">//记下进行交换的记录位置</span></div><div class="line">             &#125; <span class="comment">//if</span></div><div class="line">         i -= <span class="number">1</span>;</div><div class="line">   &#125; <span class="comment">// while</span></div><div class="line">&#125; <span class="comment">// BubbleSort</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(Elem R[ ], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> i = n;<span class="comment">//首先从n位置排序</span></div><div class="line">   <span class="keyword">while</span> (i &gt;<span class="number">1</span>) &#123;<span class="comment">//第[i..n]大元素已排序，寻找 第i-1大元素</span></div><div class="line">         <span class="keyword">int</span>  lastExchangeIndex = <span class="number">1</span>;</div><div class="line">         <span class="keyword">for</span> (j = <span class="number">1</span>;  j &lt; i;  j++) <span class="comment">//从[1..i-1]寻找第i-1大元素</span></div><div class="line">             <span class="keyword">if</span> (R[j+<span class="number">1</span>].key &lt; R[j].key) &#123; <span class="comment">//将大的记录向后移</span></div><div class="line">                  Swap(R[j], R[j+<span class="number">1</span>]);</div><div class="line">                  lastExchangeIndex = j;  <span class="comment">//记下进行交换的记录位置</span></div><div class="line">             &#125; <span class="comment">//if</span></div><div class="line">         i = lastExchangeIndex; <span class="comment">//本趟进行过交换的最后一个记录的位置</span></div><div class="line">   &#125; <span class="comment">// while</span></div><div class="line">&#125; <span class="comment">// BubbleSort</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>时间复杂度</strong></p>
<ul>
  <li>最好情况：O(n)；最坏情况：O(n^2)</li>
</ul>
<p><strong>稳定性</strong></p>
<ul>
  <li>稳定</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3>
<ul>
  <li>基本方法:分而治之，序列一分为二 //O(1)；子序列递归排序 //2×T(n/2)；合并有序子序列 //O(n)</li>
  <li>归并排序算法的复杂度为 O(nlogn)</li>
  <li>关键在于 merge 的实现</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span> <span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> hi )</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (hi-lo&lt;<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span>; <span class="comment">// 单个元素区间自然有序</span></div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    mi = (low+hi)/<span class="number">2</span>; <span class="comment">// 以中点为界</span></div><div class="line">    mergesort (low, mi); <span class="comment">// 将前半段排序</span></div><div class="line">    mergesort (mi+<span class="number">1</span>, hi); <span class="comment">// 对后半段排序</span></div><div class="line">    Merge (low, mi, hi); <span class="comment">// 归并</span></div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">// Msort</span></div><div class="line"></div><div class="line"><span class="comment">//二路归并算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span> <span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">  RcdType *A = elements+low;</div><div class="line">  <span class="keyword">int</span> lb = mi-low; </div><div class="line">  RcdType *B = <span class="keyword">new</span> RcdType[<span class="number">1b</span>];</div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;lb; B[i] = A[i++]);</div><div class="line">  <span class="keyword">int</span> lc = hi-mi;</div><div class="line">  RcdType *C = elements+mi;</div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>; j&lt;lb || k&lt;lc; ) &#123;</div><div class="line">    <span class="keyword">if</span> ( (j&lt;lb) &amp;&amp; (lc&lt;=k || B[j].key&lt;=C[k].key) )</div><div class="line">      A[i++] = B[j++];</div><div class="line">    <span class="keyword">if</span> ( (k&lt;lc) &amp;&amp; (lb&lt;=j || C[k].key&lt;B[j].key) )</div><div class="line">      A[i++] =C[k++];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">delete</span>(B);</div><div class="line">&#125;<span class="comment">//Merge</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>算法分析</strong></p>
<p>优点：</p>
<ul>
  <li>最坏情况下最优 O(nlogn) 性能的第一个排序算法</li>
  <li>不需要随机读写,完全顺序访问 - 尤其适用于列表之类的序列，磁带之类的设备</li>
  <li>只要实现恰当,可保证稳定</li>
  <li>可扩展性极佳,十分适宜于外部排序 - 海量网页搜索结果的归并易于并行化</li>
  <li>稳定的排序算法。</li>
</ul>
<p>缺点：</p>
<ul>
  <li>需要对等规模的辅助空间</li>
  <li>即便输入完全(或者接近)有序,仍需 O(nlogn) 时</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3>
<ul>
  <li>基本方法: 始终将序列看作两部分sorted + unsorted，L[0, r]+L[r, n}</li>
</ul>
<ul>
  <li>初始条件：r=0;</li>
</ul>
<ul>
  <li>迭代: 处理 e=L[r]，在 sorted 中确定当前元素 e 的适当位置,插入 e ,得到有序的 L[0, r]</li>
  <li>不变性:随着 r 的递增, L[0, r) 始终有序,直到 r =n, L 即为整体有序</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span> <span class="params">( SqList &amp;L )</span> </span>&#123;</div><div class="line"><span class="comment">// 对顺序表 L 作插入排序</span></div><div class="line">  <span class="keyword">for</span> ( i=<span class="number">2</span>; i&lt;=L.length; ++i ) <span class="comment">// 逐个将 i 插入已排好 [1..i-1] 中</span></div><div class="line">    <span class="keyword">if</span> (L.r[i].key &lt; L.r[i<span class="number">-1</span>].key) &#123; <span class="comment">// 只有小于时需要改变位置</span></div><div class="line">      p = search(L.r[i], i, L);</div><div class="line">      L.r[p] = L.r[i];</div><div class="line">    &#125;</div><div class="line">&#125; <span class="comment">// InsertSort</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>算法分析</strong></p>
<p>最坏情况：O(n)；</p>
<p>最好情况：O(n^2)；</p>
<p>稳定的排序算法。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3>
<ul>
  <li>起泡排序之所以需要O(n2)时间，是因为为挑选每个当前最大的元素M，需做O(n)次比较和O(n)次交换</li>
  <li>实际上经过O(n)次比较确定M后，一次交换足矣</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span> <span class="params">(Elem R[], <span class="keyword">int</span> n )</span> </span>&#123;</div><div class="line">   <span class="comment">// 对记录序列R[1..n]作简单选择排序。</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;n; ++i) &#123;</div><div class="line">        <span class="comment">// 选择第 i 小的记录，并交换到位</span></div><div class="line">       j = SelectMinKey(R, i); </div><div class="line">        <span class="comment">// 与第 i 个记录交换</span></div><div class="line">       <span class="keyword">if</span> (i!=j)</div><div class="line">         <span class="keyword">int</span> t = R[i];</div><div class="line">         R[i] = R[j];</div><div class="line">         R[j] = t;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">// SelectSort</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>算法分析</strong></p>
<ul>
  <li>共迭代n次，在第k次迭代中SelectMinKey的复杂度O(n-k)</li>
  <li>SelectMinKey的复杂度可以降至O(logn)</li>
</ul>
<h4 id="树形选择排序-锦标赛排序"><a href="#树形选择排序-锦标赛排序" class="headerlink" title="树形选择排序/锦标赛排序"></a>树形选择排序/锦标赛排序</h4>
<ul>
  <li>一种按照锦标赛思想进行选择排序的方法。这个过程可以用一棵有 n 个叶子结点的完全二叉树表示：叶节点:待排序元素(选手)；内部节点:孩子中的胜者；</li>
</ul>
<p>这种比赛树又称为胜者树。</p>
<ul>
  <li>锦标赛选择</li>
</ul>
<p>更新:唯上一优胜者的祖先,才有必要重新参加比赛，只需从其所在叶节点出发,逐层上溯直到树根。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3>
<p>堆是满足下列性质的数列：${r_1, r_2, …, r_n}$</p>
<p>$$\text{小顶堆}=\begin{cases} r<em>i\le r</em>{2i}\r<em>i \le r</em>{2i+1}\end{cases}$$</p>
<p>$$\text{大顶堆}=\begin{cases}r<em>i \ge r</em>{2i}\r<em>i \ge r</em>{2i+1}\end{cases}$$</p>
<p>堆的结构性 :</p>
<ul>
  <li>逻辑上:等同于完全二叉树</li>
  <li>物理上:直接借助顺序存储实现</li>
</ul>
<p>堆的堆序性：堆是符合这样定义的一棵有局部顺序的线性化完全二叉树：$K[i]\le K[parent(i)]$或$K[i]\ge K[parent(i)]$</p>
<p><strong>优先级队列(PQ priority queue)</strong></p>
<p>队列的一种，不过它可以按照自定义的一种方式（数据的优先级）来对队列中的数据进行态的访问，以方便快速求取最大优先级的数据。</p>
<ul>
  <li>栈和队列，都是PQ的特例——优先级完全取决于元素的插入次序</li>
  <li>应用：操作系统中的任务调度、中断处理、离散事件模拟等等</li>
  <li>作为底层数据结构所支持的高效操作，是很多高效算法的基础</li>
</ul>
<p><strong>完全二叉堆：插入</strong></p>
<p>为插入一个新的元素 e ,只需将 e 作为末元素放入原顺序结构。</p>
<ul>
  <li>唯一可能违反堆序性的只有该新节点和它的父亲。</li>
  <li>只需从其所在叶节点出发,逐层上溯直到满足堆序性【上滤】。</li>
</ul>
<p>效率：</p>
<ul>
  <li>e 与父亲的交换,每次只需 o(1) 时间,且每经过一次交换, e 都会上升一层;</li>
  <li>在插入新节点 e 的整个过程中,只有 e 的祖先们才有可能需要参与交换;</li>
  <li>堆是一棵完全树,必平衡,故 e 的祖先至多 o(logn)</li>
</ul>
<p>所以，通过上滤,可在 O(logn) 时间内插入一个新节点,并整体的重新调整为堆。</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">//插入和上滤</span></div><div class="line">Insert(Sqlist  &amp;heap,   RedType e)&#123;</div><div class="line">  heap.r[heap.length] = e;      </div><div class="line">  heap.length += <span class="number">1</span>;</div><div class="line">  percolateUp(heap, heap.length);</div><div class="line">&#125; </div><div class="line">percolateUp(Sqlist &amp;heap, <span class="keyword">int</span> i)&#123;</div><div class="line">  <span class="keyword">while</span> ( ParentValid(i) )&#123;</div><div class="line">    j = Parent（i）；</div><div class="line">      <span class="keyword">if</span> ( heap.r[i].key &gt; heap.r[j].key )  </div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      swap(heap.r[i], heap.r[j]);  i = j;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>完全二叉堆：删除</strong></p>
<p>最大元素始终在堆顶,故删除只需摘除首元素,代之以末元素 e；// 结构性自然保持,<br>那堆序性如何保持?</p>
<ul>
  <li>唯一可能违反堆序性的只有该节点e 和它的孩子们。</li>
  <li>只需从根节点出发,与孩子中的大者换位,逐层下滤直到满足堆</li>
</ul>
<p>效率:<br>通过下滤,可在 O(logn) 时间内删除堆顶节点,并整体地重新调整为堆。</p>
<p><strong>建堆</strong></p>
<ul>
  <li>自上而下的上滤</li>
  <li>建堆可以是一个从空堆开始,依次插入各元素。</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">Heapify(Sqlist &amp;L)&#123;</div><div class="line">  <span class="keyword">for</span> (i =<span class="number">1</span>; i&lt;L.length; i++)</div><div class="line">    percolateUp(L, i) ; <span class="comment">// 经上滤插入各节点</span></div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>效率: 在最坏情况下,每个元素都需上滤到根节点,所以时间复杂度是O(nlogn) 。</p>
<ul>
  <li>自下而上的下滤</li>
  <li>给定堆 H0 、 H1 和节点 P,为了得到堆 H0 UPU H1 ,只需将 ra(H0的堆顶) 和 rb(H1的堆顶) 当作 P 的孩子,对 p 下滤</li>
  <li>从下向上,子堆逐层合并</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">Heapify(Sqlist &amp;L)&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = L.length/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)</div><div class="line">    percolateDown(L, i) ; <span class="comment">// 下滤各内部节点</span></div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>效率：时间复杂度为O(n)</p>
<p><strong>堆排序即是利用堆的特性,不断输出当前最小( 大 ) 值,从而实现对序列进行排序的一种排序方法。</strong></p>
<p><strong>堆排序是不稳定的排序算法。</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">//堆排序算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span> <span class="params">(Sqlist &amp;L )</span> </span>&#123;</div><div class="line"><span class="comment">// 对顺序表 L 进行堆排序</span></div><div class="line">  Heapify ( L ); <span class="comment">// 建大顶堆</span></div><div class="line">  <span class="keyword">for</span> ( i=H.length; i&gt;<span class="number">1</span>; --i ) &#123;</div><div class="line">    <span class="keyword">int</span> t = H.r[<span class="number">0</span>];</div><div class="line">    H.r[<span class="number">0</span>] = H.r[i];</div><div class="line">    H.r[i] = t; <span class="comment">// 将堆顶记录和当前未经排序子序列H.r[1..i] 中最后一个记录相互交换堆</span></div><div class="line">  &#125;</div><div class="line">  percolateDown(L, <span class="number">0</span>) ; <span class="comment">// 对 H.r[0..i-1] 调整,成为新堆</span></div><div class="line">&#125; <span class="comment">// HeapSort</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>算法分析：</p>
<ul>
  <li>堆排序的时间复杂度为 O(nlogn) 。</li>
  <li>堆排序方法对 n 较大的文件是很有效的。</li>
</ul>
<p><strong>左式堆</strong></p>
<p>左式堆是一棵单侧倾斜的树:</p>
<ul>
  <li>节点分布偏向左侧</li>
  <li>合并操作只涉及右侧</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">//左式堆的合并</span></div><div class="line"><span class="function">BiNode *<span class="title">Merge</span><span class="params">(BiNode *a, *b)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> ( !a)</div><div class="line">      <span class="keyword">return</span> b;</div><div class="line">    <span class="keyword">if</span> (!b)</div><div class="line">      <span class="keyword">return</span> a;</div><div class="line">    <span class="keyword">if</span> ( a-&gt;data&lt;=b-&gt;data ) </div><div class="line">      swap( b, a);<span class="comment">//一般确保b不大，确保堆序性</span></div><div class="line">    a-&gt;rchild = merge(a-rchild, b); <span class="comment">//将a的右子堆与b合并</span></div><div class="line">    a-&gt;rchild-&gt;parent = a;<span class="comment">//更新父子关系</span></div><div class="line">    <span class="keyword">if</span> ( !a-&gt;lchild || a-&gt;lchild-&gt;NPL &lt; a-&gt;rchild-&gt;NPL )</div><div class="line">       swap( a-&gt;lchild, a-&gt;rchild );</div><div class="line">    a-&gt;NLP = a-&gt;rc ? A-&gt;rchild-&gt;NPL+<span class="number">1</span>: <span class="number">1</span>;<span class="comment">//更新父节点的NPL</span></div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"><span class="comment">//左式堆的插入 insert( )</span></div><div class="line"><span class="function">BiNode *<span class="title">insert</span><span class="params">(BiNode *a, e)</span></span>&#123;</div><div class="line">  BiNode *v = <span class="keyword">new</span> BiNode(e);</div><div class="line">  root= merge(a, v);</div><div class="line">  root-&gt;parent = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//左式堆的最大元素的删除DelMax</span></div><div class="line"><span class="function">BiNode *<span class="title">insert</span><span class="params">(BiNode *root)</span></span>&#123;</div><div class="line">  BiNode *lHeap = root-&gt;lChild ;BiNode *rHeap = root-&gt;rChild;</div><div class="line">  e = root-&gt;data;</div><div class="line">  <span class="keyword">delete</span> root;</div><div class="line">  root = merge( lHeap,rHeap);</div><div class="line">  <span class="keyword">if</span> ( root ) </div><div class="line">    root-&gt;parent = <span class="literal">NULL</span>;</div><div class="line">  <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3>
<ul>
  <li>分治策略的再一次体现</li>
  <li>将序列分为两个子序列: S = SL +SR；规模缩小: max{|SL|,|SR|}&lt;n；彼此独立: max(SL ) &lt;= min(SR )</li>
  <li>在子序列分别递归地排序后,原序列自然有序</li>
  <li>平凡解:当只剩单个元素时,本身就是解</li>
  <li>QuickSort 的难点在于“分” [ 归并排序 ]</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span> <span class="params">(RedType &amp; R[],  <span class="keyword">int</span> s,  <span class="keyword">int</span>  t )</span> </span>&#123;</div><div class="line">    <span class="comment">// 对记录序列R[s..t]进行快速排序</span></div><div class="line">    <span class="keyword">if</span> (s &lt; t<span class="number">-1</span>) &#123;             <span class="comment">// 长度大于1</span></div><div class="line">        pivotloc = Partition(R, s, t); <span class="comment">// 对 R[s..t] 进行一次划分</span></div><div class="line">        QSort(R, s, pivotloc<span class="number">-1</span>);  <span class="comment">// 对低子序列递归排序</span></div><div class="line">        QSort(R, pivotloc+<span class="number">1</span>, t); <span class="comment">// 对高子序列递归排序</span></div><div class="line">    &#125;</div><div class="line">&#125; <span class="comment">// QSort</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">( SqList &amp; L)</span> </span>&#123;</div><div class="line">      <span class="comment">// 对顺序表进行快速排序</span></div><div class="line">       QSort(L.r, <span class="number">1</span>, L.length);</div><div class="line">&#125; <span class="comment">// QuickSort</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span> <span class="params">(RedType&amp; R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">  pivotkey = R[low].key; <span class="comment">// 枢轴</span></div><div class="line">  <span class="keyword">while</span> (low&lt;high) &#123;</div><div class="line">    <span class="keyword">while</span> (low&lt;high &amp;&amp; R[high].key&gt;=pivotkey)</div><div class="line">      --high;</div><div class="line">    R[low]=R[high];</div><div class="line">    <span class="keyword">while</span> (low&lt;high &amp;&amp; R[low].key&lt;=pivotkey)</div><div class="line">      ++low;</div><div class="line">    R[high]=R[low];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> low;<span class="comment">// 返回枢轴所在位置</span></div><div class="line">&#125; <span class="comment">// Partition</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition2</span> <span class="params">(RedType&amp; R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">  pivotkey = R[low].key; <span class="comment">// 枢轴</span></div><div class="line">  mid = low;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = low+<span class="number">1</span>; k&lt;=high; k++)</div><div class="line">    <span class="keyword">if</span> (R[k].key&lt;pivotkey)</div><div class="line">      swap(R[++mid], R[k]);</div><div class="line">  swap(R[low], R[mid]);</div><div class="line"><span class="keyword">return</span> mid;<span class="comment">// 返回枢轴所在位置</span></div><div class="line">&#125; <span class="comment">// Partition例:</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3>
<p>又称“缩小增量排序”，将记录序列分成若干子序列，分别对每个子序列进行插入排序。</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span> <span class="params">(SqList &amp;L, <span class="keyword">int</span> dlta[], <span class="keyword">int</span> t)</span></span>&#123;</div><div class="line"><span class="comment">// 增量序列为 dlta[] 的希尔排序,序列长为 t</span></div><div class="line">  <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;t; ++t)</div><div class="line">    ShellInsert(L, dlta[k]);</div><div class="line">&#125; <span class="comment">// ShellSort</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsert</span> <span class="params">( SqList &amp;L, <span class="keyword">int</span> dk )</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> ( i=dk+<span class="number">1</span>; i&lt;=n; ++i )<span class="comment">// 对每个元素在当前增量子序列中排序</span></div><div class="line">    <span class="keyword">if</span> ( L.r[i].key&lt; L.r[i-dk].key) &#123;<span class="comment">// 在子序列中用直接插入法排序当前元素</span></div><div class="line">      L.r[<span class="number">0</span>] = L.r[i];</div><div class="line">      <span class="keyword">for</span> (j=i-dk; j&gt;<span class="number">0</span>&amp;&amp;(L.r[<span class="number">0</span>].key&lt;L.r[j].key); j-=dk)</div><div class="line">        L.r[j+dk] = L.r[j]; <span class="comment">// 记录后移,查找插入位置</span></div><div class="line">      L.r[j+dk] = L.r[<span class="number">0</span>]; <span class="comment">// 插入</span></div><div class="line">    &#125; <span class="comment">// if</span></div><div class="line">&#125; <span class="comment">// ShellInsert</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>算法分析</strong></p>
<p>希尔排序是一种不稳定的插入排序方法。</p>
<ul>
  <li>希尔排序的时间复杂性与各列内部排序的算法 ( 插入 ) 由关。内部排序不一定是高效的,但需要是 input-sensitive</li>
  <li>但其实际运行的时间更多地取决于所取“增量”序列的有关,涉及数学上尚未解决的难题。</li>
</ul>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3>
<p>基数排序是一种借助“多关键字排序”的思想来实现“单关键字排序”的内部排序算法。</p>
<p>实现多关键字排序通常有两种作法 :</p>
<p>关键字${K^0&gt;K^1&gt;…&gt;K^{d-1}}$</p>
<ul>
  <li>最高位优先 MSD 法 (Most Significant Digit first ) </li>
</ul>
<p>先对 K 进行排序,按 $K^0$ 的不同值将记录序列分成若干子序列之后,分别对 $K^1$ 进行排,…,最后对最次位关键字排序。</p>
<ul>
  <li>最低位优先 LSD 法 (Least Significant Digit first)</li>
</ul>
<p>先对$ K^{d-1}$ 进行排序,然后对$ K^{d-2}$ 进行排序, …, 最后对最主位关键字 $K^0 $排序。</p>
<p><strong>对比</strong></p>
<p>最高位优先法</p>
<ul>
  <li>必须将序列逐层分割为若干子序列,然后对各子序列分别进行排序 。</li>
</ul>
<p>最低位优先法</p>
<ul>
  <li>使用这种排序方法对每一个关键字进行排序时,不必分成子序列,对每个关键字都是整个序列参加排序。</li>
  <li>按 LSD 排序时,可以通过若干次“分配”和“收集”来实现排序。其好处是不需要进行关键字间的比较。</li>
</ul>
<p><strong>实现</strong></p>
<p>在计算机上实现基数排序时,为减少所需辅助存储空间,应采用链表作存储结构,即链式基数排序,具体作法为:</p>
<ol>
  <li>待排序记录以指针相链,构成一个链表;</li>
  <li>“分配” 时,按当前“关键字位”所取值,将记录分配到不同的 “链队列” 中,每个队列中记录的 “关键字位” 相同;</li>
  <li>“收集”时,按当前关键字位取值从小到大将各队列首尾相链成一个链表 ；</li>
  <li>对每个关键字位均重复 2) 和 3) 两步。</li>
</ol>
<p><strong>链表基数排序算法</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM_OF_KEY 8</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RADIX 10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SPACE 10000</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</div><div class="line">   KeysType keys[MAX_NUM_OF_KEY];</div><div class="line">   InfoType otheritems;</div><div class="line">   <span class="keyword">int</span> next;</div><div class="line">&#125;SLCell;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</div><div class="line">   SLCell r[MAX_SPACE];</div><div class="line">   <span class="keyword">int</span> keynum;</div><div class="line">   <span class="keyword">int</span> recnum;</div><div class="line">&#125;SLList;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArrType[RADIX];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Distribute</span><span class="params">(SLCell &amp;r, <span class="keyword">int</span> I, ArrType &amp;f, ArrType &amp;e)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;RADIX; ++j) f[j] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (p=r[<span class="number">0</span>].next; p; p= r[p].next)&#123;</div><div class="line">           j = r[p].keys[i];</div><div class="line">           <span class="keyword">if</span> (!f[j])  f[j] = p;</div><div class="line">           <span class="keyword">else</span>  r[e[j]].next = p;</div><div class="line">           e[j] = p;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function">Void <span class="title">Collect</span><span class="params">(SLCell &amp;r, <span class="keyword">int</span> I, ArrType f, ArrType e)</span></span>&#123;</div><div class="line">      <span class="keyword">for</span> (j=<span class="number">0</span>; !f[j]; j = succ(j));</div><div class="line">      r[<span class="number">0</span>].next = f[j]; t = e[j];</div><div class="line">      <span class="keyword">while</span> (j&lt;RADIX)&#123;</div><div class="line">                <span class="keyword">for</span> (j=succ(j); j&lt;RADIX<span class="number">-1</span>&amp;&amp;!f[j]; j = succ(j));</div><div class="line">                <span class="keyword">if</span> (f[j]) &#123; r[t].next = f[j]; t = e[j];&#125;</div><div class="line">      &#125;</div><div class="line">      r[t].next = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function">Void <span class="title">Radixsort</span><span class="params">(SLList &amp;L)</span></span>&#123;</div><div class="line">    <span class="comment">//L是静态链表表示的顺序表</span></div><div class="line">    <span class="comment">//对L作基数排序，使得L成为自小到大的有序静态链表</span></div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>；i&lt;L.recnum;；++i）L.r[i].next = i+<span class="number">1</span>；</div><div class="line">    L.r[L.recnum].next = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;L.recnum; ++i)&#123;</div><div class="line">           Distribute(L.r, i,  f, e);</div><div class="line">            Collect(L.r, I, f, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>算法分析</strong></p>
<ul>
  <li>若每个排序码有 d 位 , 需要重复执行 d 趟“分配”与“收集”。每趟对 n 个元素进行“分配”,对 radix 个队列进行“收集”。总时间复杂度为O(d(n+radix))</li>
  <li>若基数 radix 相同 , 对于元素个数较多而排序码位数较少的情况 , 使用链式基数排序较好。</li>
  <li>基数排序需要增加 n+2radix 个附加链接指针。</li>
  <li>基数排序是稳定的排序方法。</li>
</ul>
<h3 id="2-路插入排序"><a href="#2-路插入排序" class="headerlink" title="2-路插入排序"></a>2-路插入排序</h3>
<ul>
  <li>2- 路插入排序是在折半插入排序的基础上进行的改进,目的是减少排序过程中记录移动的次数。</li>
  <li>算法的思想为:另设一个和原始待排序列 L 相同的数组D ,该数组是一个循环向量。首先将 L[1] 复制给 D[1] ,并把 D[1]看成是已排好序的序列中处于中间位置的元素,之后将 L 中的从第二个元素开始依次插入到数组 D 中。</li>
</ul>
<h3 id="表插入排序"><a href="#表插入排序" class="headerlink" title="表插入排序"></a>表插入排序</h3>
<p>为了减少在排序过程中进行的“移动”记录的操作，静态链表结构可以避免元素移动。</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100  </span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  &#123;  </div><div class="line">  RcdType  rc;  </div><div class="line">  <span class="keyword">int</span> next;  </div><div class="line">&#125;SLNode;  </div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  &#123;  </div><div class="line">  SLNode numbers[SIZE];  </div><div class="line">  <span class="keyword">int</span> length;  </div><div class="line">&#125;SLinkList;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LInsertionSort</span> <span class="params">(Elem SL[ ] , <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line"><span class="comment">// 对记录序列 SL[1..n] 作表插入排序</span></div><div class="line">  SL[<span class="number">0</span>].key = MAXINT ;</div><div class="line">  SL[<span class="number">0</span>].next = <span class="number">1</span>; </div><div class="line">  SL[<span class="number">1</span>].next = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> ( i=<span class="number">2</span>; i&lt;=n; ++i )&#123; <span class="comment">// 逐个将 i 插入已排好 [1..i-1] 中</span></div><div class="line">    <span class="keyword">for</span> ( j=<span class="number">0</span>, k = SL[<span class="number">0</span>].next; SL[k].key&gt;=SL[i].key ;j=k, k=SL[k].next ); <span class="comment">// 从表头开始寻找插入位置</span></div><div class="line">    SL[j].next = i;</div><div class="line">    SL[i].next = k;</div><div class="line">  &#125;</div><div class="line">&#125;<span class="comment">// LinsertionSort</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>表插入排序的结果只是求得一个有序链表。为了方便查找，需要对结果进行重新排列求得一个有序数组。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3>
<p>各种排序方法之间的比较：</p>
<table>
  <thead>
    <tr>
      <th>排序方法</th>
      <th>比较次数(最好)</th>
      <th>比较次数(最差)</th>
      <th>移动次数(最好)</th>
      <th>移动次数(最差)</th>
      <th>稳定性</th>
      <th>附加存储</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>直接插入排序</td>
      <td>n</td>
      <td>n^2</td>
      <td>0</td>
      <td>n^2</td>
      <td>稳定</td>
      <td>1</td>
    </tr>
    <tr>
      <td>冒泡排序</td>
      <td>n</td>
      <td>n^2</td>
      <td>0</td>
      <td>n^2</td>
      <td>稳定</td>
      <td>1</td>
    </tr>
    <tr>
      <td>快速排序</td>
      <td>nlog2n</td>
      <td>n^2</td>
      <td>log2n</td>
      <td>n</td>
      <td>不稳定</td>
      <td>log2n</td>
    </tr>
    <tr>
      <td>堆排序</td>
      <td>nlog2n</td>
      <td></td>
      <td>nlog2n</td>
      <td></td>
      <td>不稳定</td>
      <td>1</td>
    </tr>
    <tr>
      <td>归并排序</td>
      <td>nlog2n</td>
      <td></td>
      <td>nlog2n</td>
      <td></td>
      <td>稳定</td>
      <td>n</td>
    </tr>
  </tbody>
</table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;排序:将一组杂乱无章的数据按一定的规律顺次排列起来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设含 n 个记录的序列为 { R1, R2, … , Rn }其相应的关键字序列为 { K1, K2, … , Kn }这些关键字相互之间可以进行比较,即在它们之间存在着这样一个关系 :&lt;/p&gt;
&lt;p&gt;Kp1≤Kp2≤…≤Kpn&lt;br&gt;按此固有关系将上式记录序列重新排列,即使序列成为一个按关键字排序的 序列:{ Rp1, Rp2, … , Rpn }的操作称作排序。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;排序算法的稳定性 : 当输入含重复关键字时,重复元素在输入、输出序列中的相对次序是否保持不变。&lt;/li&gt;
  &lt;li&gt;内排序与外排序 : 内排序是指在 整个排序过程 数据元素全部存放在内存、 不需要访问外存便能完成 的排序, 称此类排序为内部排序 ; 反之,若参加排序的记录数量很大 ,不能同时存放在内存,必须根据排序过程的要求,不断在内、外存之间移动的排序, 称为外部排序。&lt;/li&gt;
  &lt;li&gt;排序算法的分类 :内部排序算法很多。但就其全面性能而言,很难认为哪种方法是最好的。没一种方法都有各自的优缺点,适合在不同环境下使用。插入排序、交换排序、选择排序、归并排序、计数排序等等 &amp;lt; 按排序过程中依据的不同原则 &amp;gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Data-Structures" scheme="http://ucasfl.me/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>查找和搜索-Part3</title>
    <link href="http://ucasfl.me/2017/08/07/Find-and-Search-Part3/"/>
    <id>http://ucasfl.me/2017/08/07/Find-and-Search-Part3/</id>
    <published>2017-08-07T04:51:28.000Z</published>
    <updated>2017-09-02T04:38:29.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="键树-数字查找树"><a href="#键树-数字查找树" class="headerlink" title="键树 / 数字查找树"></a>键树 / 数字查找树</h3>
<p>Keyword Tree/Digital Search Tree 是关键字的一种组织方式,其具有下列特征:</p>
<ul>
  <li>( 结点 ) 树的结点包含组成关键字的符号，关键字中的各个符号分布在从根结点到叶的路径上,叶结点内的符号为“结束”的标志符。</li>
  <li>键树的深度和关键字集合的大小无关,取决于关键字中字符或数位的个数</li>
  <li>( 多叉 ) 度大于 2 的树，每个结点的最大度与关键字的“基”有关</li>
  <li>( 排序 ) 键树被约定为是一棵有序树,即同一层中兄弟结点之间依所含符号自左至右有序,并约定结束符‘ $’ 小于任何其它符号。</li>
</ul>
<p><strong>键树的存储结构:双链树</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> DLTNode &#123;</div><div class="line">  <span class="keyword">char</span> symbol;</div><div class="line">  <span class="keyword">struct</span> DLTNode *next; <span class="comment">// 指向兄弟结点的指针</span></div><div class="line">  NodeKind kind;</div><div class="line">  <span class="keyword">union</span> &#123;</div><div class="line">    Record *infoptr; <span class="comment">// 叶子结点内的记录指针</span></div><div class="line">    <span class="keyword">struct</span> DLTNode *first;</div><div class="line"><span class="comment">// 分支结点内的孩子链指针</span></div><div class="line">  &#125;</div><div class="line">&#125; DLTNode, *DLTree; <span class="comment">// 双链树的类型</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<a id="more"></a>
<p><strong>在双链树中查找记录</strong></p>
<ul>
  <li>假设: T 为指向双链树根结点的指针, K.ch 为待查关键字 ( 由 k.ch[0]..k.ch[num-2] 的字符组成, k.ch[num-1] 为 $)</li>
  <li>查找过程: 从树根出发,沿 first 指针到结点 p ,进行比较K.ch[i] =? p-&gt;symbol ,其中, 0 ≤ i ≤ K.num-1， 若相等,沿 first 指针比较下一个字符， 若不等,沿 next 指针顺序查找</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXKEYLEN 20</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  <span class="keyword">char</span> ch[MAXKEYLEN]; <span class="comment">// 关键字</span></div><div class="line">  <span class="keyword">int</span> num;</div><div class="line"><span class="comment">// 关键字长度</span></div><div class="line">&#125; KeysType;</div><div class="line"><span class="comment">// 关键字类型</span></div><div class="line"><span class="function">RECORD *<span class="title">SearchDLTree</span><span class="params">(DLTree T, KeysType K)</span> </span>&#123;</div><div class="line">  DLTree p; <span class="keyword">int</span> i;</div><div class="line">  p = T-&gt;first; i=<span class="number">0</span>; <span class="comment">// 初始化</span></div><div class="line">  <span class="keyword">while</span> (p &amp;&amp; i&lt;K.num) &#123;</div><div class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;symbol != K.ch[i]) <span class="comment">// 查找关键字的第 i 位</span></div><div class="line">      p = p-&gt;next;</div><div class="line">    <span class="keyword">if</span> (p &amp;&amp; i&lt;K.num<span class="number">-1</span>) </div><div class="line">      p = p-&gt;first; <span class="comment">// 准备查找下一位</span></div><div class="line">    ++i; </div><div class="line">  &#125; <span class="comment">// 查找结束</span></div><div class="line">  <span class="keyword">if</span> (!p) </div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 查找不成功</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> p-&gt;infoptr; <span class="comment">// 查找成功</span></div><div class="line">&#125; <span class="comment">//Search DLTree</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>键树的存储结构: Trie 树</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> TrieNode &#123;</div><div class="line">  NodeKind kind; <span class="comment">// 结点类型</span></div><div class="line">  <span class="keyword">union</span> &#123;</div><div class="line">    <span class="keyword">struct</span> &#123; </div><div class="line">      KeyType K;</div><div class="line">      Record *infoptr</div><div class="line">    &#125; lf;</div><div class="line"><span class="comment">// 叶子结点 ( 关键字和指向记录的指针 )</span></div><div class="line">    <span class="keyword">struct</span> &#123;</div><div class="line">      TrieNode *ptr[<span class="number">27</span>]; </div><div class="line">      <span class="keyword">int</span> num </div><div class="line">    &#125; bh;</div><div class="line"><span class="comment">// 分支结点 (27 个指向下一层结点的指针 )</span></div><div class="line">  &#125;</div><div class="line">&#125; TrieNode, *TrieTree; <span class="comment">// 键树类型T</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>在Trie树中查找记录</strong></p>
<ul>
  <li>假设 :</li>
</ul>
<p>– T 为指向 Trie 树根结点的指针, K.ch 为待查关键字 ( 由 k.ch[0]..k.ch[num-2] 的字符组成, k.ch[num-1] 为 $)</p>
<ul>
  <li>查找过程:</li>
</ul>
<p>– 从树根出发,搜索和对应字母相应的指针 p:<br>– 若 p 不空,且 p 所指为分支结点,则<br>– p= p-&gt;bh.ptr[ord(K.ch[i])] ( 其中, ord 给出字符<br>在字母表中的序号, 0 ≤ i ≤ K.num-1 )<br>– 沿 p 指针比较下一个字符,直到叶子结点<br>– 若未找到 p ,则查找不成功</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">//在键树 T 中查找关键字等于 K 的记录</span></div><div class="line"><span class="comment">//ord 求字符在字母表中序号</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ord</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> c-<span class="string">'@'</span>; </div><div class="line">&#125;</div><div class="line"><span class="function">RECORD *<span class="title">SearchTrie</span><span class="params">(TrieTree T, KeysType K)</span> </span>&#123;</div><div class="line">  TrieTree p; <span class="keyword">int</span> i;</div><div class="line"><span class="comment">// 对 K 的每个字符逐个查找, *p 为分支结点</span></div><div class="line">  <span class="keyword">for</span> (p=T, i=<span class="number">0</span>; p &amp;&amp; p-&gt;kind==BRANCH &amp;&amp; i&lt;K.num;p=p-&gt;bh.ptr[ord(K.ch[i])], i++) ;</div><div class="line">  <span class="keyword">if</span> (p &amp;&amp; p-&gt;kind==LEAF &amp;&amp;<span class="built_in">strcmp</span>(p-&gt;lf.K.ch, K.ch)==<span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> p-&gt;lf.infoptr; <span class="comment">// 查找成功</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 查找不成功</span></div><div class="line">&#125; <span class="comment">//SearchTrie</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3>
<p><strong>基本思想</strong></p>
<ul>
  <li>Motivation :已有的查找方法需要进行一系列的指定值与数据元素的关键字的比较</li>
</ul>
<p>– 不同的查找其差别在于关键字和给定值进行比较的顺序不同<br>– 原因:数据元素的关键字和数据元素的存储位置之间没有确定的关系<br>– 结果:查找的效率取决于和给定值进行比较的关键字的个数</p>
<ul>
  <li>Solution : ( 通过哈希函数和冲突处理方法 ) 由记录的关键字确定记录在表中的地址,并将记录放入此地址,这样构成的表叫哈希表</li>
</ul>
<p>– 哈希查找 ( 又叫散列查找 ) :通过哈希表中的对应关系进行一次存取,就能得到所查的元素<br>– 特别适用于,只知道关键字的所属范围,但不知道确切的关键字</p>
<p><strong>基本概念</strong></p>
<ul>
  <li>哈希函数:在记录的关键字与记录的存储地址之间建立了一种确定的对应关系</li>
</ul>
<p>– 哈希函数是一种映象,是从关键字空间到存储地址空间的一种映象。<br>– 对于记录 ai , addr(ai) =H(ki) ,其中, addr(ai)是 ai 的地址, ki 是记录 ai 的关键字<br>– 哈希函数通常是一种压缩映象,所以冲突不可避免<br>– 冲突:对于关键字 ki 、 kj ,若 ki!=kj ,但 H(ki)=H(kj) 的现象叫冲突 (collision)<br>– 同义词:具有相同哈希函数值的两个不同的关键字,称为该哈希函数的同义词</p>
<p><strong>哈希表设计要素</strong></p>
<ul>
  <li>确定哈希函数的定义域 ( 所有关键字 ) 和值域(0… m-1)</li>
  <li>构造合适的哈希函数</li>
</ul>
<p>– 使得同一关键字总被映射到同一地址<br>– 使得对于所有可能的元素 ( 记录的关键字 ) ,其函数值能尽可能覆盖整个地址空间且均匀地映射到地址空间</p>
<p>​ - 所谓均匀 (uniform) 是指从一个关键字映射到地址集合中任何一个地址的概率是相等的,即使得发生冲突的可能性尽可能最少</p>
<p>– 哈希函数的构造简单,能在较短的时间内计算出来。</p>
<ul>
  <li>冲突元给出处理冲突的方法,即当冲突出现时如何为冲突元素找到另一个存储位置。</li>
</ul>
<h4 id="哈希函数的构造"><a href="#哈希函数的构造" class="headerlink" title="哈希函数的构造"></a>哈希函数的构造</h4>
<p><strong>直接定址法</strong></p>
<p>直接定址法:取关键字或关键字的某个线性函数作哈希地址,即:H(key)=key 或 H(key)=a·key+b (a,b 为常数 )</p>
<ul>
  <li>特点:直接定址法所得地址集合与关键字集合大小相等,不会发生冲突,但实际中很少使用</li>
  <li>举例:根据年份查找该年份的人口数量</li>
</ul>
<p><strong>数字分析法</strong></p>
<p>数字分析法:若关键字为以 r 为基的数,取关键字的若干位或组合作为哈希地址</p>
<ul>
  <li>特点:适用于关键字位数比哈希地址位数大,且事先知道可能出现的关键字的情况 ( 如频度 )</li>
</ul>
<p><strong>平方取中法</strong></p>
<p>平方取中法:将关键字平方后取中间几位作为哈希地址</p>
<ul>
  <li>哈希函数所取的位数由哈希表的长度决定</li>
</ul>
<ul>
  <li>特点:一个数平方后中间几位和数的每一位都有关,则由随机分布的关键字得到的哈希地址也是随机的</li>
</ul>
<p>– 适用于:不知道全部关键字情况<br>– 适用于:关键字中的每一位都有某些数字重复出现</p>
<p><strong>折叠法</strong></p>
<p>折叠法 (folding) :将关键字分割成位数相同的几部分 ( 最后一部分可以不同 ) ,然后取这几部分的叠加和作为哈希地址</p>
<ul>
  <li>数位叠加有移位叠加和间界叠加</li>
</ul>
<p>– 移位叠加:将分割后的几部分低位对齐相加<br>– 间界叠加:从一端到另一端沿分割界来回折迭,然后对齐相加</p>
<ul>
  <li>特点:适于关键字位数很多,且每一位上数字分布大致均匀</li>
</ul>
<p><strong>除留余数法</strong></p>
<p>除留余数法:取关键字被某个不大于哈希表表长 m 、但最接近于或等于 m 的质数 p 除后所得余数作哈希地址,即:<br>H(key) = key MOD p (p $\le$ m)<br>– 从 p 到 (m-1) 的地址可以在处理冲突的时候用</p>
<ul>
  <li>特点:简单、常用的哈希函数构造方法</li>
  <li>一般,哈希函数可以设成:</li>
</ul>
<p>H(key) =(a*key+b) MOD p (a&gt;0, b&gt;0, a MOD p!=0, p 为素数 )</p>
<p>p的选取：</p>
<ul>
  <li>选取$p=2^i(p\le m)$ :便于用移位来实现运算,但等于将关键字的高位忽略而仅留下低位二进制数,因此,高位不同而低位相同的关键字都成为了同义词</li>
  <li>选取 $p=q\times f$ (q 、 f 都是 p 的质因数, p$\le $m) :则所有含有 q 或 f 因子的关键字的哈希地址均是 q或 f 的倍数</li>
</ul>
<p><strong>随机数法</strong></p>
<p>随机数法:取关键字的随机函数值作哈希地址,即 H(key)=random(key)</p>
<ul>
  <li>当哈希表中关键字长度不等时,该方法比较合适</li>
</ul>
<p><em>选取哈希函数时应考虑的因素</em></p>
<ul>
  <li>计算哈希函数所需时间</li>
  <li>关键字的长度</li>
  <li>哈希表长度 ( 即哈希地址范围 )</li>
  <li>关键字分布情况</li>
  <li>记录的查找频率</li>
</ul>
<h4 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h4>
<p><strong>开放定址法</strong></p>
<ul>
  <li>当冲突发生时,形成某个探测序列;按此序列逐个探测哈希表中的其他地址,直到为给定的关键字找到一个空地址 ( 开放的地址 ) 为止,将发生冲突的记录放到该地址中</li>
  <li>哈希地址的计算公式是:</li>
</ul>
<p>H0 =H(key)<br>Hi (key)=(H(key)+di ) MOD m , i=1, 2, …, m-1<br>– 其中: H(key) 为哈希函数; m 是哈希表长度; Hi (key) 为经第 i 次探测后得到的哈希地址; di 是第 i 次探测时的增量序列</p>
<ul>
  <li>根据 di 的形成方法,有:</li>
</ul>
<p>– 线性探测法 (Linear Probing)<br>– 二次探测法 (Quadratic Probing)<br>– 伪随机探测法: 用伪随机函数获得伪随机数列</p>
<p><em>线性探测法</em></p>
<ul>
  <li>将哈希表 T[0 …m-1] 看成循环向量。当发生冲突时,从初次发生冲突的位置依次向后探测其他的地址,即: 增量序列为: di=1, 2, 3, …, m-1</li>
  <li>设初次发生冲突的地址是 h ,则依次探测 T[h+1] , T[h+2]… ,直到 T[m-1] 时又循环到表头,再次探测 T[0] , T[1]… ,直到 T[h-1]</li>
  <li>探测过程终止的情况:</li>
</ul>
<p>– 探测到的地址为空:表中没有记录。若是查找操作则失败;若是插入操作，则将记录写入到该地址<br>– 探测到的地址有给定的关键字:若是查操作找则成功;若是插入操作则失败<br>– 直到 T[h] :仍未探测到空地址或给定的关键字,则表示哈希表满</p>
<ul>
  <li>线性探测法的特点:</li>
</ul>
<p>– 优点:只要哈希表未满,总能找到一个不冲突的哈希地址<br>– 缺点:二次聚集 ( 两个第一次哈希地址不同的记录争夺同一个后继哈希地址 )</p>
<p><em>二次探测法</em></p>
<ul>
  <li>增量序列为: $d_i=1^2,-1^2,2^2,-2^2,3^2,……+k^2,- k^2 (k\le ⌊ m/2 ⌋ )$</li>
</ul>
<p>– 当 M 是质数,且装填因子小于等于 0.5 ,可以找出空闲地址<br>– 表长 m 形如 4j+3 的质数 ( 如 7, 11, 19, 23, 31, 43, … 等 ) 时,可以保证查找链的前 m 项均互异:基于 费马双平方定理</p>
<ul>
  <li>除了 2 这个特殊的素数,所有的素数都可以分两类:被 4 除余 1 的素数,如 5 , 13 , 17 , 29 , 37 , 41 ,这类素数都能表示为两个整数的平方和;第二类则是被 4 除余 3 的素数如 3, 7 , 11 , 19 , 23 , 31 。这类不能表示为两个整数的平方和。</li>
  <li>优点:探测序列跳跃式地哈希到整个表中,不易产生冲突的聚集现象</li>
  <li>缺点:不能保证探测到哈希表的所有地址</li>
</ul>
<p><strong>再哈希法</strong></p>
<ul>
  <li>构造若干个哈希函数,当发生冲突时,利用不同的哈希函数再计算下一个新哈希地址,直到不发生冲突为止,</li>
</ul>
<p>– 即: Hi =RHi (key) i=1, 2, …, k<br>– 其中, RHi 为一组不同的哈希函数。第一次发生冲突时,用 RH1 计算,第二次发生冲突时,用 RH2 计算,依此类推直到到某个 Hi 不发生冲突为止</p>
<ul>
  <li>优点:不易产生冲突的聚集现象</li>
  <li>缺点:计算时间增加</li>
</ul>
<p><strong>链地址法</strong></p>
<ul>
  <li>将所有关键字为同义词 ( 哈希地址相同 ) 的记录存储在一个单链表中,并用一维数组存放链表的头指针</li>
  <li>设哈希表长为 m ,定义一个一维指针数组: RecNode *linkhash[m] ,其中 RecNode 是结点类型,每个分量的初值为空。凡哈希地址为 k 的记录都插入到以 linkhash[k] 为头指针的链表中,插入位置可以在表头或表尾或按关键字排序插入</li>
  <li>优点:不易产生冲突的聚集;删除记录也很简单</li>
</ul>
<p><strong>建立公共溢出区</strong></p>
<ul>
  <li>在基本哈希表之外,另外设立一个溢出表保存与基本表中记录冲突的所有记录</li>
  <li>设哈希表长为 m ,设立基本哈希表 Hashtable[m],每个分量保存一个记录;溢出表 Overtable[m],一旦某个记录的哈希地址发生冲突,都填入溢出表中</li>
</ul>
<h3 id="哈希查找过程"><a href="#哈希查找过程" class="headerlink" title="哈希查找过程"></a>哈希查找过程</h3>
<ul>
  <li>哈希表的主要目的是用于快速查找,且插入和删除操作都要用到查找</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">//开放定址哈希表的结构</span></div><div class="line"><span class="keyword">int</span> hashsize[] = &#123; <span class="number">997</span>, ... &#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  ElemType *elem; <span class="comment">//ElemType 中含 key</span></div><div class="line">  <span class="keyword">int</span> count; <span class="comment">// 当前数据元素个数</span></div><div class="line">  <span class="keyword">int</span> sizeindex;<span class="comment">// hashsize[sizeindex] 为当前容量</span></div><div class="line">&#125; HashTable;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DUPLICATE -1</span></div><div class="line"></div><div class="line"><span class="comment">//在哈希表 H 中查找关键码为 K 的元素</span></div><div class="line"><span class="function">Status <span class="title">SearchHash</span><span class="params">(HashTable H, HKeyType K, <span class="keyword">int</span> &amp;p, <span class="keyword">int</span> &amp;c)</span> </span>&#123;</div><div class="line"><span class="comment">// 若查找成功,以 p 指示待查数据元素在表中位置,并返回</span></div><div class="line"><span class="comment">//SUCCESS ,否则,以 p 指示插入位置,并返回 UNSUCCESS,</span></div><div class="line"><span class="comment">//c 用以记录冲突次数,其初值置零,供建表插入时参考</span></div><div class="line">  p = Hash(K); <span class="comment">// 求得哈希地址</span></div><div class="line">  <span class="keyword">while</span> ((H.elem[p].key != NULLKEY) &amp;&amp; !equal(K, (H.elem[p].key))) <span class="comment">// 该位置中填有记录，并且关键字不相等</span></div><div class="line">    collision(p, ++c); <span class="comment">// 求得下一探查地址 p</span></div><div class="line">  <span class="keyword">if</span> (equal(K, (H.elem[p].key)))</div><div class="line">    <span class="keyword">return</span> SUCCESS;</div><div class="line"><span class="comment">// 查找成功, p 返回待查数据元素位置</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> UNSUCCESS;</div><div class="line"><span class="comment">// 查找不成功, p 返回的是插入位置</span></div><div class="line">&#125; <span class="comment">// SearchHash</span></div><div class="line"></div><div class="line"><span class="comment">//哈希表插入算法</span></div><div class="line"><span class="function">Status <span class="title">InsertHash</span><span class="params">(HashTable &amp;H, HElemType e)</span> </span>&#123;</div><div class="line"><span class="comment">// 查找不成功时插入数据元素 e 到开放定址哈希表 H 中,</span></div><div class="line"><span class="comment">// 并返回 OK ;若冲突次数过大,则重建哈希表</span></div><div class="line">  <span class="keyword">int</span> c = <span class="number">0</span>; <span class="keyword">int</span> p = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (SearchHash(H, e.key, p, c) == SUCCESS )</div><div class="line">    <span class="keyword">return</span> DUPLICATE;</div><div class="line"><span class="comment">// 表中已有与 e 有相同关键字的元素</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; H.cursize) &#123;</div><div class="line"><span class="comment">// 冲突次数 c 未达到上限 ( 阈值 c 可调 )</span></div><div class="line">    H.elem[p] = e; ++H.count;</div><div class="line">    <span class="keyword">return</span> SUCCESS; <span class="comment">// 插入 e</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    RecreateHashTable(H); <span class="comment">// 重建哈希表</span></div><div class="line">    <span class="keyword">return</span> UNSUCCESS; </div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">// InsertHash</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>哈希查找的性能分析</strong></p>
<ul>
  <li>从哈希查找过程可见,尽管哈希表在关键字与记录的存储地址之间建立了直接映象,但由于存在冲突,查找过程仍是一个给定值与关键字进行比较的过程,仍要用 ASL 评价哈希查找效率</li>
  <li>哈希查找时,关键字与给定值比较的次数取决于:</li>
</ul>
<p>– 哈希函数<br>– 处理冲突的方法<br>– 哈希表的填满因子：$\alpha=\frac{\text{表中填入的记录数}}{\text{哈希表的长度}}$</p>
<ul>
  <li>一般情况下,可以认为选用的哈希函数是均匀的,则在讨论 ASL 时,可以不考虑它的因素</li>
  <li>哈希表的ASL是填满因子$\alpha$的函数，而不是$n$的函数。</li>
  <li>用哈希表构造查找表时，可以选择一个合适的填满因子，使得ASL限定在某个范围内。</li>
</ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;键树-数字查找树&quot;&gt;&lt;a href=&quot;#键树-数字查找树&quot; class=&quot;headerlink&quot; title=&quot;键树 / 数字查找树&quot;&gt;&lt;/a&gt;键树 / 数字查找树&lt;/h3&gt;
&lt;p&gt;Keyword Tree/Digital Search Tree 是关键字的一种组织方式,其具有下列特征:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;( 结点 ) 树的结点包含组成关键字的符号，关键字中的各个符号分布在从根结点到叶的路径上,叶结点内的符号为“结束”的标志符。&lt;/li&gt;
  &lt;li&gt;键树的深度和关键字集合的大小无关,取决于关键字中字符或数位的个数&lt;/li&gt;
  &lt;li&gt;( 多叉 ) 度大于 2 的树，每个结点的最大度与关键字的“基”有关&lt;/li&gt;
  &lt;li&gt;( 排序 ) 键树被约定为是一棵有序树,即同一层中兄弟结点之间依所含符号自左至右有序,并约定结束符‘ $’ 小于任何其它符号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;键树的存储结构:双链树&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;
        &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;
      &lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;
        &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; DLTNode &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; symbol;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; DLTNode *next; &lt;span class=&quot;comment&quot;&gt;// 指向兄弟结点的指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  NodeKind kind;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Record *infoptr; &lt;span class=&quot;comment&quot;&gt;// 叶子结点内的记录指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; DLTNode *first;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 分支结点内的孩子链指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; DLTNode, *DLTree; &lt;span class=&quot;comment&quot;&gt;// 双链树的类型&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Data-Structures" scheme="http://ucasfl.me/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>查找和搜索-Part2</title>
    <link href="http://ucasfl.me/2017/08/07/Find-and-Search-Part2/"/>
    <id>http://ucasfl.me/2017/08/07/Find-and-Search-Part2/</id>
    <published>2017-08-07T04:51:24.000Z</published>
    <updated>2017-09-02T04:38:29.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3>
<ul>
  <li>Motivation: 二叉排序树是一种查找效率比较高的数据组织形式,但其平均查找长度受树的形态影响较大,形态比较均匀时查找效率很好,形态明显偏向某一方向时其效率就大大降低。因此,希望有更好的二叉排序树,其形态总是均衡的,查找时能得到最好的效率</li>
  <li>Solution: 平衡二叉排序树 (Balanced Binary Sort Tree) ,由 Adelson-Velskii 和 Landis于 1962 年提出的,故称 AVL 树</li>
  <li>变种:红黑树,树堆,伸展树</li>
</ul>
<p><strong>基本概念</strong></p>
<p>平衡二叉树 (Balanced Binary Tree 或 Height-Balanced Tree) 或者是空树,或者是满足下列性质的二叉树</p>
<ul>
  <li>左子树和右子树深度之差的绝对值不大于 1</li>
  <li>左子树和右子树也都是平衡二叉树</li>
</ul>
<p>结点的平衡因子 (Balance Factor) :该结点的右子树的深度减去其左子树深度</p>
<ul>
  <li>平衡二叉树上每个结点的平衡因子只可能是 1 、 0和 -1</li>
  <li>平衡二叉排序树 (Balanced Binary Sort Tree) :一棵二叉树既是二叉排序树又是平衡二叉树</li>
</ul>
<a id="more"></a>
<p><strong>结构定义</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BSTNode &#123;</div><div class="line">  ElemType data;</div><div class="line">  <span class="keyword">int</span> bf; <span class="comment">// 平衡因子</span></div><div class="line">  <span class="keyword">struct</span> BSTNode *lchild , *rchild;</div><div class="line">&#125; BSTNode, *BSTree;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>平衡化旋转</strong></p>
<ul>
  <li>如果在一棵平衡的二叉排序树中插入一个新结点,造成了不平衡。此时必须调整树的结构,使之平衡化</li>
  <li>每插入一个新结点时, AVL 树中相关结点的平衡状态会发生改变。因此,在插入一个新结点后,需要从插入位置沿通向根的路径回溯,检查各结点的平衡因子</li>
  <li>如果在某一结点发现不平衡,停止回溯。从发生不平衡的结点起,沿刚才回溯的路径取直接下两层的结点</li>
  <li>如果这三个结点处于一条直线上,则采用单旋转进行平衡化。单旋转可按其方向分为左单旋转和右单旋转 , 其中一个是另一个的镜像,其方向与不平衡的形状相关</li>
  <li>如果这三个结点处于一条折线上,则采用双旋转进行平衡化。</li>
</ul>
<p><strong>右单旋转(RotateRight) : LL 型</strong></p>
<ul>
  <li>在结点 A 的左子女的左子树 D 上插入新结点使其高度增 1 导致结点 A 的平衡因子增到 -2 ,造成不平衡</li>
  <li>为使树恢复平衡,从 A 沿插入路径连续取 3个结点 A 、 B 和 D ,以结点 B 为旋转轴,将结点 A 顺时针旋转</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BSTree &amp;p)</span> </span>&#123;</div><div class="line"><span class="comment">// 对以 *p 为根的二叉排序树作右旋处理</span></div><div class="line"><span class="comment">// 处理之后 p 指向新的树根结点,</span></div><div class="line"><span class="comment">// 即旋转处理之前的左子树的根结点</span></div><div class="line">  BSTree lc;</div><div class="line">  lc = p-&gt;lchild; <span class="comment">//lc 指向 *p 的左子树根结点</span></div><div class="line">  p-&gt;lchild = lc-&gt;rchild;</div><div class="line"><span class="comment">// lc 的右子树挂接为 *p 的左子树</span></div><div class="line">  lc-&gt;rchild = p;</div><div class="line">  p = lc; <span class="comment">//p 指向新的根结点</span></div><div class="line">&#125; <span class="comment">// R_Rotate</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>左单旋转 (RotateLeft) : RR 型</strong></p>
<ul>
  <li>在结点 A 的右子女的右子树 E 中插入新结点,该子树高度增 1 导致结点 A 的平衡因子变成 2 ,出现不平衡</li>
  <li>为使树恢复平衡,从 A 沿插入路径连续取 3个结点 A 、 C 和 E ,以结点 C 为旋转轴,让结点 A 反时针旋转 p</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BSTree &amp;p)</span> </span>&#123;</div><div class="line"><span class="comment">// 对以 *p 为根的二叉排序树作左旋处理</span></div><div class="line"><span class="comment">// 处理之后 p 指向新的树根结点</span></div><div class="line"><span class="comment">// 即旋转处理之前的右子树的根结点</span></div><div class="line">  BSTree rc;</div><div class="line">  rc = p-&gt;rchild; <span class="comment">//rc 指向 *p 的右子树根结点</span></div><div class="line"><span class="comment">//rc 的左子树挂接为 *p 的右子树</span></div><div class="line">  p-&gt;rchild = rc-&gt;lchild;</div><div class="line">  rc-&gt;lchild = p;</div><div class="line"><span class="comment">//p 指向新的根结点</span></div><div class="line">  p = rc;</div><div class="line">&#125; <span class="comment">//L_Rotate</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>先左后右双旋转 (RotationLeftRight)-LR 型</strong></p>
<ul>
  <li>在结点 A 的左子女的右子树中插入新结点,该子树高度增 1 导致结点 A 的平衡因子变为 -2 ,造成不平衡</li>
  <li>以结点 E 为旋转轴,将结点 B 反时针旋转,以 E 代替原来 B 的位置</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LR_Rotate</span> <span class="params">(BSTree &amp;p)</span> </span>&#123;</div><div class="line"><span class="comment">// 对以 *p 为根的二叉排序树做先左后右旋转</span></div><div class="line">  BSTree lc,rc;</div><div class="line"><span class="comment">// 初始化</span></div><div class="line">  rc =p; lc =rc-&gt;lchild;</div><div class="line">  p=lc-&gt;rchild; <span class="comment">// 重新确定根</span></div><div class="line">  lc-&gt;rchild=p-&gt;lchild; <span class="comment">// 为 BF 拉链</span></div><div class="line">  p-&gt;lchild=lc; <span class="comment">// 设置新根的左孩子,为 EB 拉链</span></div><div class="line">  rc-&gt;lchild=p-&gt;rchild; <span class="comment">// 为 AG 拉链</span></div><div class="line">  p-&gt;rchild=rc; <span class="comment">// 为 EA 拉链</span></div><div class="line">&#125; <span class="comment">// LR_Rotate</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>先右后左双旋转 (RotationRightLeft)-RL 型</strong></p>
<ul>
  <li>在结点 A 的右子女的左子树中插入新结点,该子树高度增 1 。结点 A 的平衡因子变为 2 ,发生了不平衡</li>
  <li>首先以结点 D 为旋转轴,将结点 C 顺时针旋转,以 D 代替原来 C 的位置</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RL_Rotate</span> <span class="params">(BSTree &amp;p)</span> </span>&#123;</div><div class="line"><span class="comment">// 对以 *p 为根的二叉排序树做先右后左旋转</span></div><div class="line">  BSTree lc,rc;</div><div class="line"><span class="comment">// 初始化</span></div><div class="line">  lc =p; rc =lc-&gt;rchild;</div><div class="line">  p=rc-&gt;lchild;</div><div class="line">  rc-&gt;lchild=p-&gt;rchild;</div><div class="line">  p-&gt;rchild=rc;</div><div class="line">  lc-&gt;rchild=p-&gt;lchild;</div><div class="line">  p-&gt;lchild=lc;</div><div class="line">&#125; <span class="comment">// RL_Rotate</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>AVL 树的插入</strong></p>
<ul>
  <li>AVL 树的插入算法是从一棵空树开始,通过输入一系列关键字,逐步建立 AVL 树</li>
  <li>在向一棵本来是平衡的 AVL 树中插入一个新结点时,需从插入结点沿通向根的路径向上回溯,如果某个结点的平衡因子的绝对值 |bf| &gt; 1 ,那么需从这个结点出发,使用平衡旋转方法进行平衡化处理</li>
</ul>
<p>算法实现：</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LH -1 <span class="comment">// 左高</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EH 0 <span class="comment">// 等高</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RH 1 <span class="comment">// 右高</span></span></div><div class="line"><span class="function">Status <span class="title">InsertAVL</span><span class="params">(BSTree &amp;T, ElemType e, Boolean &amp;taller)</span> </span>&#123;</div><div class="line"><span class="comment">// 若在平衡的二叉排序树 T 中不存在和 e 有相同关键字的结点,</span></div><div class="line"><span class="comment">// 则插入一个数据元素为 e 的新结点,并返回 1 ,否则返回0 。</span></div><div class="line"><span class="comment">// 若因插入而使二叉排序树失去平衡,则作平衡旋转处理,</span></div><div class="line"><span class="comment">// 布尔变量 taller 反映 T 长高与否</span></div><div class="line">  <span class="keyword">if</span> (!T) &#123; <span class="comment">// 插入新结点,树 " 长高 " ,置 taller 为 TRUE</span></div><div class="line">    T = (BSTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BSTNode));</div><div class="line">    T-&gt;data = e; T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</div><div class="line">    T-&gt;bf = EH; taller = TRUE; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (EQ(e.key, T-&gt;data.key))&#123;</div><div class="line">      taller = <span class="literal">false</span>;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//已经存在记录，不再插入</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (LT(e.key, T-&gt;data.key)) &#123;</div><div class="line"><span class="comment">// 应继续在 *T 的左子树中进行搜索</span></div><div class="line">      <span class="keyword">if</span> (InsertAVL(T-&gt;lchild, e, taller)==<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未插入</span></div><div class="line">      <span class="keyword">if</span> (taller) <span class="comment">// 插入到 *T 的左子树中且左子树 " 长高“</span></div><div class="line">        <span class="keyword">switch</span> (T-&gt;bf) &#123; <span class="comment">// 检查 *T 的平衡度</span></div><div class="line">          <span class="keyword">case</span> LH: <span class="comment">// 原本左子树比右子树高,需作左平衡处理</span></div><div class="line">            LeftBalance(T); taller = FALSE; <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> EH: <span class="comment">// 原本左、右子树等高</span></div><div class="line"><span class="comment">// 现因左子树增高而使树增高</span></div><div class="line">            T-&gt;bf = LH; taller = TRUE; <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> RH: <span class="comment">// 原本右子树比左子树高 S</span></div><div class="line"><span class="comment">// 现左、右子树等高</span></div><div class="line">            T-&gt;bf = EH; taller = FALSE; <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="comment">// switch (T-&gt;bf)</span></div><div class="line">    &#125; <span class="comment">// if</span></div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 应继续在 T↑ 的右子树中进行搜索</span></div><div class="line">      <span class="keyword">if</span> (InsertAVL(T-&gt;rchild, e, taller)==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      <span class="keyword">if</span> (taller) <span class="comment">// 已插入到 *T 的右子树且右子树长高</span></div><div class="line">        <span class="keyword">switch</span> (T-&gt;bf) &#123; <span class="comment">// 检查 *T 的平衡度</span></div><div class="line">          <span class="keyword">case</span> LH: <span class="comment">// 原本左子树比右子树高</span></div><div class="line"><span class="comment">// 现左、右子树等高</span></div><div class="line">            T-&gt;bf = EH; taller = FALSE; <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> EH: <span class="comment">// 原本左、右子树等高</span></div><div class="line"><span class="comment">// 现因右子树增高而使树增高</span></div><div class="line">            T-&gt;bf = RH; taller = TRUE; <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> RH: <span class="comment">// 原本右子树比左子树高</span></div><div class="line"><span class="comment">// 需要作右平衡处理</span></div><div class="line">            RightBalance(T); taller = FALSE; <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="comment">//switch (T-&gt;bf)</span></div><div class="line">    &#125; <span class="comment">//else</span></div><div class="line">  &#125; <span class="comment">// else</span></div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>; </div><div class="line">&#125; <span class="comment">//InsertAVL</span></div><div class="line"></div><div class="line"><span class="comment">//对以指针 T 所指结点为根的二叉树作左平衡旋转处理</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(BSTree &amp;T)</span> </span>&#123;</div><div class="line"><span class="comment">// 本算法结束时,指针 T 指向新的根结点</span></div><div class="line">  BSTree lc,rd;</div><div class="line">  lc = T-&gt;lchild; <span class="comment">// lc 指向 *T 的左子树根结点</span></div><div class="line">  <span class="keyword">switch</span> (lc-&gt;bf) &#123; <span class="comment">// 检查 *T 的左子树的平衡度</span></div><div class="line"><span class="comment">// 并作相应平衡处理</span></div><div class="line">    <span class="keyword">case</span> LH:</div><div class="line"><span class="comment">// 新结点插入在 *T 的左孩子的左子树上,</span></div><div class="line"><span class="comment">// 要作单右旋处理</span></div><div class="line">      T-&gt;bf = lc-&gt;bf = EH;</div><div class="line">      R_Rotate(T); </div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> RH: <span class="comment">// 新结点插入在 *T 的左孩子的右子树上</span></div><div class="line"><span class="comment">// 要作双旋处理</span></div><div class="line">      rd = lc-&gt;rchild; <span class="comment">// rd 指向 *T 的左孩子的右子树根</span></div><div class="line">      <span class="keyword">switch</span> (rd-&gt;bf) &#123; <span class="comment">// 修改 *T 及其左孩子的平衡因子</span></div><div class="line">        <span class="keyword">case</span> LH: T-&gt;bf = RH; lc-&gt;bf = EH; <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> EH: T-&gt;bf = lc-&gt;bf = EH; <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> RH: T-&gt;bf = EH; lc-&gt;bf = LH; <span class="keyword">break</span>;</div><div class="line">      &#125; <span class="comment">//switch (rd-&gt;bf)</span></div><div class="line">      rd-&gt;bf = EH;</div><div class="line"><span class="comment">// 对 *T 的左子树作左旋平衡处理</span></div><div class="line">      L_Rotate(T-&gt;lchild);</div><div class="line">      R_Rotate(T); <span class="comment">// 对 *T 作右旋平衡处理</span></div><div class="line">  &#125; <span class="comment">// switch (lc-&gt;bf)</span></div><div class="line">&#125; <span class="comment">// LeftBalance</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RightBalance</span><span class="params">(BSTree *T)</span></span>&#123;</div><div class="line">    BSTree lc,ld;</div><div class="line">    lc=(*T)-&gt;rchild;</div><div class="line">    <span class="keyword">switch</span>(lc-&gt;bf)&#123;</div><div class="line">    <span class="keyword">case</span> RH:</div><div class="line">        (*T)-&gt;bf=lc-&gt;bf=EH;</div><div class="line">        L_Rotate(T);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> LH:</div><div class="line">        ld=lc-&gt;lchild;</div><div class="line">        <span class="keyword">switch</span>(ld-&gt;bf)&#123;</div><div class="line">        <span class="keyword">case</span> LH:</div><div class="line">            (*T)-&gt;bf=EH;</div><div class="line">            lc-&gt;bf=RH;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> EH:</div><div class="line">            (*T)-&gt;bf=lc-&gt;bf=EH;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> RH:</div><div class="line">            lc-&gt;bf=EH;</div><div class="line">            (*T)-&gt;bf=LH;</div><div class="line">        &#125;</div><div class="line">        ld-&gt;bf=EH;</div><div class="line">        R_Rotate(&amp;((*T)-&gt;rchild));</div><div class="line">        L_Rotate(T);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> EH:</div><div class="line">        (*T)-&gt;bf=RH;</div><div class="line">        lc-&gt;bf=LH;</div><div class="line">        L_Rotate(T);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;<span class="comment">//RightBalance</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>AVL树的删除</strong></p>
<ul>
  <li>如果被删结点 x 最多只有一个子女,可做简单删除</li>
</ul>
<p>– 将结点 x 从树中删去<br>– 因为结点 x 最多有一个子女,可以简单地把 x 的双亲中原来指向 x 的指针改指到这个子女结点<br>– 如果结点 x 没有子女, x 双亲原来指向 x的指针置为 NULL<br>– 将原来以结点 x 为根的子树的高度减 1</p>
<ul>
  <li>如果被删结点 x 有两个子女</li>
</ul>
<p>– 搜索 x 在中序次序下的直接前驱 y ( 同样可以找直接后继 )<br>– 把结点 y 的内容传送给结点 x ,现在问题转移到删除结点 y 。把结点 y 当作被删结点 x<br>– 因为结点 y 最多有一个子女,可以简单地用 前一页给出的方法进行删除</p>
<ul>
  <li>必须沿结点 x 通向根的路径反向追踪高度的变化对路径上各个结点的影响</li>
  <li>用一个布尔变量 shorter 来指明子树高度是否被缩短</li>
</ul>
<p>– 布尔变量 shorter 的值初始化为 True</p>
<ul>
  <li>对于从 x 的双亲到根的路径上的各个结点p ,在 shorter 保持为 True 时执行下面操作;如果 shorter 变成 False ,算法终止</li>
</ul>
<p>– 在每个结点上要做的操作取决于 shorter 的值<br>和结点的 bf ,有时还要依赖子女的 bf</p>
<p>算法实现：</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteAVL</span><span class="params">(BSTree *t, ElemType key, <span class="keyword">bool</span>&amp; shorter)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>((*t)== <span class="literal">NULL</span>)&#123;                      </div><div class="line">        shorter=<span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                   </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(EQ(key, (*t)-&gt;data))&#123;        </div><div class="line">        BSTNode* q = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">if</span>((*t)-&gt;lchild == <span class="literal">NULL</span>)&#123;           </div><div class="line">            q = *t;</div><div class="line">            (*t) = (*t)-&gt;rchild;</div><div class="line">            <span class="keyword">delete</span> q;</div><div class="line">            shorter = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((*t)-&gt;rchild == <span class="literal">NULL</span>)&#123;      </div><div class="line">            q = (*t);</div><div class="line">            (*t) = (*t)-&gt;lchild;</div><div class="line">            <span class="keyword">delete</span> q;</div><div class="line">            shorter = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;                            </div><div class="line">            q = (*t)-&gt;lchild;</div><div class="line">            <span class="keyword">while</span>(q-&gt;rchild)</div><div class="line">                q = q-&gt;rchild;</div><div class="line">            (*t)-&gt;data = q-&gt;data;</div><div class="line">            deleteAVL(&amp;((*t)-&gt;lchild), q-&gt;data, shorter);   </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LT(key, (*t)-&gt;data))&#123;        </div><div class="line">        <span class="keyword">if</span>(!deleteAVL(&amp;((*t)-&gt;lchild), key, shorter))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(shorter)&#123;</div><div class="line">            <span class="keyword">switch</span>((*t)-&gt;bf)&#123;</div><div class="line">                <span class="keyword">case</span> LH:</div><div class="line">                    (*t)-&gt;bf = EH;</div><div class="line">                    shorter = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> EH:</div><div class="line">                    (*t)-&gt;bf = RH;</div><div class="line">                    shorter = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> RH:</div><div class="line">                    RightBalance(t);    </div><div class="line">                    <span class="keyword">if</span>((*t)-&gt;rchild-&gt;bf == EH)</div><div class="line">                        shorter = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        shorter = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;                                </div><div class="line">        <span class="keyword">if</span>(!deleteAVL(&amp;((*t)-&gt;rchild), key, shorter))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(shorter)&#123;</div><div class="line">            <span class="keyword">switch</span>((*t)-&gt;bf)&#123;</div><div class="line">                <span class="keyword">case</span> LH:</div><div class="line">                    LeftBalance(t);    </div><div class="line">                    <span class="keyword">if</span>((*t)-&gt;lchild-&gt;bf == EH)</div><div class="line">                        shorter = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        shorter = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> EH:</div><div class="line">                    (*t)-&gt;bf = LH;</div><div class="line">                    shorter = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> RH:</div><div class="line">                    (*t)-&gt;bf = EH;</div><div class="line">                    shorter = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>AVL 上的查找</strong></p>
<p>AVL上进行查找的时间复杂度为O(logn) .</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3>
<p>一棵m阶B树，或者是空树，或者是满足下面性质的一棵树：</p>
<ul>
  <li>每个节点至多有m棵子树</li>
  <li>节点要么是根节点，或者是叶子节点，或者至少有两棵子树</li>
  <li>除根节点外，所有非终节点至少有m/2(上取整)棵子树</li>
  <li>所有非终端节点应包含如下信息：
    <ul>
      <li>$(n, A_0, K_1, A_1, K_2, A_2, …, K_n, A_n)$</li>
      <li>其中，$K_i$是关键字，且$K<em>i &lt; K</em>{i+1}, A<em>i$为指向孩子节点的指针，且$A</em>{i-1}$所指向的子树中的所有节点的关键字均小于$K_i,A_i$所指向子树中的所有节点的关键字均大于$K_i$，$n$是节点中关键字的个数，$n+1$为子树的棵树。</li>
    </ul>
  </li>
  <li>所有叶子节点都在树的同一层上，且不带信息。
    <ul>
      <li>叶子节点为外部节点，查找失败时候的节点，实际上不存在。</li>
    </ul>
  </li>
</ul>
<p><strong>m阶B树定义</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> m 3</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BTNode &#123;</div><div class="line">  <span class="keyword">int</span> keynum; <span class="comment">// 结点中关键字个数,即结点大小</span></div><div class="line">  <span class="keyword">struct</span> BTNode *parent; <span class="comment">// 指向父结点的指针</span></div><div class="line">  KeyType key[m+<span class="number">1</span>]; <span class="comment">// 关键字, 0 号单元不用</span></div><div class="line">  Record *recptr[m+<span class="number">1</span>]; <span class="comment">// 记录指针向量,0 号单元不用</span></div><div class="line">  <span class="keyword">struct</span> BTNode *ptr[m+<span class="number">1</span>]; <span class="comment">// 子树指针向量</span></div><div class="line">&#125; BTNode, *BTree; <span class="comment">//B 树结点和 B 树的类型</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>B 树的查找:类似二叉排序树</strong></p>
<ul>
  <li>(1) 从树的根结点 T 开始,在 T 所指向的结点的关键字向量 key[1…keynum] 中查找给定值 K( 用 s 顺序查找或折半查找 ) :</li>
  <li>若 key[i]=K(1≤i≤keynum) ,则查找成功,返回结点及关键字位置;否则,转 (2) ;</li>
  <li>(2) 将 K 与向量 key[1…keynum] 中的各个分量的值进行比较,以选定查找的子树:</li>
</ul>
<p>​ – 若 K &lt; key[1] : T=T-&gt;ptr[0]<br>​ – 若 key[i] &lt; K&lt; key [i+1] (i=1, 2, …keynum-1) : T=T-&gt;ptr[i]<br>​ – 若 K&gt;key[keynum] : T=T-&gt;ptr[keynum]</p>
<ul>
  <li>转 (1) ,直到 T 是叶子结点且未找到相等的关键字,则查找失败• 在 B+ 树上插入、删除的过程基本上和 B 树类似</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  BTNode *pt; <span class="comment">// 指向找到的结点</span></div><div class="line">  <span class="keyword">int</span> i; <span class="comment">// 在结点中的关键字序号</span></div><div class="line">  <span class="keyword">int</span> tag;</div><div class="line"><span class="comment">//1 :查找成功, 0 :查找失败</span></div><div class="line">&#125; Result;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(BTree p, KeyType K)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; p-&gt;keynum &amp;&amp; p-&gt;key[i+<span class="number">1</span>] &lt;= K; i++);</div><div class="line">  <span class="keyword">return</span> i; <span class="comment">// p-&gt;key[i] &lt;= K &lt; p-&gt;key[i+1]</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//在 m 阶 B 树 T 上查找关键字 K ,返回结果 (pt,i,tag)</span></div><div class="line"><span class="function">Result <span class="title">SearchBTree</span><span class="params">(BTree T, KeyType K)</span> </span>&#123;</div><div class="line">  BTree p, q; <span class="keyword">int</span> found, i, j=<span class="number">0</span>; Result R;</div><div class="line"><span class="comment">// 初始化, p 指向待查结点, q 指向 p 的双亲</span></div><div class="line">  p = T; q = <span class="literal">NULL</span>; found = FALSE; i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (p &amp;&amp; !found) &#123;</div><div class="line">    i = Search(p, K); <span class="comment">// 在 p-&gt;key[1..keynum] 中查找 i ,</span></div><div class="line"><span class="comment">// 使得 p-&gt;key[i]&lt;=K&lt;p-&gt;key[i+1]</span></div><div class="line">    <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; p-&gt;key[i]==K)</div><div class="line">      found = TRUE; <span class="comment">// 找到待查关键字</span></div><div class="line">    <span class="keyword">else</span> &#123; q = p; p = p-&gt;ptr[i]; &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (found) &#123; <span class="comment">// 查找成功: pt 所指结点中第 i 个关键字等于 K</span></div><div class="line">    R.pt = p; R.i = i; R.tag = <span class="number">1</span>; &#125;</div><div class="line">  <span class="keyword">else</span> &#123; <span class="comment">// 关键字 k 应插入在 pt 所指结点中的第 i 和第 i+1 个关键字之间</span></div><div class="line">    R.pt = q; R.i = i; R.tag = <span class="number">0</span>; &#125;</div><div class="line">  <span class="keyword">return</span> R; <span class="comment">// 返回结果信息 : K 的位置 ( 或插入位置 )</span></div><div class="line">&#125; <span class="comment">// SearchBTree</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>在 B 树上的查找有两种基本操作:</li>
</ul>
<p>​ – 在 B 树上查找结点:在磁盘上进行<br>​ – 在结点中查找关键字:将结点信息读入内存后再查找</p>
<ul>
  <li>因此,磁盘上的查找次数 ( 即:待查找的记录关键字在 B 树上的层次数 ) 是决定 B 树查找效率的首要因素.</li>
</ul>
<p><strong>B树的插入</strong></p>
<ul>
  <li>B 树的生成是从空树起,逐个插入关键字</li>
  <li>插入时不是每插入一个关键字就添加一个叶子结点,而是首先在最低层的某个叶子结点中添加一个关键字,然后</li>
  <li>若关键字的数目达到 m ,则分裂成两个结点,并将中间关键字插入到 p 的父结点,这时,父结点也可能不满足 m 阶 B 树的要求( 分枝数大于 m) ,则必须对父结点进行分裂,一直进行下去,直到没有父结点或分裂后的父结点满足 m 阶 B 树的要求</li>
  <li>当根结点分裂时,因没有父结点,则建立一个新的根, B 树增高一层</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function">BTNode *<span class="title">split</span><span class="params">(BTNode *p)</span></span></div><div class="line"><span class="comment">// 结点 p 中包含 m 个关键字,从中分裂出一个新的结点</span></div><div class="line">&#123;</div><div class="line">  BTNode *q ; <span class="keyword">int</span> k, mid, j ;</div><div class="line">  q=(BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>( BTNode));</div><div class="line">  mid=(m+<span class="number">1</span>)/<span class="number">2</span>; </div><div class="line">  q-&gt;ptr[<span class="number">0</span>]=p-&gt;ptr[mid];</div><div class="line">  <span class="keyword">for</span> (j=<span class="number">1</span>,k=mid+<span class="number">1</span>; k&lt;=m; k++) &#123;</div><div class="line">    q-&gt;key[j]=p-&gt;key[k] ;</div><div class="line">    q-&gt;ptr[j++]=p-&gt;ptr[k] ;</div><div class="line">  &#125; <span class="comment">// 将 p 的后半部分移到新结点 q 中</span></div><div class="line">  q-&gt;keynum=m-mid ; p-&gt;keynum=mid<span class="number">-1</span> ;</div><div class="line">  <span class="keyword">return</span>(q) ;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>B树的删除</strong></p>
<ul>
  <li>在 B 树上删除一个关键字 K ,首先找到关键字所在的结点 N ,然后在 N 中进行关键字 K 的删除操作。</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3>
<ul>
  <li>m 阶 B+ 树, B 树的一种变体</li>
  <li>一棵 m 阶 B+ 树与 m 阶 B 树的主要差异是: 若一个结点有 n 棵子树,则必含有 n 个关键字</li>
  <li>所有叶子结点中包含了全部记录的关键字信息以及这些关键字记录的指针,而且叶子结点按关键字的大小从小到大顺序链接,构成一个有序链表</li>
  <li>在 B+ 树中,所有的非叶子结点可以看成是索引,结点中只含有其子树的根结点中的最大 ( 或最小 ) 关键字</li>
</ul>
<p><strong>B+树定义</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;branch, left&#125; NodeType;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BPNode &#123;</div><div class="line">  NodeTag tag; <span class="comment">// 结点标志</span></div><div class="line">  <span class="keyword">int</span> keynum; <span class="comment">// 结点中关键字的个数</span></div><div class="line">  <span class="keyword">struct</span> BTNode *parent; <span class="comment">// 指向父结点的指针</span></div><div class="line">  KeyType key[M+<span class="number">1</span>]; <span class="comment">// 关键字向量 ,key[0] 未用</span></div><div class="line">  <span class="keyword">union</span> pointer</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">struct</span> BTNode *ptr[M+<span class="number">1</span>]; <span class="comment">// 子树指针向量</span></div><div class="line">    RecType *recptr[M+<span class="number">1</span>]; <span class="comment">//recptr[0] 未用</span></div><div class="line">  &#125;ptrType ; <span class="comment">// 用联合体定义子树指针和记录指针</span></div><div class="line">&#125;BPNode;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>B+树的查找</strong></p>
<ul>
  <li>与 B 树相比,对 B+ 树不仅可以从根结点开始按关键字随机查找,而且可以从最小关键字起,按叶子结点的链接顺序进行顺序查找。</li>
  <li>在 B+ 树上进行随机查找的过程基本上和 B树类似。</li>
  <li>在 B+ 树上进行随机查找时,若非叶子结点的关键字等于给定的 K 值,并不终止,而是继续向下直到叶子结点 ( 只有叶子结点才存储记录 ) , 即无论查找成功与否,都走了一条从根结点到叶子结点的路径。</li>
</ul>
<p><strong>B+ 树的插入、删除</strong></p>
<ul>
  <li>在 B+ 树上插入、删除的过程基本上和 B 树类似。</li>
</ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;AVL-树&quot;&gt;&lt;a href=&quot;#AVL-树&quot; class=&quot;headerlink&quot; title=&quot;AVL 树&quot;&gt;&lt;/a&gt;AVL 树&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Motivation: 二叉排序树是一种查找效率比较高的数据组织形式,但其平均查找长度受树的形态影响较大,形态比较均匀时查找效率很好,形态明显偏向某一方向时其效率就大大降低。因此,希望有更好的二叉排序树,其形态总是均衡的,查找时能得到最好的效率&lt;/li&gt;
  &lt;li&gt;Solution: 平衡二叉排序树 (Balanced Binary Sort Tree) ,由 Adelson-Velskii 和 Landis于 1962 年提出的,故称 AVL 树&lt;/li&gt;
  &lt;li&gt;变种:红黑树,树堆,伸展树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基本概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;平衡二叉树 (Balanced Binary Tree 或 Height-Balanced Tree) 或者是空树,或者是满足下列性质的二叉树&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;左子树和右子树深度之差的绝对值不大于 1&lt;/li&gt;
  &lt;li&gt;左子树和右子树也都是平衡二叉树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结点的平衡因子 (Balance Factor) :该结点的右子树的深度减去其左子树深度&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;平衡二叉树上每个结点的平衡因子只可能是 1 、 0和 -1&lt;/li&gt;
  &lt;li&gt;平衡二叉排序树 (Balanced Binary Sort Tree) :一棵二叉树既是二叉排序树又是平衡二叉树&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Data-Structures" scheme="http://ucasfl.me/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>查找和搜索-Part1</title>
    <link href="http://ucasfl.me/2017/08/05/Find-and-Search-Part1/"/>
    <id>http://ucasfl.me/2017/08/05/Find-and-Search-Part1/</id>
    <published>2017-08-05T04:51:20.000Z</published>
    <updated>2017-09-02T04:38:29.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3>
<ul>
  <li>查找表 (Search Table) :相同类型的数据元素 ( 或记录 ) 组成的集合,每个数据元素通常由若干数据项构成</li>
  <li>关键字 (Key ,码 ) :数据元素中某个 ( 或几个 ) 数据项的值,它可以标识一个数据元素</li>
</ul>
<p>– 主关键字 (Primary Key) :能唯一标识一个数据元素的关键字<br>– 次关键字 (Secondary Key) :能标识若干个数据元素的关键字</p>
<h4 id="关键字类型"><a href="#关键字类型" class="headerlink" title="关键字类型"></a>关键字类型</h4>
<ul>
  <li>数据元素的关键字:其类型通常是可以进行比较运算的类型</li>
  <li>典型的关键字类型</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> KeyType ;</div><div class="line"><span class="comment">// 实型</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType ; <span class="comment">// 整型</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> KeyType ; <span class="comment">// 字符串型</span></div><div class="line">• 数据元素类型</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> RecType &#123;</div><div class="line">KeyType key ; <span class="comment">// 关键字域</span></div><div class="line">... ... <span class="comment">// 其他域</span></div><div class="line">&#125; ElemType;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<a id="more"></a>
<h4 id="对两个关键字的比较"><a href="#对两个关键字的比较" class="headerlink" title="对两个关键字的比较"></a>对两个关键字的比较</h4>
<figure class="highlight">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">//C 的宏定义</div><div class="line">// 对数值型关键字</div><div class="line">#define EQ(a, b) ((a)==(b))</div><div class="line">#define LT(a, b) ((a)&lt;(b))</div><div class="line">#define LQ(a, b) ((a)&lt;=(b))</div><div class="line">// 对字符串型关键字</div><div class="line">#define EQ(a, b) (!strcmp((a), (b)) )</div><div class="line">#define LT(a, b) (strcmp((a), (b))&lt;0 )</div><div class="line">#define LQ(a, b) (strcmp((a), (b))&lt;=0 )</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4>
<p>根据给定的 Key 值,在查找表中确定一个关键字等于给定值的数据元素或记录</p>
<ul>
  <li>查找表中存在满足条件的数据元素 / 记录,则查找成功,返回所查到的数据元素或其在查找表中的位置</li>
  <li>查找表中不存在满足条件的记录,则查找失败</li>
  <li>“ 关键字等于给定值 ” 只是一种最为常用的查找条件,实际应用中可能会有其他的查找件,例如查找 “ 关键字在某个范围内的数据元素 ” 等等</li>
</ul>
<p>采用何种查找方法,首先取决于查找表的组织,即按何种关系组织 / 存储数据元素</p>
<ul>
  <li>查找表是记录的集合,而集合中的元素之间是一种完全松散的关系,因此,查找表是一种非常灵活的数据结构,可以用多种方式来存储</li>
</ul>
<h3 id="查找及其方法分类"><a href="#查找及其方法分类" class="headerlink" title="查找及其方法分类"></a>查找及其方法分类</h3>
<ul>
  <li>静态查找 / 静态查找表 (Static Search Table):只对该表的数据元素进行查询</li>
  <li>动态查找 / 动态查找表 (Dynamic Search Table) :在对该表实施查找的同时,可插入查找表中不存在的记录,或从查找表中删除已存在的某个记录;表的结构本身是在查找过程中动态生成的</li>
</ul>
<h4 id="分类1：按存储结构的不同"><a href="#分类1：按存储结构的不同" class="headerlink" title="分类1：按存储结构的不同"></a>分类1：按存储结构的不同</h4>
<ul>
  <li>线性表查找: 数据元素保存在顺序表或链表中</li>
  <li>哈希查找:数据元素保存在哈希表中,根据给定的 Key 值直接访问 查找表, 从而找到要查找的记录</li>
  <li>树表查找:数据元素保存在树中</li>
</ul>
<h4 id="分类2："><a href="#分类2：" class="headerlink" title="分类2："></a>分类2：</h4>
<ul>
  <li>内查找:整个查找过程全部在内存进行</li>
  <li>外查找:在查找过程中还需要访问外存，例如:查找表太大,无法全部放入内存中</li>
</ul>
<h4 id="查找方法的评价指标"><a href="#查找方法的评价指标" class="headerlink" title="查找方法的评价指标"></a>查找方法的评价指标</h4>
<ul>
  <li>查找过程中的主要操作是关键字的比较,查找过程中关键字的平均比较次数是衡量一个查找算法效率高低的标准</li>
  <li>ASL (Average Search Length , 平均查找长度 ) 定义为需要和给定值进行比较的关键字的个数的期望值</li>
</ul>
<h3 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h3>
<p>静态查找表:可以用线性表 ( 顺序表或线性链表 ) 实现</p>
<p>静态查找表 StaticSearchTable 的基本操作:</p>
<figure class="highlight">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">void CreateSSTable(SSTable *t);// 构造一个查找表</div><div class="line">void Destroy(SSTable *t);</div><div class="line">void ListSSTable(SSTable *t); // 输出查找表</div><div class="line">int SearchSSTable(SSTable *t,KeyType key); // 查找成功,返回元素值在表中位置</div><div class="line">void Traverser(SSTable *t, void Visit(ElemType *e)); // 按某种次序对 t 的每个元素调用函数 Visit()</div><div class="line">一次且一次</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h4 id="静态查找表的查找方法"><a href="#静态查找表的查找方法" class="headerlink" title="静态查找表的查找方法"></a>静态查找表的查找方法</h4>
<ul>
  <li>基于顺序表的查找: 顺序查找 (SequentialSearch) ,逐一比较</li>
  <li>基于有序表的查找</li>
</ul>
<p>– 折半查找 / 二分查找 (Binary Search) :每次对查找表进行折半缩小<br>– Fibonacci 查找 :根据 Fibonacci 数列的特点对查找表进行分割<br>– 静态树表查找</p>
<ul>
  <li>基于索引顺序表的查找:索引顺序查找 /分块查找 (Blocking Search) ,基于顺序表和其索引的查找</li>
</ul>
<h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4>
<p>顺序表的定义如下：</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> SSTable&#123;</div><div class="line"><span class="comment">// 数据元素存储空间的基地址</span></div><div class="line"><span class="comment">// 建表时按实际长度分配, 0 号单元留空</span></div><div class="line">ElemType *elem;</div><div class="line"><span class="keyword">int</span> length ; <span class="comment">// 实际元素个数</span></div><div class="line">&#125; SSTable;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>顺序查找算法：</p>
<p>从表的一端 ( 例如:最后一个记录 ) 开始,逐个将记录的关键字和给定 Key 值进行比较<br>– 若某个记录的关键字和给定 Key 值相等,查找成功<br>– 否则,若扫描完整个表,仍然没有找到相应的记录,则查找失败</p>
<p>简单实现：</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchSSTable</span><span class="params">(SSTable *t, KeyType key)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=t-&gt;length &amp;&amp; (t-&gt;elem[i].key != key); i++ );</div><div class="line">  <span class="keyword">if</span>( i&lt;=t-&gt;length )</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125; <span class="comment">//Search_Seq</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>标准算法：</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchSSTable</span><span class="params">(SSTable *t,KeyType key)</span> </span>&#123;</div><div class="line"><span class="comment">// 设置哨兵,查找失败时返回 0</span></div><div class="line">  t-&gt;elem[<span class="number">0</span>].key=key;</div><div class="line"><span class="comment">// 从后往前找</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=t-&gt;length; !EQ(t-&gt;elem[i].key, key); i--) ;</div><div class="line">  <span class="keyword">return</span> i ; <span class="comment">// 找不到时, i 为 0</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//设立哨兵后可以使循环中省掉了一次比较</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p>算法分析：</p>
<ul>
  <li>查找成功时候的比较次数：ASL = (n+1)/2</li>
  <li>查找失败时候的比较次数：ASL=n+1</li>
  <li>若查找成功与不成功的概率相等，则 ASL = 3(n+1)/4</li>
</ul>
<p>缺点：</p>
<p>查找效率低,当 n 较大时,不宜采用顺序查找。</p>
<p>改进：</p>
<ul>
  <li>根据数据元素被查找的概率组织顺序表，在不等概率的情况下，按被查找概率的升序排序。</li>
  <li>在数据元素中增加一数据项,用于记录对该数据元素的访问次数<br>– 在每次查找后,维护查找表使得其按照数据元素的访问次数升序排序</li>
  <li>在每次查找后,将刚查找到的元素移动至表尾:已发生的事会重复发生</li>
  <li>为顺序表加索引</li>
</ul>
<h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4>
<ul>
  <li>基于有序顺序表的查找chazhao</li>
</ul>
<p>– 查找表中的所有记录是按关键字有序 ( 升序或降序 ) 排列的</p>
<ul>
  <li>查找过程中,先确定待查找记录在表中的范围,然后逐步缩小范围 ( 每次将待查记录所在区间缩小一半 ) ,直到找到或找不到记录为止</li>
</ul>
<p>算法思想：</p>
<ul>
  <li>初始:用 Low 、 High 和 Mid 表示待查找区间的下界、上界和中间位置指针,初值设置为 Low=1 , High=n</li>
  <li>(1) 取中间位置 Mid : Mid=(Low+High)/2</li>
  <li>(2) 比较中间位置记录的关键字与给定的 Key值:</li>
</ul>
<p>– 相等:查找成功;<br>– 大于:待查记录在区间的前半段,修改上界指针: High=Mid-1 ,转 (1) ;<br>– 小于:待查记录在区间的后半段,修改下界指针: Low=Mid+1 ,转 (1) ;</p>
<ul>
  <li>直到越界 (Low&gt;High) ,查找失败</li>
</ul>
<p><strong>算法实现</strong>：</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">// 在有序表 t 中折半查找其关键字等于 key 的数据元素</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchSSTable</span><span class="params">(SSTable *t, KeyType key)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> low, high, mid;</div><div class="line">  low = <span class="number">1</span>; high = t-&gt;length; <span class="comment">// 置区间初值</span></div><div class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</div><div class="line">    mid = (low + high) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (EQ(key , t-&gt;elem[mid].key))</div><div class="line"><span class="comment">// 找到,返回该待查元素在表中的位置</span></div><div class="line">      <span class="keyword">return</span> mid;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (LT(key, t-&gt;elem[mid].key))</div><div class="line"><span class="comment">// 继续在前半区间进行查找</span></div><div class="line">      high = mid - <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="comment">// 继续在后半区间进行查找</span></div><div class="line">      low = mid + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 顺序表中不存在待查元素</span></div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>算法分析</strong>：</p>
<ul>
  <li>查找时,每经过一次比较,查找范围就缩小一半,该过程可用一棵二叉树表示:</li>
</ul>
<p>– 把当前查找区间的中点作为根结点<br>– 左子区间和右子区间分别作为根的左子树和右子树<br>– 排在中间位置前面的作为左子树的结点<br>– 排在中间位置后面的作为右子树的结点</p>
<ul>
  <li>上述描述查找过程的二叉树被称为折半查找的判定树(Decision Tree)</li>
</ul>
<p>– 内结点代表顺序表中已有的元素,外结点代表失败结点,它表示在两个相邻已有元素值之间的值</p>
<ul>
  <li>找到有序表中任一记录的过程是走了一条从根结点到与该记录相应的结点的路径,与给定值进行比较的关键字个数为该结点在判定树上的层次数</li>
  <li>查找成功时候的ASL = (n+1)/nlog2(n+1) - 1</li>
  <li>当n很大时(n&gt;50)，ASL = log2(n+1) - 1</li>
</ul>
<p><strong>算法优缺点分析</strong>：</p>
<ul>
  <li>Strength :折半查找速度很快</li>
</ul>
<p>– 1000 个元素的有序表,至多需要比较 10 次<br>– 1000,000 个元素的有序表,需要不超过 20 次的比较</p>
<ul>
  <li>Limitation :查找对象是有序表,即在查找之前需要对顺序表进行排序操作</li>
</ul>
<ul>
  <li>Weaknesses :</li>
</ul>
<p>– 折半查找无法应用于链表<br>– 在不等概率查找的情况下,折半查找不一定是有序表最好的查找方法<br>– 当查找表的长度不大时,也许折半查找的效率不如顺序查找</p>
<ul>
  <li>Conclusion :适合于大量的静态数据</li>
</ul>
<p>– 有序表的插入和删除都比较麻烦,平均要移动表中一半的元素</p>
<h4 id="Fibonacci-查找"><a href="#Fibonacci-查找" class="headerlink" title="Fibonacci 查找"></a>Fibonacci 查找</h4>
<ul>
  <li>基于有序顺序表的查找</li>
</ul>
<p>– 查找表中的所有记录是按关键字有序 ( 升序或降序 )排列的</p>
<ul>
  <li>查找过程中,先确定待查找记录在表中的范围,然后逐步缩小范围 ( 每次根据 Fibonacci 数列的特点对查找表进行分割 ) ,直到找到或找不到记录为止</li>
</ul>
<p><strong>算法思想</strong></p>
<ul>
  <li>设查找表中的记录数 n 比某个 Fibonacci 数小 1,即设 n=F(j)-1</li>
  <li>用 Low 、 High 和 Mid 表示待查找区间的下界、上界和分割位置,初值为 Low=1 , High=n</li>
  <li>(1) 取分割位置 Mid : Mid=F(j-1)</li>
  <li>(2) 比较 key 值与分割位置记录的关键字:</li>
</ul>
<p>– 相等: 查找成功<br>– 小于:待查记录在区间的前半段,修改上界指针:High=Mid-1 ,这时,区间长度为 F(j-1)-1 ,转(1) ;<br>– 大于:待查记录在区间的后半段,修改下界指针:Low=Mid+1 , 这时,区间长度为 F(j-2)-1 ,转(1) ;</p>
<ul>
  <li>直到越界 (Low&gt;High) ,查找失败</li>
</ul>
<p><strong>算法实现</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">//Fibonacci 数的计算</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, f, f0=<span class="number">0</span>, f1=<span class="number">1</span>;</div><div class="line">  <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ;</div><div class="line">  <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> ;</div><div class="line">  <span class="keyword">for</span> (i=<span class="number">2</span> ; i&lt;=n ; i++ ) &#123;</div><div class="line">    f=f0+f1 ; f0=f1 ; f1=f ; </div><div class="line">  &#125;chazhao</div><div class="line">  <span class="keyword">return</span> f ;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 在有序表 t 中用 Fibonacci 方法查找关键字为 key 的记录</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchSSTableFibonacci</span><span class="params">(SSTable *t, KeyType key , <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> Low=<span class="number">1</span>, High, Mid, f1, f2 ;</div><div class="line">  High=fib(n); </div><div class="line">  f1=fib(n<span class="number">-1</span>); </div><div class="line">  f2=fib(n<span class="number">-2</span>);<span class="function">chazhao</span></div><div class="line">  <span class="title">while</span> <span class="params">(Low&lt;=High)</span> &#123;</div><div class="line">    Mid=Low+f1<span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span> ( EQ(key, t-&gt;elem[Mid].key) ) </div><div class="line">      <span class="keyword">return</span> Mid ;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( LT(key, t-&gt;elem[Mid].key) )&#123; </div><div class="line">      High=Mid<span class="number">-1</span>; f2=f1-f2; f1=f1-f2; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123; </div><div class="line">      Low=Mid+<span class="number">1</span>; f1=f1-f2; f2=f2-f1; </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>算法分析</strong></p>
<ul>
  <li>Fibonacci 查找的平均性能比折半查找好，但最坏情况下比折半查找差。</li>
  <li>插值查找：根据key值来决定与哪个记录比较并分区。</li>
  <li>插值查找适用于关键字均匀分布。</li>
</ul>
<h4 id="索引顺序查找-分块查找"><a href="#索引顺序查找-分块查找" class="headerlink" title="索引顺序查找 / 分块查找"></a>索引顺序查找 / 分块查找</h4>
<ul>
  <li>查找表的组织:将查找表分成几块</li>
</ul>
<p>– 块间有序,即第 i+1 块的所有记录关键字均大于 ( 或小于 ) 第 i 块记录关键字<br>– 块内无序<br>– 在查找表的基础上附加一个索引表,索引表是按关键字有序的,索引表中记录的构成是:<br>– 可以建立多级索引<br>– 可以建立多种索引</p>
<ul>
  <li>先 ( 用顺序查找或折半查找 ) 确定待查记录所在块,再在块内查找 ( 顺序查找 )</li>
</ul>
<p><strong>算法实现</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">//数据结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> IndexType &#123;</div><div class="line">  KeyType maxkey; <span class="comment">// 块中最大的关键字</span></div><div class="line">  <span class="keyword">int</span> startpos;</div><div class="line"><span class="comment">// 块的起始位置指针</span></div><div class="line"><span class="comment">//int length;</span></div><div class="line"><span class="comment">// 块的长度</span></div><div class="line">&#125; Index;</div><div class="line"><span class="comment">//算法实现</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchSSTableBlock</span> <span class="params">(SSTable *t, Index ind[], KeyType key , <span class="keyword">int</span> n , <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 表长为 n ,块数为 b</span></div><div class="line">  <span class="keyword">int</span> i=<span class="number">0</span>, j , k ;</div><div class="line"><span class="comment">// 在块间顺序查找</span></div><div class="line">  <span class="keyword">while</span> ((i&lt;b)&amp;&amp; LT(ind[i].maxkey, key) ) i++ ;</div><div class="line">  <span class="keyword">if</span> (i&gt;b)</div><div class="line">    <span class="keyword">return</span>(<span class="number">0</span>); <span class="comment">// 没有找到</span></div><div class="line">  j=ind[i].startpos;</div><div class="line">  <span class="keyword">while</span> ((j&lt;n) &amp;&amp; LQ(t-&gt;elem[j].key, ind[i].maxkey) ) &#123;</div><div class="line"><span class="comment">// 在块内顺序查找</span></div><div class="line">    <span class="keyword">if</span> ( EQ(t-&gt;elem[j].key, key) ) <span class="keyword">break</span> ;</div><div class="line">    j++ ;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (j&gt;n||!EQ(t-&gt;elem[j].key, key) ) j=<span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span>(j)；</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>算法分析</strong></p>
<ul>
  <li>索引顺序查找的平均查找长度ASL等于 = 查找索引表确定所在块的平均查找长度Lb + 在块内查找元素的平均查找长度Lw.</li>
</ul>
<h4 id="查找方法比较"><a href="#查找方法比较" class="headerlink" title="查找方法比较"></a>查找方法比较</h4>
<table>
  <thead>
    <tr>
      <th style="text-align:right"></th>
      <th>顺序查找</th>
      <th>分块查找</th>
      <th>折半查找</th>
      <th>Fibonacci查找</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:right">表结构</td>
      <td>有序表/无序表</td>
      <td>分块有序表</td>
      <td>有序表</td>
      <td>有序表</td>
    </tr>
    <tr>
      <td style="text-align:right">存储结构</td>
      <td>顺序存储结构/线性链表</td>
      <td>顺序存储结构/线性链表</td>
      <td>顺序存储结构</td>
      <td>顺序存储结构</td>
    </tr>
    <tr>
      <td style="text-align:right">ASL</td>
      <td>最大</td>
      <td>介于两者之间</td>
      <td>最小</td>
      <td>平均比折半查找好</td>
    </tr>
  </tbody>
</table>
<h3 id="静态树表-次优查找树的查找"><a href="#静态树表-次优查找树的查找" class="headerlink" title="静态树表/次优查找树的查找"></a>静态树表/次优查找树的查找</h3>
<ul>
  <li>若有序表中的各个元素的查找概率不等,那么,用折半查找,性能未必最优</li>
  <li>如何改进,以提高性能 ?</li>
</ul>
<p>– 需要找到查找性能最佳的判定树,即,静态最优查找树 (Static Optimal Tree)<br>– 该判定树的带权内路径长度之和最小<br>$$Min PH=Min\sum_{i=1}^{n}w_i\times h_i$$<br>– n 为有序表长度, hi 为第 i 个结点在二叉树上的层次数, wi =cpi (i=1,2,…,n) , pi 为结点的查找概率, c 为常量</p>
<p><strong>算法思路</strong></p>
<ul>
  <li>构造静态最优查找树的时间开销太大</li>
  <li>为有序表构造次优查找树 (Nearly Optimal Search Tree)</li>
  <li>基于次优查找树的查找</li>
</ul>
<p>– 给定 Key ,<br>– 从根结点开始,将 Key 值与根结点比较,若 key大于根结点值,在右子树中查找,若 key 小于根结点值,在左子树中查找<br>– 平均查找长度与 logn 成正比</p>
<p><strong>次优查找树的构建</strong></p>
<ul>
  <li>
    <p>已知按关键字升序排列的记录序列$ (r<em>l ,r</em>{l+1} ,…,r_h )$ ,与每个记录相应的权值为 $w<em>l ,w</em>{l+1} ,…,w_h$,现构造一颗二叉树,使得该树的带权内路径长度 PH 值在所有具有相同权值的二叉树中近似为最小</p>
  </li>
  <li>
    <p>取第 i(l&lt;=i&lt;=h) 个记录构造根节点,使得下式取最小</p>
    <p>$$\Delta P<em>i=|\sum</em>{j=i+1}^{h}w<em>j-\sum</em>{j=l}^{i-1}|$$</p>
  </li>
  <li>
    <p>然后分别对子序列 $(r<em>l ,r</em>{l+1} ,…,r<em>{i-1} ) , (r</em>{i+1 },…,r_h )​$构造两颗次优查找树,并分别设为根节点的左子树和右子树.</p>
  </li>
</ul>
<p><strong>递归构造次优查找树t</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">// 根据有序表 R[low..high] 及其累计权值表 sw( 其中 sw[0]==0)构造次优查找树 t</span></div><div class="line"><span class="function">BiTree <span class="title">SecondOptimal</span><span class="params">(ElemType R[], <span class="keyword">float</span> sw[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i,j; </div><div class="line">  <span class="keyword">float</span> min,dw; </div><div class="line">  BiTree *t;</div><div class="line">  i = low; </div><div class="line">  min = (<span class="keyword">float</span>) <span class="built_in">fabs</span>(sw[high]-sw[low]);</div><div class="line">  dw = sw[high]+sw[low<span class="number">-1</span>];</div><div class="line">  <span class="keyword">for</span> (j=low+<span class="number">1</span>; j&lt;=high; ++j) <span class="comment">// 选择最小的 ΔPi 值</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(dw-sw[j]-sw[j<span class="number">-1</span>]) &lt; min) &#123;</div><div class="line">      i = j; min = (<span class="keyword">float</span>)<span class="built_in">fabs</span>(dw-sw[j]-sw[j<span class="number">-1</span>]);</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">if</span> (!(t = (BiTree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTreeTNode))))</div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">  t-&gt;data = R[i];</div><div class="line"><span class="comment">// 生成结点</span></div><div class="line">  <span class="keyword">if</span> (i==low) </div><div class="line">    t-&gt;lchild = <span class="literal">NULL</span>;</div><div class="line"><span class="comment">// 左子树空</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    t-&gt;lchild=SecondOptimal(R, sw, low, i<span class="number">-1</span>); <span class="comment">// 构造左子树</span></div><div class="line">  <span class="keyword">if</span> (i==high) </div><div class="line">    t-&gt;rchild = <span class="literal">NULL</span>; <span class="comment">// 右子树空</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    t-&gt;rchild=SecondOptimal(R, sw, i+<span class="number">1</span>, high); <span class="comment">// 构造右子树</span></div><div class="line">  <span class="keyword">return</span> t; </div><div class="line">&#125; <span class="comment">// SecondOptimal</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h3>
<p><strong>表的组织方式</strong></p>
<ul>
  <li>若以线性表的形式组织查找表,那么如需要对查找表进行插入、删除或排序操作,就必须移动大量的记录</li>
</ul>
<p>– 当记录数很多时,这种移动的代价很大</p>
<ul>
  <li>以树的形式组织查找表,可以对查找表进行动态、高效的查找</li>
</ul>
<p>– 二叉排序树<br>– 平衡二叉树<br>– B 树<br>– B+ 树<br>– 键树</p>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3>
<p>二叉排序树或者是空树,或者是满足下列性质的二叉树:</p>
<ul>
  <li>若左子树不为空,则左子树上所有结点的值( 关键字 ) 都小于根结点的值;</li>
  <li>若右子树不为空,则右子树上所有结点的值( 关键字 ) 都大于根结点的值;</li>
  <li>左、右子树都分别是二叉排序树</li>
  <li>每个结点的 Key 互不相同</li>
</ul>
<p><strong>数据结构</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">//BST 可以用二叉链表来存储</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> RecType&#123;</div><div class="line">  KeyType key;</div><div class="line"><span class="comment">//Others</span></div><div class="line">&#125; ElemType;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BiTreeNode &#123;</div><div class="line">  ElemType data;</div><div class="line">  <span class="keyword">struct</span> BiTreeNode *lchild,*rchild;</div><div class="line">&#125; *BiTree;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>BST的查找算法1</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">// 在根指针 T 所指二叉排序树中,</span></div><div class="line"><span class="comment">// 递归地查找其关键字等于 key 的数据元素,</span></div><div class="line"><span class="comment">// 若查找成功,则返回指向该数据元素结点的指针</span></div><div class="line"><span class="comment">// 若查找不成功,则返回空指针</span></div><div class="line"><span class="function">BiTree <span class="title">SearchBST</span> <span class="params">(BiTree T, KeyType key)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!T || EQ(key, T-&gt;data.key)) </div><div class="line">    <span class="keyword">return</span> T; <span class="comment">// 查找结束</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (LT(key, T-&gt;data.key))</div><div class="line">    <span class="keyword">return</span> SearchBST(T-&gt;lchild, key); <span class="comment">// 在左子树中查找</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> SearchBST(T-&gt;rchild, key); <span class="comment">// 在右子树中查找</span></div><div class="line">&#125; <span class="comment">// SearchBST</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>注：若按中序遍历一棵二叉排序树,所得到的结点序列是一个递增序列</strong></p>
<p><strong>BST的构造</strong></p>
<ul>
  <li>BST 是在查找过程中,当树中不存在关键字等于给定值的结点时进行插入</li>
</ul>
<p>– 新插入的结点一定是 BST 的一个新的叶子结点,并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子</p>
<ul>
  <li>因此:</li>
</ul>
<p>– 需要一个 BST 的查找算法,它在没有找到指定值时,返回:查找路径上访问的最后一个结点<br>– 基于上述查找算法,形成 BST 的构造算法：</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">// 若查找成功,则指针 p 指向该数据元素结点,并返回 TRUE</span></div><div class="line"><span class="comment">// 否则指针 p 指向查找路径上访问的最后一个结点,并返回</span></div><div class="line"><span class="comment">// FALSE 。指针 f 指向 T 的双亲,其初始调用值为 NULL</span></div><div class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, KeyType key, BiTree f, BiTree &amp;p)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span> (!T) &#123;</div><div class="line">    p = f; <span class="keyword">return</span> FALSE; </div><div class="line">  &#125; <span class="comment">// 查找不成功</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (EQ(key, T-&gt;data.key)) &#123;</div><div class="line">    p = T; <span class="keyword">return</span> TRUE; </div><div class="line">  &#125; <span class="comment">// 查找成功</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (LT(key, T-&gt;data.key))</div><div class="line">    <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p); <span class="comment">// 在左子树中查找</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p); <span class="comment">// 在右子树中查找</span></div><div class="line">&#125; <span class="comment">// SearchBST</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>BST的插入算法</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="comment">// 当二叉排序树 T 中没有关键字等于 e.key 的数据元素时,</span></div><div class="line"><span class="comment">// 插入 e 并返回 TRUE ,否则返回 FALSE</span></div><div class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree &amp;T, ElemType e)</span></span>&#123;</div><div class="line">  BiTree p,s;</div><div class="line">  <span class="keyword">if</span> (!SearchBST(T, e.key, <span class="literal">NULL</span>, p)) &#123; <span class="comment">// 查找不成功</span></div><div class="line">    s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>( BiTreeNode ));</div><div class="line">    s-&gt;data = e; </div><div class="line">    s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>; </div><div class="line">    <span class="keyword">if</span> (!p) T = s; <span class="comment">// 插入 s 为新的根结点</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (LT(e.key, p-&gt;data.key))</div><div class="line">      p-&gt;lchild=s; <span class="comment">// 插入 s 为左孩子 时,不必移动其它</span></div><div class="line">    <span class="keyword">else</span> </div><div class="line">      p-&gt;rchild=s;<span class="comment">// 插入 s 为右孩子</span></div><div class="line">    <span class="keyword">return</span> TRUE;</div><div class="line">  &#125; </div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> FALSE; <span class="comment">// 树中已有关键字相同的结点,不再插入</span></div><div class="line">&#125; <span class="comment">// Insert BST</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>BST上节点的删除</strong></p>
<p>从 BST 上删除一个结点,需要保证删除结点后的树仍满足 BST 的性质</p>
<p>设被删除结点为 p ,其父结点为 f ,分如下情况:</p>
<ol>
  <li>
    <p>若 p 是叶子结点: 直接删除 p</p>
  </li>
  <li>
    <p>若 p 只有一棵子树 ( 左子树或右子树 ) :直接用 p 的左子树 ( 或右子树 ) 取代 p 的位置而成为 f 的一棵子树</p>
  </li>
  <li>
    <p>若 p 既有左子树又有右子树</p>
    <p>方法一：用 p 的直接前驱 ( 或直接后继 ) 结点 s 代替 p ,即从 p 的左子树中选择值最大的结点 s 放在 p 的位置 ( 用结点 s 的内容替换结点 p 内容 ) ,然后删除结点 s ,并将 s的左子树作为 s 的父结点的右子树</p>
    <p>方法二：找到 s , s 是 p 的左子树中的最右边的结点且没有右子树,将 p 的右子树作为 s 的右子树,然后用 p 的左子树顶替被删结点 ( 也就是将 p 的左子树为 f 的左子树 )</p>
  </li>
</ol>
<p><strong>算法实现</strong></p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree *T, KeyType key)</span></span></div><div class="line"><span class="comment">// 若二叉排序树 T 中存在关键字等于 key 的数据元素时,</span></div><div class="line"><span class="comment">// 则删除该数据元素结点 p ,返回 TRUE ;否则返回 FALSE</span></div><div class="line">&#123; </div><div class="line">  <span class="keyword">if</span> (!T)</div><div class="line">    <span class="keyword">return</span> FALSE;<span class="comment">// 不存在关键字等于 key 的数据元素</span></div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (EQ(key, T-&gt;data.key))</div><div class="line"><span class="comment">// 找到关键字等于 key 的数据元素</span></div><div class="line">      <span class="keyword">return</span> Delete(T);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (LT(key, T-&gt;data.key))</div><div class="line">      <span class="keyword">return</span> DeleteBST(T-&gt;lchild, key);</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="keyword">return</span> DeleteBST(T-&gt;rchild, key);</div><div class="line">  &#125;</div><div class="line">&#125;<span class="comment">//DeleteBST</span></div><div class="line"><span class="comment">// 从二叉排序树中删除结点 p ,并重接它的左或右子树，伪代码</span></div><div class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree &amp;p)</span> </span>&#123;</div><div class="line">  BiTree q, s;</div><div class="line">  <span class="keyword">if</span> (!p-&gt;rchild) &#123;<span class="comment">// 右子树空则只需重接它的左子树</span></div><div class="line">    q = p; p = p-&gt;lchild;</div><div class="line">    <span class="comment">//将 p 原来的父结点 ( 设为 f) 与 p 相连 </span></div><div class="line">    f-&gt;lchild/rchild=p</div><div class="line">      <span class="built_in">free</span>(q); </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;lchild) &#123;<span class="comment">// 只需重接它的右子树</span></div><div class="line">    q = p; p = p-&gt;rchild;</div><div class="line">   <span class="comment">//将 p 原来的父结点 ( 设为 f) 与 p 相连 </span></div><div class="line">    f-&gt;lchild/rchild=p</div><div class="line">      <span class="built_in">free</span>(q); </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123; <span class="comment">// 左右子树均不空,按方法一</span></div><div class="line"><span class="comment">// 左右子树均不空</span></div><div class="line">    q = p; s = p-&gt;lchild;</div><div class="line">    <span class="keyword">while</span> (s-&gt;rchild)</div><div class="line"><span class="comment">// 转左,然后向右到尽头 q</span></div><div class="line">    &#123;</div><div class="line">      q = s; s = s-&gt;rchild;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//s 指向被删结点的前驱</span></div><div class="line">    p-&gt;data = s-&gt;data;</div><div class="line">    <span class="keyword">if</span> (q != p)</div><div class="line">      q-&gt;rchild = s-&gt;lchild;</div><div class="line"><span class="comment">// 重接 *q 的右子树</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">      q-&gt;lchild = s-&gt;lchild;</div><div class="line"><span class="comment">// 重接 *q 的左子树</span></div><div class="line">    <span class="built_in">free</span>(s);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<p><strong>BST的查找性能分析</strong></p>
<ul>
  <li>二叉排序树上成功的查找次数不会超过二叉树的深度,而具有 n 个结点的二叉排序树的深度,最好为 log2n ,最坏为 n 。因此二叉排序树查找的最好时间复杂度为 O(log2n) ,最坏的时间复杂度为 O(n)。</li>
  <li>在随机情况下, n 个结点的二叉排序树的平均查找长度 (ASL) 和log2n ( 树的深度 ) 是等数量级的。</li>
  <li>随机:各个元素的查找概率相同,元素组成的序列是随机的</li>
</ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;查找表 (Search Table) :相同类型的数据元素 ( 或记录 ) 组成的集合,每个数据元素通常由若干数据项构成&lt;/li&gt;
  &lt;li&gt;关键字 (Key ,码 ) :数据元素中某个 ( 或几个 ) 数据项的值,它可以标识一个数据元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;– 主关键字 (Primary Key) :能唯一标识一个数据元素的关键字&lt;br&gt;– 次关键字 (Secondary Key) :能标识若干个数据元素的关键字&lt;/p&gt;
&lt;h4 id=&quot;关键字类型&quot;&gt;&lt;a href=&quot;#关键字类型&quot; class=&quot;headerlink&quot; title=&quot;关键字类型&quot;&gt;&lt;/a&gt;关键字类型&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;数据元素的关键字:其类型通常是可以进行比较运算的类型&lt;/li&gt;
  &lt;li&gt;典型的关键字类型&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;gutter&quot;&gt;
        &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;
      &lt;/td&gt;
      &lt;td class=&quot;code&quot;&gt;
        &lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; KeyType ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实型&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; KeyType ; &lt;span class=&quot;comment&quot;&gt;// 整型&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; KeyType ; &lt;span class=&quot;comment&quot;&gt;// 字符串型&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;• 数据元素类型&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; RecType &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;KeyType key ; &lt;span class=&quot;comment&quot;&gt;// 关键字域&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;... ... &lt;span class=&quot;comment&quot;&gt;// 其他域&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; ElemType;&lt;/div&gt;&lt;/pre&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/figure&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Data-Structures" scheme="http://ucasfl.me/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>动态存储管理</title>
    <link href="http://ucasfl.me/2017/07/30/Dynamic-Memory-Management/"/>
    <id>http://ucasfl.me/2017/07/30/Dynamic-Memory-Management/</id>
    <published>2017-07-30T11:57:40.000Z</published>
    <updated>2017-09-02T04:38:29.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="存储空间的分配和管理"><a href="#存储空间的分配和管理" class="headerlink" title="存储空间的分配和管理"></a>存储空间的分配和管理</h3>
<ul>
  <li>问题的来源: ( 数据 ) 结构中的每一个数据元素都对应一定的存储空间,数据元素的访问都是通过对应的存储单元来进行的 – 操作系统、编译程序 ( 例如 JVM) 、用户程序</li>
  <li>问题的解决策略:采用动态存储管理思想</li>
  <li>存储空间的分配和管理策略的选择与用户的需求有关:
    <ul>
      <li>用户存储请求的分配量的大小分布</li>
      <li>用户存储分配请求和释放请求的频率</li>
      <li>分配效率 对系统的重要性</li>
    </ul>
  </li>
</ul>
<a id="more"></a>
<h3 id="动态存储管理-堆的管理"><a href="#动态存储管理-堆的管理" class="headerlink" title="动态存储管理 - 堆的管理"></a>动态存储管理 - 堆的管理</h3>
<ul>
  <li>堆(heap)：操作系统在内存中划出一块地址连续的大区域
    <ul>
      <li>占用块:已分配给用户使用的一块地址连续的内存区域;</li>
      <li>空闲块:未曾分配的地址连续的内存区域</li>
    </ul>
  </li>
  <li>堆的管理要解决的问题:如何根据用户的存储 / 内存分配请求分配内存空间?如何回收被释放的或不再使用的 ) 内存空间?</li>
  <li>堆的使用:利用程序设计语言提供的内存动态分配函数<br>– C : malloc() , calloc() , realloc , free() 函数<br>– C++ : new , delete 函数等</li>
</ul>
<h3 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h3>
<p>方式1： 从高地址空闲块中进行分配,直到分配无法进行时,才回收所有用户不再使用的空闲块,重新组织一个大的空闲块来再分配。</p>
<p>方式2：用户程序一旦运行结束,便将它所占的内存区释放成为空闲块,同时,每当新用户请求分配内存时,需查找整个内存区中所有空闲块,并从中找出一个合适的空闲块分配之。</p>
<h3 id="可利用空间表"><a href="#可利用空间表" class="headerlink" title="可利用空间表"></a>可利用空间表</h3>
<ul>
  <li>可利用空间表 / 存储池:包含所有可分配的空闲块</li>
</ul>
<p>​ – 当用户请求分配时,系统从可利用空间表中删除一个结点分配之<br>​ – 当用户释放其所占内存时,系统即回收并将它插入到可利用空间表中</p>
<ul>
  <li>可利用空间表的组织方式</li>
</ul>
<p>​ – 目录表<br>​ – 链表方式</p>
<h3 id="链式可利用空间表的分配方式"><a href="#链式可利用空间表的分配方式" class="headerlink" title="链式可利用空间表的分配方式"></a>链式可利用空间表的分配方式</h3>
<ul>
  <li>当可利用空间表以链表方式组织时,每个空闲块就是链表中的一个结点<br>– 分配时:从链表中找到一个合适的结点加以分配,然后将该结点删除之;<br>– 回收时:将空闲块插入到链表中。</li>
  <li>具体的分配和释放的策略取决于结点 ( 空闲块 ) 的结构<br>– 空闲块的大小相同<br>– 空闲块的大小只有几种规格<br>– 空闲块的大小不固定</li>
</ul>
<h4 id="分配方式1：空闲块的大小相同"><a href="#分配方式1：空闲块的大小相同" class="headerlink" title="分配方式1：空闲块的大小相同"></a>分配方式1：空闲块的大小相同</h4>
<p>– 将进行动态存储分配的整个内存区域( 堆 ) 按所需大小分割成若干大小相同的块,然后用指针链接成一个可利用空间表。<br>– 分配时:从表的首结点分配,然后删除该结点<br>– 回收时:将释放的空闲块插入表头<br>– 存在的问题:空间利用率不高<br>当请求分配的块空间大小比最大规格的结点还大时,分配不能进行。而实际上内存空间却可能存在比所需大小还要大的的连续空间。</p>
<h4 id="分配方式2：空闲块大小只有几种规格"><a href="#分配方式2：空闲块大小只有几种规格" class="headerlink" title="分配方式2：空闲块大小只有几种规格"></a>分配方式2：空闲块大小只有几种规格</h4>
<p>– 根据统计分析得到的概率分布,事先对动态分配的堆建立若干个可利用空间链表,同一链表中的结点 ( 块 ) 大小都相同。<br>– 分配时:根据请求的大小,将最接近该大小的某个链表的首结点分配给用户。若剩余部分正好是另一种规格大小,则将剩余部分插入到另一种规格的链表中,然后删除该结点<br>– 回收时:只要将所释放的空闲块插入到相应大小的表头<br>– 存在的问题:同前</p>
<h4 id="分配方式3：请求分配的块大小不确定"><a href="#分配方式3：请求分配的块大小不确定" class="headerlink" title="分配方式3：请求分配的块大小不确定"></a>分配方式3：请求分配的块大小不确定</h4>
<p>– 整个堆空间开始是一个空闲块,链表中只有一个大小为整个堆的结点,随着分配和回收的进行,链表中的结点大小和个数动态变化<br>– 链表结点中,增加一个表示结点大小的域 (size),以保存空闲块的大小<br>– 分配策略:若用户请求分配大小为 n(kB) 的内存,而链表中有若干大小不小于 n 的空闲块时,如何分配 ?</p>
<ul>
  <li>首次拟合法 (First fit)</li>
  <li>最佳拟合法 (Best fit)</li>
  <li>最差拟合法 (Worst fit)</li>
</ul>
<h3 id="首次拟合法-First-fit"><a href="#首次拟合法-First-fit" class="headerlink" title="首次拟合法 (First fit)"></a>首次拟合法 (First fit)</h3>
<ul>
  <li>分配时:从表头指针开始查找可利用空间表,将找到的第一个不小于 n 的空闲块的部分 ( 所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点</li>
  <li>回收时:将释放的空闲块插在链表的表头</li>
  <li>特点:分配时随机的;回收时仅需插入到表头</li>
</ul>
<h3 id="最佳拟合法-Best-fit"><a href="#最佳拟合法-Best-fit" class="headerlink" title="最佳拟合法 (Best fit)"></a>最佳拟合法 (Best fit)</h3>
<ul>
  <li>分配时:扫描整个可利用空间链表,找到一个大小满足要求且最接近 n 的空闲块,将其中的一部分 ( 即所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点</li>
  <li>回收时:只要将释放的空闲块插入到可利用空间链表的合适位置</li>
  <li>为了使分配时不需要扫描整个可利用空间链表,链表组织 ( 包括块回收时 ) 成按从小到大排序 ( 升序 )</li>
  <li>优点:适用于请求分配的内存块大小范围较广的系统</li>
  <li>缺点:系统容易产生无法分配的内存碎片;无论分配与回收,都需要查找空闲链表,最费时</li>
</ul>
<h3 id="最差拟合法-Worst-fit"><a href="#最差拟合法-Worst-fit" class="headerlink" title="最差拟合法 (Worst fit)"></a>最差拟合法 (Worst fit)</h3>
<ul>
  <li>分配时:扫描整个可利用空间链表,找到一个大小最大的空闲块,将其中的一部分 ( 所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点</li>
  <li>回收时:只要将释放的空闲块插入到链表的合适位置</li>
  <li>为了使分配时不需要扫描整个可利用空间链表,链表组织 ( 块回收时 ) 成按从大到小排序 (降序 )</li>
  <li>特点:适用于请求分配的内存块的大小范围较窄的系统;分配无需查找,回收需要查找适当的位置</li>
</ul>
<h3 id="边界标识法-Boundary-Tag-Method"><a href="#边界标识法-Boundary-Tag-Method" class="headerlink" title="边界标识法 (Boundary Tag Method)"></a>边界标识法 (Boundary Tag Method)</h3>
<ul>
  <li>操作系统中常用的动态存储管理方法</li>
  <li>将所有的空闲块链接成一个双重循环链表</li>
  <li>每个内存区域的头部和底部两个边界上分别设置标识,以标识该区域为占用块或空闲块</li>
  <li>在回收块时易于判别在物理位置上与其相邻的内存区域是否为空闲块,以便于将所有地址连续的空闲存储区合并成一个尽可能大的空闲块</li>
</ul>
<p>可利用空间表的节点结构：</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> word &#123;</div><div class="line"><span class="keyword">union</span> &#123;</div><div class="line"><span class="comment">// 头部域,指向前驱结点</span></div><div class="line">  <span class="keyword">struct</span> word *llink;</div><div class="line"><span class="comment">// 尾部域,指向本结点的头部</span></div><div class="line">  <span class="keyword">struct</span> word *uplink;</div><div class="line">&#125;;</div><div class="line">  <span class="keyword">int</span> tag; <span class="comment">//0 :空闲; 1 :占用</span></div><div class="line">  <span class="keyword">int</span> size;</div><div class="line"><span class="comment">// 头部域,指向后继结点</span></div><div class="line">  <span class="keyword">struct</span> word *rlink;</div><div class="line"><span class="comment">//OtherType other;</span></div><div class="line">&#125;WORD, head, foot, *Space;</div><div class="line"><span class="comment">// 指向 p 所指结点的底部</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FootLoc(p) (p+p-&gt;size-1)</span></div><div class="line"><span class="function">Space <span class="title">FootLoc</span><span class="params">(Space p)</span> </span>&#123;</div><div class="line">  <span class="keyword">char</span> *q; Space f;</div><div class="line">  q=(<span class="keyword">char</span> *)p;</div><div class="line">  f=(Space)(q+<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*p-&gt;size-<span class="keyword">sizeof</span>(foot));</div><div class="line">  <span class="keyword">return</span> f;</div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="分配算法：两个约定"><a href="#分配算法：两个约定" class="headerlink" title="分配算法：两个约定"></a>分配算法：两个约定</h3>
<h4 id="分配约定"><a href="#分配约定" class="headerlink" title="分配约定"></a>分配约定</h4>
<ul>
  <li>选定适当常量 e ,设待分配空闲块、请求分配空间的大小分别为 m 、 n</li>
  <li>当 m-n&lt;=e 时:将整个空闲块分配给用户;</li>
  <li>当 m-n&gt;e 时:则只分配请求的大小 n 给用户;</li>
  <li>尽量减少空闲块链表中出现小碎片 ( 容量 ≤ e) ,提高分配效率;减少对空闲块链表的维护工作量</li>
  <li>为了避免修改指针,约定将高地址部分分配给用户</li>
</ul>
<h4 id="查找约定"><a href="#查找约定" class="headerlink" title="查找约定"></a>查找约定</h4>
<ul>
  <li>每次需要查找空闲块时,从上次刚分配结点的后继结点开始查找空闲块</li>
  <li>作用:提高查找空闲块的速度,防止小容量结点聚集</li>
</ul>
<h3 id="分配算法：首次拟合法"><a href="#分配算法：首次拟合法" class="headerlink" title="分配算法：首次拟合法"></a>分配算法：首次拟合法</h3>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> e = <span class="number">16</span>; <span class="comment">// 不保留小于等于 e 的剩余量</span></div><div class="line"><span class="comment">// 若有不小于 n 的空闲块,则分配相应的存储块,并返</span></div><div class="line">回其首地址, 否则返回 <span class="function"><span class="literal">NULL</span></span></div><div class="line">Space <span class="title">AllocBoundTag</span><span class="params">(Space pav, <span class="keyword">int</span> n)</span> &#123;</div><div class="line">  Space p;</div><div class="line"><span class="comment">// 查找不小于 n 的空闲块</span></div><div class="line">  <span class="keyword">for</span> (p=pav; p &amp;&amp; p-&gt;size&lt;n &amp;&amp; p-&gt;rlink!=pav; p=p-&gt;rlink);</div><div class="line">  <span class="keyword">if</span> (!p || p-&gt;size&lt;n) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 找不到,返回空指针</span></div><div class="line">  <span class="keyword">else</span> &#123; <span class="comment">// p 指向找到的空闲块</span></div><div class="line">    Space f = FootLoc(p); <span class="comment">// f 指向底部</span></div><div class="line">    pav = p-&gt;rlink;</div><div class="line"><span class="comment">// pav 指向 *p 结点的后继结点</span></div><div class="line">    <span class="keyword">if</span> (p-&gt;size-n &lt;= e) &#123; <span class="comment">// 整块分配,不保留小于等于 e 的剩余量</span></div><div class="line">      <span class="keyword">if</span> (pav==p) pav = <span class="literal">NULL</span>; <span class="comment">// 可利用空间表变为空表</span></div><div class="line">      <span class="keyword">else</span> &#123; <span class="comment">// 在表中删除分配的结点</span></div><div class="line">        pav-&gt;llink = p-&gt;llink; p-&gt;llink-&gt;rlink = pav;</div><div class="line">      &#125;</div><div class="line">      p-&gt;tag = f-&gt;tag = <span class="number">1</span>; <span class="comment">// 修改分配结点的头部和底部标志</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 分配该块的后 n 个字</span></div><div class="line">      f-&gt;tag = <span class="number">1</span>; <span class="comment">// 修改分配块的底部标志</span></div><div class="line">      p-&gt;size -= n; <span class="comment">// 置剩余块大小</span></div><div class="line">      f = FootLoc(p); <span class="comment">// 指向剩余块底部</span></div><div class="line">      f-&gt;tag = <span class="number">0</span>; f-&gt;uplink = p; <span class="comment">// 设置剩余块底部</span></div><div class="line">      p = f+<span class="number">1</span>; <span class="comment">// 指向分配块头部</span></div><div class="line">      p-&gt;tag = <span class="number">1</span>; p-&gt;size = n; <span class="comment">// 设置分配块头部</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回分配块首地址</span></div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">// AllocBoundTag</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3>
<h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4>
<ul>
  <li>释放块的左、右邻块均为占用块:将被释放块简单地插入到空闲块链表中即可</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">p-&gt;tag=<span class="number">0</span> ; FootLoc(p)-&gt;uplink=p;</div><div class="line">FootLoc(p)-&gt;tag=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> ( !pav )</div><div class="line">pav=p-&gt;llink=p-&gt;rlink=p; <span class="comment">// 第一个空闲块</span></div><div class="line"><span class="keyword">else</span> &#123;<span class="comment">// 刚释放的空闲结点是插在 pav 之前,并成为 pav</span></div><div class="line">q=pav-&gt;llink; p-&gt;rlink=pav ;</div><div class="line">p-&gt;llink=q ; q-&gt;rlink=pav-&gt;llink=p ;</div><div class="line">pav=p ; <span class="comment">//pav 指向刚释放的空闲结点</span></div><div class="line"><span class="comment">// 成为下次分配最先查询的结点</span></div><div class="line">&#125;</div></pre>
      </td>
    </tr>
  </table>
</figure>
<h4 id="情况2、3"><a href="#情况2、3" class="headerlink" title="情况2、3"></a>情况2、3</h4>
<ul>
  <li>释放块的左邻块空闲而右邻块为占用:和左邻块合并成一个大的空闲块结点,改变左邻块的 size 域及重新设置 ( 合并后 ) 结点的底部</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">n=p-&gt;size;</div><div class="line">s=(p<span class="number">-1</span>)-&gt;uplink; s-&gt;size+=n; <span class="comment">// 设置新空闲块大小</span></div><div class="line">f=FootLoc(p); f-&gt;uplink=s; f-&gt;tag=<span class="number">0</span>; <span class="comment">// 设置新空闲块底部</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li>释放块的左邻占用而右邻空闲:和右邻块合并成一个大的空闲块结点,改变右邻块的 size 域及重新设置( 合并后 ) 结点的头部</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">t= FootLoc(p)+<span class="number">1</span>; p-&gt;tag=<span class="number">0</span>; q=t-&gt;llink;</div><div class="line">p-&gt;llink=q; q-&gt;rlink=p ; <span class="comment">// 设置空闲块的前驱</span></div><div class="line">q1=t-&gt;rlink ; p-&gt;rlink=q1 ; q1-&gt;llink=p ;</div><div class="line">p-&gt;size+=t-&gt;size; <span class="comment">// 设置新空闲块大小</span></div><div class="line">FootLoc(t)-&gt;uplink=p ; <span class="comment">// 底部指针指向新结点的头部</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h4 id="情况4"><a href="#情况4" class="headerlink" title="情况4"></a>情况4</h4>
<ul>
  <li>释放块的左、右邻块均为空闲块:和左、右邻块合并成一个大的空闲块结点,改变左邻块的 size 域及重新设置 ( 合并后 ) 结点的底部</li>
</ul>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre>
      </td>
      <td class="code">
        <pre><div class="line">n=p-&gt;size;</div><div class="line">s=(p<span class="number">-1</span>)-&gt;uplink;<span class="comment">//s 指向左邻块</span></div><div class="line">t= FootLoc(p)+<span class="number">1</span>; <span class="comment">//t 指向右邻块 , p+p-&gt;size</span></div><div class="line">s-&gt;size +=n+t-&gt;size; <span class="comment">// 设置新空闲结点的大小</span></div><div class="line"><span class="comment">// 在空闲链表中,删除右邻空闲块</span></div><div class="line">q=t-&gt;llink; q1=t-&gt;rlink; <span class="comment">// 修改右邻原来的关系</span></div><div class="line">q-&gt;rlink=q1; q1-&gt;llink=q ;</div><div class="line">FootLoc(t)-&gt;uplink=s; <span class="comment">// 新结点底部指针指向其头部</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="伙伴系统-Buddy-System"><a href="#伙伴系统-Buddy-System" class="headerlink" title="伙伴系统 (Buddy System)"></a>伙伴系统 (Buddy System)</h3>
<ul>
  <li>操作系统中常用的动态存储管理方法</li>
  <li>与边界标识法类似,所不同是:无论占用块或空闲块,其大小均为 2 的 k 次幂 ,不是以顺序片段来分配内存</li>
  <li>伙伴系统的可利用空间表:
    <ul>
      <li>将所有大小相同的空闲块建于一张子表中,每个子表是一个双重链表,这样的链表可能有 m+1 个</li>
      <li>再将这 m+1 个表头指针用向量结构组织成一个表</li>
    </ul>
  </li>
</ul>
<p>可利用空间表的结构:</p>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M 16</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> WORD_b &#123;</div><div class="line">  WORD_b * llink;<span class="comment">// 前驱结点</span></div><div class="line">  <span class="keyword">int</span> tag;<span class="comment">// 块占用标识</span></div><div class="line">  <span class="keyword">int</span> kval;<span class="comment">// 块的大小,是 2 的幂次</span></div><div class="line">  WORD_b *rlink;<span class="comment">// 后继结点</span></div><div class="line">  OtherType other;</div><div class="line">&#125; WORD_b, head;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> HeadNode &#123;</div><div class="line">  <span class="keyword">int</span> nodesize;</div><div class="line">  WORD_b * first;</div><div class="line">&#125; FreeList[M+<span class="number">1</span>];<span class="comment">// 子表个数为 M+1</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h4 id="伙伴系统的分配算法"><a href="#伙伴系统的分配算法" class="headerlink" title="伙伴系统的分配算法"></a>伙伴系统的分配算法</h4>
<figure class="highlight c">
  <table>
    <tr>
      <td class="gutter">
        <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre>
      </td>
      <td class="code">
        <pre><div class="line"><span class="function">WORD_b* <span class="title">AllocBuddy</span> <span class="params">(FreeList avail[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"><span class="comment">// avail[0..m] 为可利用空间表, n 为申请分配量,若有不小于n 的空闲块,则分配相应的存储块,并返回其首地址;否则返回 NULL</span></div><div class="line">  WORD_b *pa, *pre, *suc, *pi;</div><div class="line"><span class="comment">// 查找满足分配要求的子表</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=m &amp;&amp; (!avail[k].first ||avail[k].nodesize&lt;n+<span class="number">1</span>);k++) ;</div><div class="line">  <span class="keyword">if</span> (k&gt;m) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 分配失败</span></div><div class="line">  <span class="keyword">else</span> &#123; <span class="comment">// 进行分配</span></div><div class="line">    pa = avail[k].first; <span class="comment">// 指向可分配子表的第一个结点</span></div><div class="line"><span class="comment">// 分别指向前驱和后继</span></div><div class="line">    pre = pa-&gt;llink; suc = pa-&gt;rlink;</div><div class="line">    <span class="keyword">if</span> (pa==suc)</div><div class="line">      avail[k].first = <span class="literal">NULL</span>; <span class="comment">// 分配后该子表变成空表</span></div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 从子表删去 *pa 结点</span></div><div class="line">      pre-&gt;rlink = suc; suc-&gt;llink = pre;</div><div class="line">      avail[k].first = suc;</div><div class="line">    &#125;</div><div class="line"><span class="comment">// 将剩余块插入相应子表</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; avail[k-i].nodesize&gt;=n+<span class="number">1</span>; ++i) &#123;</div><div class="line">      pi = pa+(<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, (k-i)); pi-&gt;rlink = pi;</div><div class="line">      pi-&gt;llink = pi; pi-&gt;tag = <span class="number">0</span>; pi-&gt;kval = k-i;</div><div class="line">      avail[k-i].first = pi; </div><div class="line">    &#125;</div><div class="line">    pa-&gt;tag = <span class="number">1</span>; pa-&gt;kval = k-(--i);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> pa;</div><div class="line">&#125; <span class="comment">// AllocBuddy</span></div></pre>
      </td>
    </tr>
  </table>
</figure>
<h4 id="回收算法-1"><a href="#回收算法-1" class="headerlink" title="回收算法"></a>回收算法</h4>
<ul>
  <li>释放占用块时,需要将该新的空闲块插入到可利用空闲表中</li>
  <li>考虑合并成大块的问题:只有 “ 互为伙伴 ” 的两个子块均空闲时才合并;即使有两个相邻且大小相同的空闲块,如果不是 “ 互为伙伴 ” ( 从同一个大块中分裂出来的 ) 也不合并。</li>
</ul>
<p>设要回收的空闲块的首地址是 p ,其大小为 2^k :<br> (1) 判断其 “ 互为伙伴 ” 的块是否空闲:</p>
<ul>
  <li>若不空闲,仅将要回收的空闲块直接插入到相应的子表中;否则转 (2) ;</li>
</ul>
<p>(2) 按以下步骤进行空闲块的合并:</p>
<ul>
  <li>在相应子表中找到其伙伴并删除之;</li>
  <li>合并两个空闲块;</li>
</ul>
<p>(3) 重复 (2) ,直到合并后的空闲块的伙伴不是空闲块为止</p>
<ul>
  <li>特点:算法简单;速度快;但容易产生碎片</li>
</ul>
<h3 id="无用单元收集"><a href="#无用单元收集" class="headerlink" title="无用单元收集"></a>无用单元收集</h3>
<ul>
  <li>无用单元:用户不再使用而系统没有回收的变量和结构</li>
  <li>产生原因:程序 Bug</li>
</ul>
<p>– p=malloc(size); … … p=NULL; // 未回收的空间<br>– p=malloc(size); … … q=p;free(p);// 悬挂访问</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;存储空间的分配和管理&quot;&gt;&lt;a href=&quot;#存储空间的分配和管理&quot; class=&quot;headerlink&quot; title=&quot;存储空间的分配和管理&quot;&gt;&lt;/a&gt;存储空间的分配和管理&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;问题的来源: ( 数据 ) 结构中的每一个数据元素都对应一定的存储空间,数据元素的访问都是通过对应的存储单元来进行的 – 操作系统、编译程序 ( 例如 JVM) 、用户程序&lt;/li&gt;
  &lt;li&gt;问题的解决策略:采用动态存储管理思想&lt;/li&gt;
  &lt;li&gt;存储空间的分配和管理策略的选择与用户的需求有关:
    &lt;ul&gt;
      &lt;li&gt;用户存储请求的分配量的大小分布&lt;/li&gt;
      &lt;li&gt;用户存储分配请求和释放请求的频率&lt;/li&gt;
      &lt;li&gt;分配效率 对系统的重要性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Data-Structures" scheme="http://ucasfl.me/categories/Data-Structures/"/>
    
    
      <category term="Data-Structures" scheme="http://ucasfl.me/tags/Data-Structures/"/>
    
  </entry>
  
</feed>
