<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>查找和搜索-Part3 | Cry On My Shoulder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Data-Structures" />
  
  
  
  
  <meta name="description" content="键树 / 数字查找树Keyword Tree/Digital Search Tree 是关键字的一种组织方式,其具有下列特征:

( 结点 ) 树的结点包含组成关键字的符号，关键字中的各个符号分布在从根结点到叶的路径上,叶结点内的符号为“结束”的标志符。
键树的深度和关键字集合的大小无关,取决于关键字中字符或数位的个数
( 多叉 ) 度大于 2 的树，每个结点的最大度与关键字的“基”有关
( 排序">
<meta property="og:type" content="article">
<meta property="og:title" content="查找和搜索-Part3">
<meta property="og:url" content="http://ucasfl.me/2017/08/07/Find-and-Search-Part3/index.html">
<meta property="og:site_name" content="Cry On My Shoulder">
<meta property="og:description" content="键树 / 数字查找树Keyword Tree/Digital Search Tree 是关键字的一种组织方式,其具有下列特征:

( 结点 ) 树的结点包含组成关键字的符号，关键字中的各个符号分布在从根结点到叶的路径上,叶结点内的符号为“结束”的标志符。
键树的深度和关键字集合的大小无关,取决于关键字中字符或数位的个数
( 多叉 ) 度大于 2 的树，每个结点的最大度与关键字的“基”有关
( 排序">
<meta property="og:updated_time" content="2017-09-02T04:38:29.063Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="查找和搜索-Part3">
<meta name="twitter:description" content="键树 / 数字查找树Keyword Tree/Digital Search Tree 是关键字的一种组织方式,其具有下列特征:

( 结点 ) 树的结点包含组成关键字的符号，关键字中的各个符号分布在从根结点到叶的路径上,叶结点内的符号为“结束”的标志符。
键树的深度和关键字集合的大小无关,取决于关键字中字符或数位的个数
( 多叉 ) 度大于 2 的树，每个结点的最大度与关键字的“基”有关
( 排序">
  
    <link rel="alternate" href="/atom.xml" title="Cry On My Shoulder" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  
  <div class="site-header-image">
    <img id="originBg" width="100%" alt="Hike News" src="">
  </div>

  <div id="header-blur" class="site-header-image blur" style="position: absolute; top:0; height: 207px; min-height: 207px; min-width: 100%;">
    <img id="blurBg" width="100%" style="top: 96%" alt="Hike News" src="">
  </div>

  <script>
        var imgUrls = "css/images/2.jpeg,https://source.unsplash.com/collection/954550/1920x1080,https://source.unsplash.com/collection/954550/1920x1081".split(",");
        var random = Math.floor((Math.random() * imgUrls.length ));
        if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
          document.getElementById("originBg").src=imgUrls[random];
          document.getElementById("blurBg").src=imgUrls[random];
        } else {
          document.getElementById("originBg").src='/' + imgUrls[random];
          document.getElementById("blurBg").src='/' + imgUrls[random];
        }
    </script>




<header id="allheader" class="site-header" role="banner" 
   style="width: 100%; position: absolute; top:0; background: rgba(255,255,255,.8);"  >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="200px" height="200px" alt="Hike News" src=" /css/images/1.jppg">
              </a>
            
          </h1>
          
          
            <div class="site-description">高山仰止，景行行止</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">About</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Find-and-Search-Part3" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      查找和搜索-Part3
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/08/07/Find-and-Search-Part3/" class="article-date">
	  <time datetime="2017-08-07T04:51:28.000Z" itemprop="datePublished">August 7, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Data-Structures/">Data-Structures</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="键树-数字查找树"><a href="#键树-数字查找树" class="headerlink" title="键树 / 数字查找树"></a>键树 / 数字查找树</h3><p>Keyword Tree/Digital Search Tree 是关键字的一种组织方式,其具有下列特征:</p>
<ul>
<li>( 结点 ) 树的结点包含组成关键字的符号，关键字中的各个符号分布在从根结点到叶的路径上,叶结点内的符号为“结束”的标志符。</li>
<li>键树的深度和关键字集合的大小无关,取决于关键字中字符或数位的个数</li>
<li>( 多叉 ) 度大于 2 的树，每个结点的最大度与关键字的“基”有关</li>
<li>( 排序 ) 键树被约定为是一棵有序树,即同一层中兄弟结点之间依所含符号自左至右有序,并约定结束符‘ $’ 小于任何其它符号。</li>
</ul>
<p><strong>键树的存储结构:双链树</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> DLTNode &#123;</div><div class="line">  <span class="keyword">char</span> symbol;</div><div class="line">  <span class="keyword">struct</span> DLTNode *next; <span class="comment">// 指向兄弟结点的指针</span></div><div class="line">  NodeKind kind;</div><div class="line">  <span class="keyword">union</span> &#123;</div><div class="line">    Record *infoptr; <span class="comment">// 叶子结点内的记录指针</span></div><div class="line">    <span class="keyword">struct</span> DLTNode *first;</div><div class="line"><span class="comment">// 分支结点内的孩子链指针</span></div><div class="line">  &#125;</div><div class="line">&#125; DLTNode, *DLTree; <span class="comment">// 双链树的类型</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>在双链树中查找记录</strong></p>
<ul>
<li>假设: T 为指向双链树根结点的指针, K.ch 为待查关键字 ( 由 k.ch[0]..k.ch[num-2] 的字符组成, k.ch[num-1] 为 $)</li>
<li>查找过程: 从树根出发,沿 first 指针到结点 p ,进行比较K.ch[i] =? p-&gt;symbol ,其中, 0 ≤ i ≤ K.num-1， 若相等,沿 first 指针比较下一个字符， 若不等,沿 next 指针顺序查找</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXKEYLEN 20</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  <span class="keyword">char</span> ch[MAXKEYLEN]; <span class="comment">// 关键字</span></div><div class="line">  <span class="keyword">int</span> num;</div><div class="line"><span class="comment">// 关键字长度</span></div><div class="line">&#125; KeysType;</div><div class="line"><span class="comment">// 关键字类型</span></div><div class="line"><span class="function">RECORD *<span class="title">SearchDLTree</span><span class="params">(DLTree T, KeysType K)</span> </span>&#123;</div><div class="line">  DLTree p; <span class="keyword">int</span> i;</div><div class="line">  p = T-&gt;first; i=<span class="number">0</span>; <span class="comment">// 初始化</span></div><div class="line">  <span class="keyword">while</span> (p &amp;&amp; i&lt;K.num) &#123;</div><div class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;symbol != K.ch[i]) <span class="comment">// 查找关键字的第 i 位</span></div><div class="line">      p = p-&gt;next;</div><div class="line">    <span class="keyword">if</span> (p &amp;&amp; i&lt;K.num<span class="number">-1</span>) </div><div class="line">      p = p-&gt;first; <span class="comment">// 准备查找下一位</span></div><div class="line">    ++i; </div><div class="line">  &#125; <span class="comment">// 查找结束</span></div><div class="line">  <span class="keyword">if</span> (!p) </div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 查找不成功</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> p-&gt;infoptr; <span class="comment">// 查找成功</span></div><div class="line">&#125; <span class="comment">//Search DLTree</span></div></pre></td></tr></table></figure>
<p><strong>键树的存储结构: Trie 树</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> TrieNode &#123;</div><div class="line">  NodeKind kind; <span class="comment">// 结点类型</span></div><div class="line">  <span class="keyword">union</span> &#123;</div><div class="line">    <span class="keyword">struct</span> &#123; </div><div class="line">      KeyType K;</div><div class="line">      Record *infoptr</div><div class="line">    &#125; lf;</div><div class="line"><span class="comment">// 叶子结点 ( 关键字和指向记录的指针 )</span></div><div class="line">    <span class="keyword">struct</span> &#123;</div><div class="line">      TrieNode *ptr[<span class="number">27</span>]; </div><div class="line">      <span class="keyword">int</span> num </div><div class="line">    &#125; bh;</div><div class="line"><span class="comment">// 分支结点 (27 个指向下一层结点的指针 )</span></div><div class="line">  &#125;</div><div class="line">&#125; TrieNode, *TrieTree; <span class="comment">// 键树类型T</span></div></pre></td></tr></table></figure>
<p><strong>在Trie树中查找记录</strong></p>
<ul>
<li>假设 :</li>
</ul>
<p>– T 为指向 Trie 树根结点的指针, K.ch 为待查关键字 ( 由 k.ch[0]..k.ch[num-2] 的字符组成, k.ch[num-1] 为 $)</p>
<ul>
<li>查找过程:</li>
</ul>
<p>– 从树根出发,搜索和对应字母相应的指针 p:<br>– 若 p 不空,且 p 所指为分支结点,则<br>– p= p-&gt;bh.ptr[ord(K.ch[i])] ( 其中, ord 给出字符<br>在字母表中的序号, 0 ≤ i ≤ K.num-1 )<br>– 沿 p 指针比较下一个字符,直到叶子结点<br>– 若未找到 p ,则查找不成功</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在键树 T 中查找关键字等于 K 的记录</span></div><div class="line"><span class="comment">//ord 求字符在字母表中序号</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ord</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> c-<span class="string">'@'</span>; </div><div class="line">&#125;</div><div class="line"><span class="function">RECORD *<span class="title">SearchTrie</span><span class="params">(TrieTree T, KeysType K)</span> </span>&#123;</div><div class="line">  TrieTree p; <span class="keyword">int</span> i;</div><div class="line"><span class="comment">// 对 K 的每个字符逐个查找, *p 为分支结点</span></div><div class="line">  <span class="keyword">for</span> (p=T, i=<span class="number">0</span>; p &amp;&amp; p-&gt;kind==BRANCH &amp;&amp; i&lt;K.num;p=p-&gt;bh.ptr[ord(K.ch[i])], i++) ;</div><div class="line">  <span class="keyword">if</span> (p &amp;&amp; p-&gt;kind==LEAF &amp;&amp;<span class="built_in">strcmp</span>(p-&gt;lf.K.ch, K.ch)==<span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> p-&gt;lf.infoptr; <span class="comment">// 查找成功</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 查找不成功</span></div><div class="line">&#125; <span class="comment">//SearchTrie</span></div></pre></td></tr></table></figure>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><strong>基本思想</strong></p>
<ul>
<li>Motivation :已有的查找方法需要进行一系列的指定值与数据元素的关键字的比较</li>
</ul>
<p>– 不同的查找其差别在于关键字和给定值进行比较的顺序不同<br>– 原因:数据元素的关键字和数据元素的存储位置之间没有确定的关系<br>– 结果:查找的效率取决于和给定值进行比较的关键字的个数</p>
<ul>
<li>Solution : ( 通过哈希函数和冲突处理方法 ) 由记录的关键字确定记录在表中的地址,并将记录放入此地址,这样构成的表叫哈希表</li>
</ul>
<p>– 哈希查找 ( 又叫散列查找 ) :通过哈希表中的对应关系进行一次存取,就能得到所查的元素<br>– 特别适用于,只知道关键字的所属范围,但不知道确切的关键字</p>
<p><strong>基本概念</strong></p>
<ul>
<li>哈希函数:在记录的关键字与记录的存储地址之间建立了一种确定的对应关系</li>
</ul>
<p>– 哈希函数是一种映象,是从关键字空间到存储地址空间的一种映象。<br>– 对于记录 ai , addr(ai) =H(ki) ,其中, addr(ai)是 ai 的地址, ki 是记录 ai 的关键字<br>– 哈希函数通常是一种压缩映象,所以冲突不可避免<br>– 冲突:对于关键字 ki 、 kj ,若 ki!=kj ,但 H(ki)=H(kj) 的现象叫冲突 (collision)<br>– 同义词:具有相同哈希函数值的两个不同的关键字,称为该哈希函数的同义词</p>
<p><strong>哈希表设计要素</strong></p>
<ul>
<li>确定哈希函数的定义域 ( 所有关键字 ) 和值域(0… m-1)</li>
<li>构造合适的哈希函数</li>
</ul>
<p>– 使得同一关键字总被映射到同一地址<br>– 使得对于所有可能的元素 ( 记录的关键字 ) ,其函数值能尽可能覆盖整个地址空间且均匀地映射到地址空间</p>
<p>​                  - 所谓均匀 (uniform) 是指从一个关键字映射到地址集合中任何一个地址的概率是相等的,即使得发生冲突的可能性尽可能最少</p>
<p>– 哈希函数的构造简单,能在较短的时间内计算出来。</p>
<ul>
<li>冲突元给出处理冲突的方法,即当冲突出现时如何为冲突元素找到另一个存储位置。</li>
</ul>
<h4 id="哈希函数的构造"><a href="#哈希函数的构造" class="headerlink" title="哈希函数的构造"></a>哈希函数的构造</h4><p><strong>直接定址法</strong></p>
<p>直接定址法:取关键字或关键字的某个线性函数作哈希地址,即:H(key)=key 或 H(key)=a·key+b (a,b 为常数 )</p>
<ul>
<li>特点:直接定址法所得地址集合与关键字集合大小相等,不会发生冲突,但实际中很少使用</li>
<li>举例:根据年份查找该年份的人口数量</li>
</ul>
<p><strong>数字分析法</strong></p>
<p>数字分析法:若关键字为以 r 为基的数,取关键字的若干位或组合作为哈希地址</p>
<ul>
<li>特点:适用于关键字位数比哈希地址位数大,且事先知道可能出现的关键字的情况 ( 如频度 )</li>
</ul>
<p><strong>平方取中法</strong></p>
<p>平方取中法:将关键字平方后取中间几位作为哈希地址</p>
<ul>
<li>哈希函数所取的位数由哈希表的长度决定</li>
</ul>
<ul>
<li>特点:一个数平方后中间几位和数的每一位都有关,则由随机分布的关键字得到的哈希地址也是随机的</li>
</ul>
<p>– 适用于:不知道全部关键字情况<br>– 适用于:关键字中的每一位都有某些数字重复出现</p>
<p><strong>折叠法</strong></p>
<p>折叠法 (folding) :将关键字分割成位数相同的几部分 ( 最后一部分可以不同 ) ,然后取这几部分的叠加和作为哈希地址</p>
<ul>
<li>数位叠加有移位叠加和间界叠加</li>
</ul>
<p>– 移位叠加:将分割后的几部分低位对齐相加<br>– 间界叠加:从一端到另一端沿分割界来回折迭,然后对齐相加</p>
<ul>
<li>特点:适于关键字位数很多,且每一位上数字分布大致均匀</li>
</ul>
<p><strong>除留余数法</strong></p>
<p>除留余数法:取关键字被某个不大于哈希表表长 m 、但最接近于或等于 m 的质数 p 除后所得余数作哈希地址,即:<br>H(key) = key MOD p (p $\le$ m)<br>– 从 p 到 (m-1) 的地址可以在处理冲突的时候用</p>
<ul>
<li>特点:简单、常用的哈希函数构造方法</li>
<li>一般,哈希函数可以设成:</li>
</ul>
<p>H(key) =(a*key+b) MOD p  (a&gt;0, b&gt;0, a MOD p!=0, p 为素数 )</p>
<p>p的选取：</p>
<ul>
<li>选取$p=2^i(p\le m)$  :便于用移位来实现运算,但等于将关键字的高位忽略而仅留下低位二进制数,因此,高位不同而低位相同的关键字都成为了同义词</li>
<li>选取 $p=q\times f$ (q 、 f 都是 p 的质因数, p$\le $m) :则所有含有 q 或 f 因子的关键字的哈希地址均是 q或 f 的倍数</li>
</ul>
<p><strong>随机数法</strong></p>
<p>随机数法:取关键字的随机函数值作哈希地址,即 H(key)=random(key)</p>
<ul>
<li>当哈希表中关键字长度不等时,该方法比较合适</li>
</ul>
<p><em>选取哈希函数时应考虑的因素</em></p>
<ul>
<li>计算哈希函数所需时间</li>
<li>关键字的长度</li>
<li>哈希表长度 ( 即哈希地址范围 )</li>
<li>关键字分布情况</li>
<li>记录的查找频率</li>
</ul>
<h4 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h4><p><strong>开放定址法</strong></p>
<ul>
<li>当冲突发生时,形成某个探测序列;按此序列逐个探测哈希表中的其他地址,直到为给定的关键字找到一个空地址 ( 开放的地址 ) 为止,将发生冲突的记录放到该地址中</li>
<li>哈希地址的计算公式是:</li>
</ul>
<p>H0 =H(key)<br>Hi (key)=(H(key)+di ) MOD m , i=1, 2, …, m-1<br>– 其中: H(key) 为哈希函数; m 是哈希表长度; Hi (key) 为经第 i 次探测后得到的哈希地址; di 是第 i 次探测时的增量序列</p>
<ul>
<li>根据 di 的形成方法,有:</li>
</ul>
<p>– 线性探测法 (Linear Probing)<br>– 二次探测法 (Quadratic Probing)<br>– 伪随机探测法: 用伪随机函数获得伪随机数列</p>
<p><em>线性探测法</em></p>
<ul>
<li>将哈希表 T[0 …m-1] 看成循环向量。当发生冲突时,从初次发生冲突的位置依次向后探测其他的地址,即: 增量序列为: di=1, 2, 3, …, m-1</li>
<li>设初次发生冲突的地址是 h ,则依次探测 T[h+1] , T[h+2]… ,直到 T[m-1] 时又循环到表头,再次探测 T[0] , T[1]… ,直到 T[h-1]</li>
<li>探测过程终止的情况:</li>
</ul>
<p>– 探测到的地址为空:表中没有记录。若是查找操作则失败;若是插入操作，则将记录写入到该地址<br>– 探测到的地址有给定的关键字:若是查操作找则成功;若是插入操作则失败<br>– 直到 T[h] :仍未探测到空地址或给定的关键字,则表示哈希表满</p>
<ul>
<li>线性探测法的特点:</li>
</ul>
<p>– 优点:只要哈希表未满,总能找到一个不冲突的哈希地址<br>– 缺点:二次聚集 ( 两个第一次哈希地址不同的记录争夺同一个后继哈希地址 )</p>
<p><em>二次探测法</em></p>
<ul>
<li>增量序列为: $d_i=1^2,-1^2,2^2,-2^2,3^2,……+k^2,- k^2 (k\le ⌊ m/2 ⌋ )$</li>
</ul>
<p>– 当 M 是质数,且装填因子小于等于 0.5 ,可以找出空闲地址<br>– 表长 m 形如 4j+3 的质数 ( 如 7, 11, 19, 23, 31, 43, … 等 ) 时,可以保证查找链的前 m 项均互异:基于 费马双平方定理</p>
<ul>
<li>除了 2 这个特殊的素数,所有的素数都可以分两类:被 4 除余 1 的素数,如 5 , 13 , 17 , 29 , 37 , 41 ,这类素数都能表示为两个整数的平方和;第二类则是被 4 除余 3 的素数如 3, 7 , 11 , 19 , 23 , 31 。这类不能表示为两个整数的平方和。</li>
<li>优点:探测序列跳跃式地哈希到整个表中,不易产生冲突的聚集现象</li>
<li>缺点:不能保证探测到哈希表的所有地址</li>
</ul>
<p><strong>再哈希法</strong></p>
<ul>
<li>构造若干个哈希函数,当发生冲突时,利用不同的哈希函数再计算下一个新哈希地址,直到不发生冲突为止,</li>
</ul>
<p>– 即: Hi =RHi (key) i=1, 2, …, k<br>– 其中, RHi 为一组不同的哈希函数。第一次发生冲突时,用 RH1 计算,第二次发生冲突时,用 RH2 计算,依此类推直到到某个 Hi 不发生冲突为止</p>
<ul>
<li>优点:不易产生冲突的聚集现象</li>
<li>缺点:计算时间增加</li>
</ul>
<p><strong>链地址法</strong></p>
<ul>
<li>将所有关键字为同义词 ( 哈希地址相同 ) 的记录存储在一个单链表中,并用一维数组存放链表的头指针</li>
<li>设哈希表长为 m ,定义一个一维指针数组: RecNode *linkhash[m] ,其中 RecNode 是结点类型,每个分量的初值为空。凡哈希地址为 k 的记录都插入到以 linkhash[k] 为头指针的链表中,插入位置可以在表头或表尾或按关键字排序插入</li>
<li>优点:不易产生冲突的聚集;删除记录也很简单</li>
</ul>
<p><strong>建立公共溢出区</strong></p>
<ul>
<li>在基本哈希表之外,另外设立一个溢出表保存与基本表中记录冲突的所有记录</li>
<li>设哈希表长为 m ,设立基本哈希表 Hashtable[m],每个分量保存一个记录;溢出表 Overtable[m],一旦某个记录的哈希地址发生冲突,都填入溢出表中</li>
</ul>
<h3 id="哈希查找过程"><a href="#哈希查找过程" class="headerlink" title="哈希查找过程"></a>哈希查找过程</h3><ul>
<li>哈希表的主要目的是用于快速查找,且插入和删除操作都要用到查找</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开放定址哈希表的结构</span></div><div class="line"><span class="keyword">int</span> hashsize[] = &#123; <span class="number">997</span>, ... &#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  ElemType *elem; <span class="comment">//ElemType 中含 key</span></div><div class="line">  <span class="keyword">int</span> count; <span class="comment">// 当前数据元素个数</span></div><div class="line">  <span class="keyword">int</span> sizeindex;<span class="comment">// hashsize[sizeindex] 为当前容量</span></div><div class="line">&#125; HashTable;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DUPLICATE -1</span></div><div class="line"></div><div class="line"><span class="comment">//在哈希表 H 中查找关键码为 K 的元素</span></div><div class="line"><span class="function">Status <span class="title">SearchHash</span><span class="params">(HashTable H, HKeyType K, <span class="keyword">int</span> &amp;p, <span class="keyword">int</span> &amp;c)</span> </span>&#123;</div><div class="line"><span class="comment">// 若查找成功,以 p 指示待查数据元素在表中位置,并返回</span></div><div class="line"><span class="comment">//SUCCESS ,否则,以 p 指示插入位置,并返回 UNSUCCESS,</span></div><div class="line"><span class="comment">//c 用以记录冲突次数,其初值置零,供建表插入时参考</span></div><div class="line">  p = Hash(K); <span class="comment">// 求得哈希地址</span></div><div class="line">  <span class="keyword">while</span> ((H.elem[p].key != NULLKEY) &amp;&amp; !equal(K, (H.elem[p].key))) <span class="comment">// 该位置中填有记录，并且关键字不相等</span></div><div class="line">    collision(p, ++c); <span class="comment">// 求得下一探查地址 p</span></div><div class="line">  <span class="keyword">if</span> (equal(K, (H.elem[p].key)))</div><div class="line">    <span class="keyword">return</span> SUCCESS;</div><div class="line"><span class="comment">// 查找成功, p 返回待查数据元素位置</span></div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> UNSUCCESS;</div><div class="line"><span class="comment">// 查找不成功, p 返回的是插入位置</span></div><div class="line">&#125; <span class="comment">// SearchHash</span></div><div class="line"></div><div class="line"><span class="comment">//哈希表插入算法</span></div><div class="line"><span class="function">Status <span class="title">InsertHash</span><span class="params">(HashTable &amp;H, HElemType e)</span> </span>&#123;</div><div class="line"><span class="comment">// 查找不成功时插入数据元素 e 到开放定址哈希表 H 中,</span></div><div class="line"><span class="comment">// 并返回 OK ;若冲突次数过大,则重建哈希表</span></div><div class="line">  <span class="keyword">int</span> c = <span class="number">0</span>; <span class="keyword">int</span> p = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (SearchHash(H, e.key, p, c) == SUCCESS )</div><div class="line">    <span class="keyword">return</span> DUPLICATE;</div><div class="line"><span class="comment">// 表中已有与 e 有相同关键字的元素</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; H.cursize) &#123;</div><div class="line"><span class="comment">// 冲突次数 c 未达到上限 ( 阈值 c 可调 )</span></div><div class="line">    H.elem[p] = e; ++H.count;</div><div class="line">    <span class="keyword">return</span> SUCCESS; <span class="comment">// 插入 e</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    RecreateHashTable(H); <span class="comment">// 重建哈希表</span></div><div class="line">    <span class="keyword">return</span> UNSUCCESS; </div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">// InsertHash</span></div></pre></td></tr></table></figure>
<p><strong>哈希查找的性能分析</strong></p>
<ul>
<li>从哈希查找过程可见,尽管哈希表在关键字与记录的存储地址之间建立了直接映象,但由于存在冲突,查找过程仍是一个给定值与关键字进行比较的过程,仍要用 ASL 评价哈希查找效率</li>
<li>哈希查找时,关键字与给定值比较的次数取决于:</li>
</ul>
<p>– 哈希函数<br>– 处理冲突的方法<br>– 哈希表的填满因子：$\alpha=\frac{\text{表中填入的记录数}}{\text{哈希表的长度}}$</p>
<ul>
<li>一般情况下,可以认为选用的哈希函数是均匀的,则在讨论 ASL 时,可以不考虑它的因素</li>
<li>哈希表的ASL是填满因子$\alpha$的函数，而不是$n$的函数。</li>
<li>用哈希表构造查找表时，可以选择一个合适的填满因子，使得ASL限定在某个范围内。</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Data-Structures/">Data-Structures</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structures/">Data-Structures</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/08/08/Inner-Sort/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          内部排序
        
      </div>
    </a>
  
  
    <a href="/2017/08/07/Find-and-Search-Part2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">查找和搜索-Part2</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#键树-数字查找树"><span class="nav-number">1.</span> <span class="nav-text">键树 / 数字查找树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表"><span class="nav-number">2.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希函数的构造"><span class="nav-number">2.1.</span> <span class="nav-text">哈希函数的构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#冲突处理方法"><span class="nav-number">2.2.</span> <span class="nav-text">冲突处理方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希查找过程"><span class="nav-number">3.</span> <span class="nav-text">哈希查找过程</span></a></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2017 Cry On My Shoulder All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
      var headerblur = document.getElementById("header-blur");
      headerblur.style.minHeight = window.getComputedStyle(document.getElementById("allheader"), null).height;
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>








	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
