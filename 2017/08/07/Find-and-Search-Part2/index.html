<!DOCTYPE html>






<html class="theme-next muse use-motion" lang="zh-Hans">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="theme-color" content="#222">









  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />


















  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







  <link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

  <link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Data-Structures," />





  <link rel="alternate" href="/atom.xml" title="春暖花开" type="application/atom+xml" />






  <meta name="description" content="AVL 树

  Motivation: 二叉排序树是一种查找效率比较高的数据组织形式,但其平均查找长度受树的形态影响较大,形态比较均匀时查找效率很好,形态明显偏向某一方向时其效率就大大降低。因此,希望有更好的二叉排序树,其形态总是均衡的,查找时能得到最好的效率
  Solution: 平衡二叉排序树 (Balanced Binary Sort Tree) ,由 Adelson-Velskii 和">
  <meta property="og:type" content="article">
  <meta property="og:title" content="查找和搜索-Part2">
  <meta property="og:url" content="http://ucasfl.me/2017/08/07/Find-and-Search-Part2/index.html">
  <meta property="og:site_name" content="春暖花开">
  <meta property="og:description" content="AVL 树

  Motivation: 二叉排序树是一种查找效率比较高的数据组织形式,但其平均查找长度受树的形态影响较大,形态比较均匀时查找效率很好,形态明显偏向某一方向时其效率就大大降低。因此,希望有更好的二叉排序树,其形态总是均衡的,查找时能得到最好的效率
  Solution: 平衡二叉排序树 (Balanced Binary Sort Tree) ,由 Adelson-Velskii 和">
  <meta property="og:updated_time" content="2017-09-02T04:38:29.063Z">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="查找和搜索-Part2">
  <meta name="twitter:description" content="AVL 树

  Motivation: 二叉排序树是一种查找效率比较高的数据组织形式,但其平均查找长度受树的形态影响较大,形态比较均匀时查找效率很好,形态明显偏向某一方向时其效率就大大降低。因此,希望有更好的二叉排序树,其形态总是均衡的,查找时能得到最好的效率
  Solution: 平衡二叉排序树 (Balanced Binary Sort Tree) ,由 Adelson-Velskii 和">



  <script type="text/javascript" id="hexo.configurations">
    var NexT = window.NexT || {};
    var CONFIG = {
      root: '/',
      scheme: 'Muse',
      version: '5.1.3',
      sidebar: {
        "position": "left",
        "display": "post",
        "offset": 12,
        "b2t": false,
        "scrollpercent": false,
        "onmobile": false
      },
      fancybox: true,
      tabs: true,
      motion: {
        "enable": true,
        "async": false,
        "transition": {
          "post_block": "fadeIn",
          "post_header": "slideDownIn",
          "post_body": "slideDownIn",
          "coll_header": "slideLeftIn",
          "sidebar": "slideUpIn"
        }
      },
      duoshuo: {
        userId: '0',
        author: '博主'
      },
      algolia: {
        applicationID: '',
        apiKey: '',
        indexName: '',
        hits: {
          "per_page": 10
        },
        labels: {
          "input_placeholder": "Search for Posts",
          "hits_empty": "We didn't find any results for the search: ${query}",
          "hits_stats": "${hits} results found in ${time} ms"
        }
      }
    };
  </script>



  <link rel="canonical" href="http://ucasfl.me/2017/08/07/Find-and-Search-Part2/" />





  <title>查找和搜索-Part2 | 春暖花开</title>









</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">






  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner">
        <div class="site-brand-wrapper">
          <div class="site-meta ">


            <div class="custom-logo-site-title">
              <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">春暖花开</span>
        <span class="logo-line-after"><i></i></span>
      </a>
            </div>

            <p class="site-subtitle">love, life, thinking, coding</p>

          </div>

          <div class="site-nav-toggle">
            <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
          </div>
        </div>

        <nav class="site-nav">



          <ul id="menu" class="menu">


            <li class="menu-item menu-item-home">
              <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
            </li>


            <li class="menu-item menu-item-archives">
              <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
            </li>



          </ul>



        </nav>



      </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">


            <div id="posts" class="posts-expand">








              <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">



                <div class="post-block">
                  <link itemprop="mainEntityOfPage" href="http://ucasfl.me/2017/08/07/Find-and-Search-Part2/">

                  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Flynn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

                  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="春暖花开">
    </span>


                  <header class="post-header">



                    <h1 class="post-title" itemprop="name headline">查找和搜索-Part2</h1>


                    <div class="post-meta">
                      <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

                      <span class="post-meta-item-text">发表于</span>

                      <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-07T12:51:24+08:00">
                2017/08/07
              </time>





                      </span>


                      <span class="post-category">
            
              <span class="post-meta-divider">|</span>

                      <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>

                      <span class="post-meta-item-text">分类于</span>


                      <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Structures/" itemprop="url" rel="index">
                    <span itemprop="name">Data-Structures</span>
                      </a>
                      </span>




                      </span>




                      <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                      <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                      <a href="/2017/08/07/Find-and-Search-Part2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2017/08/07/Find-and-Search-Part2/" itemprop="commentsCount"></span>
                </a>
                      </span>












                    </div>
                  </header>





                  <div class="post-body" itemprop="articleBody">





                    <h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3>
                    <ul>
                      <li>Motivation: 二叉排序树是一种查找效率比较高的数据组织形式,但其平均查找长度受树的形态影响较大,形态比较均匀时查找效率很好,形态明显偏向某一方向时其效率就大大降低。因此,希望有更好的二叉排序树,其形态总是均衡的,查找时能得到最好的效率</li>
                      <li>Solution: 平衡二叉排序树 (Balanced Binary Sort Tree) ,由 Adelson-Velskii 和 Landis于 1962 年提出的,故称 AVL 树</li>
                      <li>变种:红黑树,树堆,伸展树</li>
                    </ul>
                    <p><strong>基本概念</strong></p>
                    <p>平衡二叉树 (Balanced Binary Tree 或 Height-Balanced Tree) 或者是空树,或者是满足下列性质的二叉树</p>
                    <ul>
                      <li>左子树和右子树深度之差的绝对值不大于 1</li>
                      <li>左子树和右子树也都是平衡二叉树</li>
                    </ul>
                    <p>结点的平衡因子 (Balance Factor) :该结点的右子树的深度减去其左子树深度</p>
                    <ul>
                      <li>平衡二叉树上每个结点的平衡因子只可能是 1 、 0和 -1</li>
                      <li>平衡二叉排序树 (Balanced Binary Sort Tree) :一棵二叉树既是二叉排序树又是平衡二叉树</li>
                    </ul>
                    <a id="more"></a>
                    <p><strong>结构定义</strong></p>
                    <figure class="highlight c">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre>
                          </td>
                          <td class="code">
                            <pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BSTNode &#123;</div><div class="line">  ElemType data;</div><div class="line">  <span class="keyword">int</span> bf; <span class="comment">// 平衡因子</span></div><div class="line">  <span class="keyword">struct</span> BSTNode *lchild , *rchild;</div><div class="line">&#125; BSTNode, *BSTree;</div></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p><strong>平衡化旋转</strong></p>
                    <ul>
                      <li>如果在一棵平衡的二叉排序树中插入一个新结点,造成了不平衡。此时必须调整树的结构,使之平衡化</li>
                      <li>每插入一个新结点时, AVL 树中相关结点的平衡状态会发生改变。因此,在插入一个新结点后,需要从插入位置沿通向根的路径回溯,检查各结点的平衡因子</li>
                      <li>如果在某一结点发现不平衡,停止回溯。从发生不平衡的结点起,沿刚才回溯的路径取直接下两层的结点</li>
                      <li>如果这三个结点处于一条直线上,则采用单旋转进行平衡化。单旋转可按其方向分为左单旋转和右单旋转 , 其中一个是另一个的镜像,其方向与不平衡的形状相关</li>
                      <li>如果这三个结点处于一条折线上,则采用双旋转进行平衡化。</li>
                    </ul>
                    <p><strong>右单旋转(RotateRight) : LL 型</strong></p>
                    <ul>
                      <li>在结点 A 的左子女的左子树 D 上插入新结点使其高度增 1 导致结点 A 的平衡因子增到 -2 ,造成不平衡</li>
                      <li>为使树恢复平衡,从 A 沿插入路径连续取 3个结点 A 、 B 和 D ,以结点 B 为旋转轴,将结点 A 顺时针旋转</li>
                    </ul>
                    <figure class="highlight c">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre>
                          </td>
                          <td class="code">
                            <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BSTree &amp;p)</span> </span>&#123;</div><div class="line"><span class="comment">// 对以 *p 为根的二叉排序树作右旋处理</span></div><div class="line"><span class="comment">// 处理之后 p 指向新的树根结点,</span></div><div class="line"><span class="comment">// 即旋转处理之前的左子树的根结点</span></div><div class="line">  BSTree lc;</div><div class="line">  lc = p-&gt;lchild; <span class="comment">//lc 指向 *p 的左子树根结点</span></div><div class="line">  p-&gt;lchild = lc-&gt;rchild;</div><div class="line"><span class="comment">// lc 的右子树挂接为 *p 的左子树</span></div><div class="line">  lc-&gt;rchild = p;</div><div class="line">  p = lc; <span class="comment">//p 指向新的根结点</span></div><div class="line">&#125; <span class="comment">// R_Rotate</span></div></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p><strong>左单旋转 (RotateLeft) : RR 型</strong></p>
                    <ul>
                      <li>在结点 A 的右子女的右子树 E 中插入新结点,该子树高度增 1 导致结点 A 的平衡因子变成 2 ,出现不平衡</li>
                      <li>为使树恢复平衡,从 A 沿插入路径连续取 3个结点 A 、 C 和 E ,以结点 C 为旋转轴,让结点 A 反时针旋转 p</li>
                    </ul>
                    <figure class="highlight c">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre>
                          </td>
                          <td class="code">
                            <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BSTree &amp;p)</span> </span>&#123;</div><div class="line"><span class="comment">// 对以 *p 为根的二叉排序树作左旋处理</span></div><div class="line"><span class="comment">// 处理之后 p 指向新的树根结点</span></div><div class="line"><span class="comment">// 即旋转处理之前的右子树的根结点</span></div><div class="line">  BSTree rc;</div><div class="line">  rc = p-&gt;rchild; <span class="comment">//rc 指向 *p 的右子树根结点</span></div><div class="line"><span class="comment">//rc 的左子树挂接为 *p 的右子树</span></div><div class="line">  p-&gt;rchild = rc-&gt;lchild;</div><div class="line">  rc-&gt;lchild = p;</div><div class="line"><span class="comment">//p 指向新的根结点</span></div><div class="line">  p = rc;</div><div class="line">&#125; <span class="comment">//L_Rotate</span></div></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p><strong>先左后右双旋转 (RotationLeftRight)-LR 型</strong></p>
                    <ul>
                      <li>在结点 A 的左子女的右子树中插入新结点,该子树高度增 1 导致结点 A 的平衡因子变为 -2 ,造成不平衡</li>
                      <li>以结点 E 为旋转轴,将结点 B 反时针旋转,以 E 代替原来 B 的位置</li>
                    </ul>
                    <figure class="highlight c">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre>
                          </td>
                          <td class="code">
                            <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LR_Rotate</span> <span class="params">(BSTree &amp;p)</span> </span>&#123;</div><div class="line"><span class="comment">// 对以 *p 为根的二叉排序树做先左后右旋转</span></div><div class="line">  BSTree lc,rc;</div><div class="line"><span class="comment">// 初始化</span></div><div class="line">  rc =p; lc =rc-&gt;lchild;</div><div class="line">  p=lc-&gt;rchild; <span class="comment">// 重新确定根</span></div><div class="line">  lc-&gt;rchild=p-&gt;lchild; <span class="comment">// 为 BF 拉链</span></div><div class="line">  p-&gt;lchild=lc; <span class="comment">// 设置新根的左孩子,为 EB 拉链</span></div><div class="line">  rc-&gt;lchild=p-&gt;rchild; <span class="comment">// 为 AG 拉链</span></div><div class="line">  p-&gt;rchild=rc; <span class="comment">// 为 EA 拉链</span></div><div class="line">&#125; <span class="comment">// LR_Rotate</span></div></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p><strong>先右后左双旋转 (RotationRightLeft)-RL 型</strong></p>
                    <ul>
                      <li>在结点 A 的右子女的左子树中插入新结点,该子树高度增 1 。结点 A 的平衡因子变为 2 ,发生了不平衡</li>
                      <li>首先以结点 D 为旋转轴,将结点 C 顺时针旋转,以 D 代替原来 C 的位置</li>
                    </ul>
                    <figure class="highlight c">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre>
                          </td>
                          <td class="code">
                            <pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RL_Rotate</span> <span class="params">(BSTree &amp;p)</span> </span>&#123;</div><div class="line"><span class="comment">// 对以 *p 为根的二叉排序树做先右后左旋转</span></div><div class="line">  BSTree lc,rc;</div><div class="line"><span class="comment">// 初始化</span></div><div class="line">  lc =p; rc =lc-&gt;rchild;</div><div class="line">  p=rc-&gt;lchild;</div><div class="line">  rc-&gt;lchild=p-&gt;rchild;</div><div class="line">  p-&gt;rchild=rc;</div><div class="line">  lc-&gt;rchild=p-&gt;lchild;</div><div class="line">  p-&gt;lchild=lc;</div><div class="line">&#125; <span class="comment">// RL_Rotate</span></div></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p><strong>AVL 树的插入</strong></p>
                    <ul>
                      <li>AVL 树的插入算法是从一棵空树开始,通过输入一系列关键字,逐步建立 AVL 树</li>
                      <li>在向一棵本来是平衡的 AVL 树中插入一个新结点时,需从插入结点沿通向根的路径向上回溯,如果某个结点的平衡因子的绝对值 |bf| &gt; 1 ,那么需从这个结点出发,使用平衡旋转方法进行平衡化处理</li>
                    </ul>
                    <p>算法实现：</p>
                    <figure class="highlight c">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre>
                          </td>
                          <td class="code">
                            <pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LH -1 <span class="comment">// 左高</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EH 0 <span class="comment">// 等高</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RH 1 <span class="comment">// 右高</span></span></div><div class="line"><span class="function">Status <span class="title">InsertAVL</span><span class="params">(BSTree &amp;T, ElemType e, Boolean &amp;taller)</span> </span>&#123;</div><div class="line"><span class="comment">// 若在平衡的二叉排序树 T 中不存在和 e 有相同关键字的结点,</span></div><div class="line"><span class="comment">// 则插入一个数据元素为 e 的新结点,并返回 1 ,否则返回0 。</span></div><div class="line"><span class="comment">// 若因插入而使二叉排序树失去平衡,则作平衡旋转处理,</span></div><div class="line"><span class="comment">// 布尔变量 taller 反映 T 长高与否</span></div><div class="line">  <span class="keyword">if</span> (!T) &#123; <span class="comment">// 插入新结点,树 " 长高 " ,置 taller 为 TRUE</span></div><div class="line">    T = (BSTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BSTNode));</div><div class="line">    T-&gt;data = e; T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</div><div class="line">    T-&gt;bf = EH; taller = TRUE; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (EQ(e.key, T-&gt;data.key))&#123;</div><div class="line">      taller = <span class="literal">false</span>;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//已经存在记录，不再插入</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (LT(e.key, T-&gt;data.key)) &#123;</div><div class="line"><span class="comment">// 应继续在 *T 的左子树中进行搜索</span></div><div class="line">      <span class="keyword">if</span> (InsertAVL(T-&gt;lchild, e, taller)==<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未插入</span></div><div class="line">      <span class="keyword">if</span> (taller) <span class="comment">// 插入到 *T 的左子树中且左子树 " 长高“</span></div><div class="line">        <span class="keyword">switch</span> (T-&gt;bf) &#123; <span class="comment">// 检查 *T 的平衡度</span></div><div class="line">          <span class="keyword">case</span> LH: <span class="comment">// 原本左子树比右子树高,需作左平衡处理</span></div><div class="line">            LeftBalance(T); taller = FALSE; <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> EH: <span class="comment">// 原本左、右子树等高</span></div><div class="line"><span class="comment">// 现因左子树增高而使树增高</span></div><div class="line">            T-&gt;bf = LH; taller = TRUE; <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> RH: <span class="comment">// 原本右子树比左子树高 S</span></div><div class="line"><span class="comment">// 现左、右子树等高</span></div><div class="line">            T-&gt;bf = EH; taller = FALSE; <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="comment">// switch (T-&gt;bf)</span></div><div class="line">    &#125; <span class="comment">// if</span></div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 应继续在 T↑ 的右子树中进行搜索</span></div><div class="line">      <span class="keyword">if</span> (InsertAVL(T-&gt;rchild, e, taller)==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      <span class="keyword">if</span> (taller) <span class="comment">// 已插入到 *T 的右子树且右子树长高</span></div><div class="line">        <span class="keyword">switch</span> (T-&gt;bf) &#123; <span class="comment">// 检查 *T 的平衡度</span></div><div class="line">          <span class="keyword">case</span> LH: <span class="comment">// 原本左子树比右子树高</span></div><div class="line"><span class="comment">// 现左、右子树等高</span></div><div class="line">            T-&gt;bf = EH; taller = FALSE; <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> EH: <span class="comment">// 原本左、右子树等高</span></div><div class="line"><span class="comment">// 现因右子树增高而使树增高</span></div><div class="line">            T-&gt;bf = RH; taller = TRUE; <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> RH: <span class="comment">// 原本右子树比左子树高</span></div><div class="line"><span class="comment">// 需要作右平衡处理</span></div><div class="line">            RightBalance(T); taller = FALSE; <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="comment">//switch (T-&gt;bf)</span></div><div class="line">    &#125; <span class="comment">//else</span></div><div class="line">  &#125; <span class="comment">// else</span></div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>; </div><div class="line">&#125; <span class="comment">//InsertAVL</span></div><div class="line"></div><div class="line"><span class="comment">//对以指针 T 所指结点为根的二叉树作左平衡旋转处理</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(BSTree &amp;T)</span> </span>&#123;</div><div class="line"><span class="comment">// 本算法结束时,指针 T 指向新的根结点</span></div><div class="line">  BSTree lc,rd;</div><div class="line">  lc = T-&gt;lchild; <span class="comment">// lc 指向 *T 的左子树根结点</span></div><div class="line">  <span class="keyword">switch</span> (lc-&gt;bf) &#123; <span class="comment">// 检查 *T 的左子树的平衡度</span></div><div class="line"><span class="comment">// 并作相应平衡处理</span></div><div class="line">    <span class="keyword">case</span> LH:</div><div class="line"><span class="comment">// 新结点插入在 *T 的左孩子的左子树上,</span></div><div class="line"><span class="comment">// 要作单右旋处理</span></div><div class="line">      T-&gt;bf = lc-&gt;bf = EH;</div><div class="line">      R_Rotate(T); </div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> RH: <span class="comment">// 新结点插入在 *T 的左孩子的右子树上</span></div><div class="line"><span class="comment">// 要作双旋处理</span></div><div class="line">      rd = lc-&gt;rchild; <span class="comment">// rd 指向 *T 的左孩子的右子树根</span></div><div class="line">      <span class="keyword">switch</span> (rd-&gt;bf) &#123; <span class="comment">// 修改 *T 及其左孩子的平衡因子</span></div><div class="line">        <span class="keyword">case</span> LH: T-&gt;bf = RH; lc-&gt;bf = EH; <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> EH: T-&gt;bf = lc-&gt;bf = EH; <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> RH: T-&gt;bf = EH; lc-&gt;bf = LH; <span class="keyword">break</span>;</div><div class="line">      &#125; <span class="comment">//switch (rd-&gt;bf)</span></div><div class="line">      rd-&gt;bf = EH;</div><div class="line"><span class="comment">// 对 *T 的左子树作左旋平衡处理</span></div><div class="line">      L_Rotate(T-&gt;lchild);</div><div class="line">      R_Rotate(T); <span class="comment">// 对 *T 作右旋平衡处理</span></div><div class="line">  &#125; <span class="comment">// switch (lc-&gt;bf)</span></div><div class="line">&#125; <span class="comment">// LeftBalance</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RightBalance</span><span class="params">(BSTree *T)</span></span>&#123;</div><div class="line">    BSTree lc,ld;</div><div class="line">    lc=(*T)-&gt;rchild;</div><div class="line">    <span class="keyword">switch</span>(lc-&gt;bf)&#123;</div><div class="line">    <span class="keyword">case</span> RH:</div><div class="line">        (*T)-&gt;bf=lc-&gt;bf=EH;</div><div class="line">        L_Rotate(T);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> LH:</div><div class="line">        ld=lc-&gt;lchild;</div><div class="line">        <span class="keyword">switch</span>(ld-&gt;bf)&#123;</div><div class="line">        <span class="keyword">case</span> LH:</div><div class="line">            (*T)-&gt;bf=EH;</div><div class="line">            lc-&gt;bf=RH;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> EH:</div><div class="line">            (*T)-&gt;bf=lc-&gt;bf=EH;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> RH:</div><div class="line">            lc-&gt;bf=EH;</div><div class="line">            (*T)-&gt;bf=LH;</div><div class="line">        &#125;</div><div class="line">        ld-&gt;bf=EH;</div><div class="line">        R_Rotate(&amp;((*T)-&gt;rchild));</div><div class="line">        L_Rotate(T);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> EH:</div><div class="line">        (*T)-&gt;bf=RH;</div><div class="line">        lc-&gt;bf=LH;</div><div class="line">        L_Rotate(T);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;<span class="comment">//RightBalance</span></div></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p><strong>AVL树的删除</strong></p>
                    <ul>
                      <li>如果被删结点 x 最多只有一个子女,可做简单删除</li>
                    </ul>
                    <p>– 将结点 x 从树中删去<br>– 因为结点 x 最多有一个子女,可以简单地把 x 的双亲中原来指向 x 的指针改指到这个子女结点<br>– 如果结点 x 没有子女, x 双亲原来指向 x的指针置为 NULL<br>– 将原来以结点 x 为根的子树的高度减 1</p>
                    <ul>
                      <li>如果被删结点 x 有两个子女</li>
                    </ul>
                    <p>– 搜索 x 在中序次序下的直接前驱 y ( 同样可以找直接后继 )<br>– 把结点 y 的内容传送给结点 x ,现在问题转移到删除结点 y 。把结点 y 当作被删结点 x<br>– 因为结点 y 最多有一个子女,可以简单地用 前一页给出的方法进行删除</p>
                    <ul>
                      <li>必须沿结点 x 通向根的路径反向追踪高度的变化对路径上各个结点的影响</li>
                      <li>用一个布尔变量 shorter 来指明子树高度是否被缩短</li>
                    </ul>
                    <p>– 布尔变量 shorter 的值初始化为 True</p>
                    <ul>
                      <li>对于从 x 的双亲到根的路径上的各个结点p ,在 shorter 保持为 True 时执行下面操作;如果 shorter 变成 False ,算法终止</li>
                    </ul>
                    <p>– 在每个结点上要做的操作取决于 shorter 的值<br>和结点的 bf ,有时还要依赖子女的 bf</p>
                    <p>算法实现：</p>
                    <figure class="highlight c">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre>
                          </td>
                          <td class="code">
                            <pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteAVL</span><span class="params">(BSTree *t, ElemType key, <span class="keyword">bool</span>&amp; shorter)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>((*t)== <span class="literal">NULL</span>)&#123;                      </div><div class="line">        shorter=<span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                   </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(EQ(key, (*t)-&gt;data))&#123;        </div><div class="line">        BSTNode* q = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">if</span>((*t)-&gt;lchild == <span class="literal">NULL</span>)&#123;           </div><div class="line">            q = *t;</div><div class="line">            (*t) = (*t)-&gt;rchild;</div><div class="line">            <span class="keyword">delete</span> q;</div><div class="line">            shorter = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((*t)-&gt;rchild == <span class="literal">NULL</span>)&#123;      </div><div class="line">            q = (*t);</div><div class="line">            (*t) = (*t)-&gt;lchild;</div><div class="line">            <span class="keyword">delete</span> q;</div><div class="line">            shorter = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;                            </div><div class="line">            q = (*t)-&gt;lchild;</div><div class="line">            <span class="keyword">while</span>(q-&gt;rchild)</div><div class="line">                q = q-&gt;rchild;</div><div class="line">            (*t)-&gt;data = q-&gt;data;</div><div class="line">            deleteAVL(&amp;((*t)-&gt;lchild), q-&gt;data, shorter);   </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LT(key, (*t)-&gt;data))&#123;        </div><div class="line">        <span class="keyword">if</span>(!deleteAVL(&amp;((*t)-&gt;lchild), key, shorter))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(shorter)&#123;</div><div class="line">            <span class="keyword">switch</span>((*t)-&gt;bf)&#123;</div><div class="line">                <span class="keyword">case</span> LH:</div><div class="line">                    (*t)-&gt;bf = EH;</div><div class="line">                    shorter = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> EH:</div><div class="line">                    (*t)-&gt;bf = RH;</div><div class="line">                    shorter = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> RH:</div><div class="line">                    RightBalance(t);    </div><div class="line">                    <span class="keyword">if</span>((*t)-&gt;rchild-&gt;bf == EH)</div><div class="line">                        shorter = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        shorter = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;                                </div><div class="line">        <span class="keyword">if</span>(!deleteAVL(&amp;((*t)-&gt;rchild), key, shorter))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(shorter)&#123;</div><div class="line">            <span class="keyword">switch</span>((*t)-&gt;bf)&#123;</div><div class="line">                <span class="keyword">case</span> LH:</div><div class="line">                    LeftBalance(t);    </div><div class="line">                    <span class="keyword">if</span>((*t)-&gt;lchild-&gt;bf == EH)</div><div class="line">                        shorter = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        shorter = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> EH:</div><div class="line">                    (*t)-&gt;bf = LH;</div><div class="line">                    shorter = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> RH:</div><div class="line">                    (*t)-&gt;bf = EH;</div><div class="line">                    shorter = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p><strong>AVL 上的查找</strong></p>
                    <p>AVL上进行查找的时间复杂度为O(logn) .</p>
                    <h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3>
                    <p>一棵m阶B树，或者是空树，或者是满足下面性质的一棵树：</p>
                    <ul>
                      <li>每个节点至多有m棵子树</li>
                      <li>节点要么是根节点，或者是叶子节点，或者至少有两棵子树</li>
                      <li>除根节点外，所有非终节点至少有m/2(上取整)棵子树</li>
                      <li>所有非终端节点应包含如下信息：
                        <ul>
                          <li>$(n, A_0, K_1, A_1, K_2, A_2, …, K_n, A_n)$</li>
                          <li>其中，$K_i$是关键字，且$K<em>i &lt; K</em>{i+1}, A<em>i$为指向孩子节点的指针，且$A</em>{i-1}$所指向的子树中的所有节点的关键字均小于$K_i,A_i$所指向子树中的所有节点的关键字均大于$K_i$，$n$是节点中关键字的个数，$n+1$为子树的棵树。</li>
                        </ul>
                      </li>
                      <li>所有叶子节点都在树的同一层上，且不带信息。
                        <ul>
                          <li>叶子节点为外部节点，查找失败时候的节点，实际上不存在。</li>
                        </ul>
                      </li>
                    </ul>
                    <p><strong>m阶B树定义</strong></p>
                    <figure class="highlight c">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre>
                          </td>
                          <td class="code">
                            <pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> m 3</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BTNode &#123;</div><div class="line">  <span class="keyword">int</span> keynum; <span class="comment">// 结点中关键字个数,即结点大小</span></div><div class="line">  <span class="keyword">struct</span> BTNode *parent; <span class="comment">// 指向父结点的指针</span></div><div class="line">  KeyType key[m+<span class="number">1</span>]; <span class="comment">// 关键字, 0 号单元不用</span></div><div class="line">  Record *recptr[m+<span class="number">1</span>]; <span class="comment">// 记录指针向量,0 号单元不用</span></div><div class="line">  <span class="keyword">struct</span> BTNode *ptr[m+<span class="number">1</span>]; <span class="comment">// 子树指针向量</span></div><div class="line">&#125; BTNode, *BTree; <span class="comment">//B 树结点和 B 树的类型</span></div></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p><strong>B 树的查找:类似二叉排序树</strong></p>
                    <ul>
                      <li>(1) 从树的根结点 T 开始,在 T 所指向的结点的关键字向量 key[1…keynum] 中查找给定值 K( 用 s 顺序查找或折半查找 ) :</li>
                      <li>若 key[i]=K(1≤i≤keynum) ,则查找成功,返回结点及关键字位置;否则,转 (2) ;</li>
                      <li>(2) 将 K 与向量 key[1…keynum] 中的各个分量的值进行比较,以选定查找的子树:</li>
                    </ul>
                    <p>​ – 若 K &lt; key[1] : T=T-&gt;ptr[0]<br>​ – 若 key[i] &lt; K&lt; key [i+1] (i=1, 2, …keynum-1) : T=T-&gt;ptr[i]<br>​ – 若 K&gt;key[keynum] : T=T-&gt;ptr[keynum]</p>
                    <ul>
                      <li>转 (1) ,直到 T 是叶子结点且未找到相等的关键字,则查找失败• 在 B+ 树上插入、删除的过程基本上和 B 树类似</li>
                    </ul>
                    <figure class="highlight c">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre>
                          </td>
                          <td class="code">
                            <pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  BTNode *pt; <span class="comment">// 指向找到的结点</span></div><div class="line">  <span class="keyword">int</span> i; <span class="comment">// 在结点中的关键字序号</span></div><div class="line">  <span class="keyword">int</span> tag;</div><div class="line"><span class="comment">//1 :查找成功, 0 :查找失败</span></div><div class="line">&#125; Result;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(BTree p, KeyType K)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; p-&gt;keynum &amp;&amp; p-&gt;key[i+<span class="number">1</span>] &lt;= K; i++);</div><div class="line">  <span class="keyword">return</span> i; <span class="comment">// p-&gt;key[i] &lt;= K &lt; p-&gt;key[i+1]</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//在 m 阶 B 树 T 上查找关键字 K ,返回结果 (pt,i,tag)</span></div><div class="line"><span class="function">Result <span class="title">SearchBTree</span><span class="params">(BTree T, KeyType K)</span> </span>&#123;</div><div class="line">  BTree p, q; <span class="keyword">int</span> found, i, j=<span class="number">0</span>; Result R;</div><div class="line"><span class="comment">// 初始化, p 指向待查结点, q 指向 p 的双亲</span></div><div class="line">  p = T; q = <span class="literal">NULL</span>; found = FALSE; i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (p &amp;&amp; !found) &#123;</div><div class="line">    i = Search(p, K); <span class="comment">// 在 p-&gt;key[1..keynum] 中查找 i ,</span></div><div class="line"><span class="comment">// 使得 p-&gt;key[i]&lt;=K&lt;p-&gt;key[i+1]</span></div><div class="line">    <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; p-&gt;key[i]==K)</div><div class="line">      found = TRUE; <span class="comment">// 找到待查关键字</span></div><div class="line">    <span class="keyword">else</span> &#123; q = p; p = p-&gt;ptr[i]; &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (found) &#123; <span class="comment">// 查找成功: pt 所指结点中第 i 个关键字等于 K</span></div><div class="line">    R.pt = p; R.i = i; R.tag = <span class="number">1</span>; &#125;</div><div class="line">  <span class="keyword">else</span> &#123; <span class="comment">// 关键字 k 应插入在 pt 所指结点中的第 i 和第 i+1 个关键字之间</span></div><div class="line">    R.pt = q; R.i = i; R.tag = <span class="number">0</span>; &#125;</div><div class="line">  <span class="keyword">return</span> R; <span class="comment">// 返回结果信息 : K 的位置 ( 或插入位置 )</span></div><div class="line">&#125; <span class="comment">// SearchBTree</span></div></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <ul>
                      <li>在 B 树上的查找有两种基本操作:</li>
                    </ul>
                    <p>​ – 在 B 树上查找结点:在磁盘上进行<br>​ – 在结点中查找关键字:将结点信息读入内存后再查找</p>
                    <ul>
                      <li>因此,磁盘上的查找次数 ( 即:待查找的记录关键字在 B 树上的层次数 ) 是决定 B 树查找效率的首要因素.</li>
                    </ul>
                    <p><strong>B树的插入</strong></p>
                    <ul>
                      <li>B 树的生成是从空树起,逐个插入关键字</li>
                      <li>插入时不是每插入一个关键字就添加一个叶子结点,而是首先在最低层的某个叶子结点中添加一个关键字,然后</li>
                      <li>若关键字的数目达到 m ,则分裂成两个结点,并将中间关键字插入到 p 的父结点,这时,父结点也可能不满足 m 阶 B 树的要求( 分枝数大于 m) ,则必须对父结点进行分裂,一直进行下去,直到没有父结点或分裂后的父结点满足 m 阶 B 树的要求</li>
                      <li>当根结点分裂时,因没有父结点,则建立一个新的根, B 树增高一层</li>
                    </ul>
                    <figure class="highlight c">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre>
                          </td>
                          <td class="code">
                            <pre><div class="line"><span class="function">BTNode *<span class="title">split</span><span class="params">(BTNode *p)</span></span></div><div class="line"><span class="comment">// 结点 p 中包含 m 个关键字,从中分裂出一个新的结点</span></div><div class="line">&#123;</div><div class="line">  BTNode *q ; <span class="keyword">int</span> k, mid, j ;</div><div class="line">  q=(BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>( BTNode));</div><div class="line">  mid=(m+<span class="number">1</span>)/<span class="number">2</span>; </div><div class="line">  q-&gt;ptr[<span class="number">0</span>]=p-&gt;ptr[mid];</div><div class="line">  <span class="keyword">for</span> (j=<span class="number">1</span>,k=mid+<span class="number">1</span>; k&lt;=m; k++) &#123;</div><div class="line">    q-&gt;key[j]=p-&gt;key[k] ;</div><div class="line">    q-&gt;ptr[j++]=p-&gt;ptr[k] ;</div><div class="line">  &#125; <span class="comment">// 将 p 的后半部分移到新结点 q 中</span></div><div class="line">  q-&gt;keynum=m-mid ; p-&gt;keynum=mid<span class="number">-1</span> ;</div><div class="line">  <span class="keyword">return</span>(q) ;</div><div class="line">&#125;</div></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p><strong>B树的删除</strong></p>
                    <ul>
                      <li>在 B 树上删除一个关键字 K ,首先找到关键字所在的结点 N ,然后在 N 中进行关键字 K 的删除操作。</li>
                    </ul>
                    <h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3>
                    <ul>
                      <li>m 阶 B+ 树, B 树的一种变体</li>
                      <li>一棵 m 阶 B+ 树与 m 阶 B 树的主要差异是: 若一个结点有 n 棵子树,则必含有 n 个关键字</li>
                      <li>所有叶子结点中包含了全部记录的关键字信息以及这些关键字记录的指针,而且叶子结点按关键字的大小从小到大顺序链接,构成一个有序链表</li>
                      <li>在 B+ 树中,所有的非叶子结点可以看成是索引,结点中只含有其子树的根结点中的最大 ( 或最小 ) 关键字</li>
                    </ul>
                    <p><strong>B+树定义</strong></p>
                    <figure class="highlight c">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre>
                          </td>
                          <td class="code">
                            <pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;branch, left&#125; NodeType;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> BPNode &#123;</div><div class="line">  NodeTag tag; <span class="comment">// 结点标志</span></div><div class="line">  <span class="keyword">int</span> keynum; <span class="comment">// 结点中关键字的个数</span></div><div class="line">  <span class="keyword">struct</span> BTNode *parent; <span class="comment">// 指向父结点的指针</span></div><div class="line">  KeyType key[M+<span class="number">1</span>]; <span class="comment">// 关键字向量 ,key[0] 未用</span></div><div class="line">  <span class="keyword">union</span> pointer</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">struct</span> BTNode *ptr[M+<span class="number">1</span>]; <span class="comment">// 子树指针向量</span></div><div class="line">    RecType *recptr[M+<span class="number">1</span>]; <span class="comment">//recptr[0] 未用</span></div><div class="line">  &#125;ptrType ; <span class="comment">// 用联合体定义子树指针和记录指针</span></div><div class="line">&#125;BPNode;</div></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p><strong>B+树的查找</strong></p>
                    <ul>
                      <li>与 B 树相比,对 B+ 树不仅可以从根结点开始按关键字随机查找,而且可以从最小关键字起,按叶子结点的链接顺序进行顺序查找。</li>
                      <li>在 B+ 树上进行随机查找的过程基本上和 B树类似。</li>
                      <li>在 B+ 树上进行随机查找时,若非叶子结点的关键字等于给定的 K 值,并不终止,而是继续向下直到叶子结点 ( 只有叶子结点才存储记录 ) , 即无论查找成功与否,都走了一条从根结点到叶子结点的路径。</li>
                    </ul>
                    <p><strong>B+ 树的插入、删除</strong></p>
                    <ul>
                      <li>在 B+ 树上插入、删除的过程基本上和 B 树类似。</li>
                    </ul>

                  </div>










                  <footer class="post-footer">

                    <div class="post-tags">

                      <a href="/tags/Data-Structures/" rel="tag"># Data-Structures</a>

                    </div>







                    <div class="post-nav">
                      <div class="post-nav-next post-nav-item">

                        <a href="/2017/08/05/Find-and-Search-Part1/" rel="next" title="查找和搜索-Part1">
                <i class="fa fa-chevron-left"></i> 查找和搜索-Part1
              </a>

                      </div>

                      <span class="post-nav-divider"></span>

                      <div class="post-nav-prev post-nav-item">

                        <a href="/2017/08/07/Find-and-Search-Part3/" rel="prev" title="查找和搜索-Part3">
                查找和搜索-Part3 <i class="fa fa-chevron-right"></i>
              </a>

                      </div>
                    </div>




                  </footer>
                </div>



              </article>



              <div class="post-spread">

              </div>
            </div>


          </div>






          <div class="comments" id="comments">

            <div id="gitment-container"></div>

          </div>





        </div>



        <div class="sidebar-toggle">
          <div class="sidebar-toggle-line-wrap">
            <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
            <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
            <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
          </div>
        </div>

        <aside id="sidebar" class="sidebar">

          <div class="sidebar-inner">




            <ul class="sidebar-nav motion-element">
              <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
                文章目录
              </li>
              <li class="sidebar-nav-overview" data-target="site-overview-wrap">
                站点概览
              </li>
            </ul>


            <section class="site-overview-wrap sidebar-panel">
              <div class="site-overview">
                <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">

                  <p class="site-author-name" itemprop="name">Flynn</p>
                  <p class="site-description motion-element" itemprop="description">高山仰止，景行行止</p>
                </div>

                <nav class="site-state motion-element">


                  <div class="site-state-item site-state-posts">

                    <a href="/archives/">
              
                  <span class="site-state-item-count">119</span>
                  <span class="site-state-item-name">日志</span>
                </a>
                  </div>





                  <div class="site-state-item site-state-categories">
                    <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">分类</span>
                </a>
                  </div>





                  <div class="site-state-item site-state-tags">
                    <a href="/tags/index.html">
                  <span class="site-state-item-count">69</span>
                  <span class="site-state-item-name">标签</span>
                </a>
                  </div>


                </nav>


                <div class="feed-link motion-element">
                  <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
                </div>


                <div class="links-of-author motion-element">

                </div>









              </div>
            </section>


            <!--noindex-->
            <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
              <div class="post-toc">






                <div class="post-toc-content">
                  <ol class="nav">
                    <li class="nav-item nav-level-3"><a class="nav-link" href="#AVL-树"><span class="nav-number">1.</span> <span class="nav-text">AVL 树</span></a></li>
                    <li class="nav-item nav-level-3"><a class="nav-link" href="#B树"><span class="nav-number">2.</span> <span class="nav-text">B树</span></a></li>
                    <li class="nav-item nav-level-3"><a class="nav-link" href="#B-树"><span class="nav-number">3.</span> <span class="nav-text">B+树</span></a></li>
                  </ol>
                </div>


              </div>
            </section>
            <!--/noindex-->




          </div>
        </aside>



      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
          <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
          <span class="author" itemprop="copyrightHolder">Flynn</span>


        </div>


        <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



        <span class="post-meta-divider">|</span>



        <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>













      </div>
    </footer>


    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>

    </div>




  </div>



  <script type="text/javascript">
    if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
      window.Promise = null;
    }
  </script>
























  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>




  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>




  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>




  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>




  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>






  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>







  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
  <script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>






  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>

































  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
























</body>

</html>