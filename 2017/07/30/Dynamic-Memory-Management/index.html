<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>动态存储管理 | Cry On My Shoulder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Data-Structures" />
  
  
  
  
  <meta name="description" content="存储空间的分配和管理
问题的来源: ( 数据 ) 结构中的每一个数据元素都对应一定的存储空间,数据元素的访问都是通过对应的存储单元来进行的 – 操作系统、编译程序 ( 例如 JVM) 、用户程序
问题的解决策略:采用动态存储管理思想
存储空间的分配和管理策略的选择与用户的需求有关:
用户存储请求的分配量的大小分布
用户存储分配请求和释放请求的频率
分配效率 对系统的重要性">
<meta property="og:type" content="article">
<meta property="og:title" content="动态存储管理">
<meta property="og:url" content="http://ucasfl.me/2017/07/30/Dynamic-Memory-Management/index.html">
<meta property="og:site_name" content="Cry On My Shoulder">
<meta property="og:description" content="存储空间的分配和管理
问题的来源: ( 数据 ) 结构中的每一个数据元素都对应一定的存储空间,数据元素的访问都是通过对应的存储单元来进行的 – 操作系统、编译程序 ( 例如 JVM) 、用户程序
问题的解决策略:采用动态存储管理思想
存储空间的分配和管理策略的选择与用户的需求有关:
用户存储请求的分配量的大小分布
用户存储分配请求和释放请求的频率
分配效率 对系统的重要性">
<meta property="og:updated_time" content="2017-09-02T04:38:29.019Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="动态存储管理">
<meta name="twitter:description" content="存储空间的分配和管理
问题的来源: ( 数据 ) 结构中的每一个数据元素都对应一定的存储空间,数据元素的访问都是通过对应的存储单元来进行的 – 操作系统、编译程序 ( 例如 JVM) 、用户程序
问题的解决策略:采用动态存储管理思想
存储空间的分配和管理策略的选择与用户的需求有关:
用户存储请求的分配量的大小分布
用户存储分配请求和释放请求的频率
分配效率 对系统的重要性">
  
    <link rel="alternate" href="/atom.xml" title="Cry On My Shoulder" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  
  <div class="site-header-image">
    <img id="originBg" width="100%" alt="Hike News" src="">
  </div>

  <div id="header-blur" class="site-header-image blur" style="position: absolute; top:0; height: 207px; min-height: 207px; min-width: 100%;">
    <img id="blurBg" width="100%" style="top: 96%" alt="Hike News" src="">
  </div>

  <script>
        var imgUrls = "css/images/2.jpeg,https://source.unsplash.com/collection/954550/1920x1080,https://source.unsplash.com/collection/954550/1920x1081".split(",");
        var random = Math.floor((Math.random() * imgUrls.length ));
        if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
          document.getElementById("originBg").src=imgUrls[random];
          document.getElementById("blurBg").src=imgUrls[random];
        } else {
          document.getElementById("originBg").src='/' + imgUrls[random];
          document.getElementById("blurBg").src='/' + imgUrls[random];
        }
    </script>




<header id="allheader" class="site-header" role="banner" 
   style="width: 100%; position: absolute; top:0; background: rgba(255,255,255,.8);"  >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="200px" height="200px" alt="Hike News" src=" /css/images/1.jppg">
              </a>
            
          </h1>
          
          
            <div class="site-description">高山仰止，景行行止</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">About</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Dynamic-Memory-Management" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      动态存储管理
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/07/30/Dynamic-Memory-Management/" class="article-date">
	  <time datetime="2017-07-30T11:57:40.000Z" itemprop="datePublished">July 30, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Data-Structures/">Data-Structures</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="存储空间的分配和管理"><a href="#存储空间的分配和管理" class="headerlink" title="存储空间的分配和管理"></a>存储空间的分配和管理</h3><ul>
<li>问题的来源: ( 数据 ) 结构中的每一个数据元素都对应一定的存储空间,数据元素的访问都是通过对应的存储单元来进行的 – 操作系统、编译程序 ( 例如 JVM) 、用户程序</li>
<li>问题的解决策略:采用动态存储管理思想</li>
<li>存储空间的分配和管理策略的选择与用户的需求有关:<ul>
<li>用户存储请求的分配量的大小分布</li>
<li>用户存储分配请求和释放请求的频率</li>
<li>分配效率 对系统的重要性</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="动态存储管理-堆的管理"><a href="#动态存储管理-堆的管理" class="headerlink" title="动态存储管理 - 堆的管理"></a>动态存储管理 - 堆的管理</h3><ul>
<li>堆(heap)：操作系统在内存中划出一块地址连续的大区域<ul>
<li>占用块:已分配给用户使用的一块地址连续的内存区域;</li>
<li>空闲块:未曾分配的地址连续的内存区域</li>
</ul>
</li>
<li>堆的管理要解决的问题:如何根据用户的存储 / 内存分配请求分配内存空间?如何回收被释放的或不再使用的 ) 内存空间?</li>
<li>堆的使用:利用程序设计语言提供的内存动态分配函数<br>– C : malloc() , calloc() , realloc , free() 函数<br>– C++ : new , delete 函数等</li>
</ul>
<h3 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h3><p>方式1： 从高地址空闲块中进行分配,直到分配无法进行时,才回收所有用户不再使用的空闲块,重新组织一个大的空闲块来再分配。</p>
<p>方式2：用户程序一旦运行结束,便将它所占的内存区释放成为空闲块,同时,每当新用户请求分配内存时,需查找整个内存区中所有空闲块,并从中找出一个合适的空闲块分配之。</p>
<h3 id="可利用空间表"><a href="#可利用空间表" class="headerlink" title="可利用空间表"></a>可利用空间表</h3><ul>
<li>可利用空间表 / 存储池:包含所有可分配的空闲块</li>
</ul>
<p>​       – 当用户请求分配时,系统从可利用空间表中删除一个结点分配之<br>​       – 当用户释放其所占内存时,系统即回收并将它插入到可利用空间表中</p>
<ul>
<li>可利用空间表的组织方式</li>
</ul>
<p>​       – 目录表<br>​       – 链表方式</p>
<h3 id="链式可利用空间表的分配方式"><a href="#链式可利用空间表的分配方式" class="headerlink" title="链式可利用空间表的分配方式"></a>链式可利用空间表的分配方式</h3><ul>
<li>当可利用空间表以链表方式组织时,每个空闲块就是链表中的一个结点<br>– 分配时:从链表中找到一个合适的结点加以分配,然后将该结点删除之;<br>– 回收时:将空闲块插入到链表中。</li>
<li>具体的分配和释放的策略取决于结点 ( 空闲块 ) 的结构<br>– 空闲块的大小相同<br>– 空闲块的大小只有几种规格<br>– 空闲块的大小不固定</li>
</ul>
<h4 id="分配方式1：空闲块的大小相同"><a href="#分配方式1：空闲块的大小相同" class="headerlink" title="分配方式1：空闲块的大小相同"></a>分配方式1：空闲块的大小相同</h4><p>– 将进行动态存储分配的整个内存区域( 堆 ) 按所需大小分割成若干大小相同的块,然后用指针链接成一个可利用空间表。<br>– 分配时:从表的首结点分配,然后删除该结点<br>– 回收时:将释放的空闲块插入表头<br>– 存在的问题:空间利用率不高<br>当请求分配的块空间大小比最大规格的结点还大时,分配不能进行。而实际上内存空间却可能存在比所需大小还要大的的连续空间。</p>
<h4 id="分配方式2：空闲块大小只有几种规格"><a href="#分配方式2：空闲块大小只有几种规格" class="headerlink" title="分配方式2：空闲块大小只有几种规格"></a>分配方式2：空闲块大小只有几种规格</h4><p>– 根据统计分析得到的概率分布,事先对动态分配的堆建立若干个可利用空间链表,同一链表中的结点 ( 块 ) 大小都相同。<br>– 分配时:根据请求的大小,将最接近该大小的某个链表的首结点分配给用户。若剩余部分正好是另一种规格大小,则将剩余部分插入到另一种规格的链表中,然后删除该结点<br>– 回收时:只要将所释放的空闲块插入到相应大小的表头<br>– 存在的问题:同前</p>
<h4 id="分配方式3：请求分配的块大小不确定"><a href="#分配方式3：请求分配的块大小不确定" class="headerlink" title="分配方式3：请求分配的块大小不确定"></a>分配方式3：请求分配的块大小不确定</h4><p>– 整个堆空间开始是一个空闲块,链表中只有一个大小为整个堆的结点,随着分配和回收的进行,链表中的结点大小和个数动态变化<br>– 链表结点中,增加一个表示结点大小的域 (size),以保存空闲块的大小<br>– 分配策略:若用户请求分配大小为 n(kB) 的内存,而链表中有若干大小不小于 n 的空闲块时,如何分配 ?</p>
<ul>
<li>首次拟合法 (First fit)</li>
<li>最佳拟合法 (Best fit)</li>
<li>最差拟合法 (Worst fit)</li>
</ul>
<h3 id="首次拟合法-First-fit"><a href="#首次拟合法-First-fit" class="headerlink" title="首次拟合法 (First fit)"></a>首次拟合法 (First fit)</h3><ul>
<li>分配时:从表头指针开始查找可利用空间表,将找到的第一个不小于 n 的空闲块的部分 ( 所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点</li>
<li>回收时:将释放的空闲块插在链表的表头</li>
<li>特点:分配时随机的;回收时仅需插入到表头</li>
</ul>
<h3 id="最佳拟合法-Best-fit"><a href="#最佳拟合法-Best-fit" class="headerlink" title="最佳拟合法 (Best fit)"></a>最佳拟合法 (Best fit)</h3><ul>
<li>分配时:扫描整个可利用空间链表,找到一个大小满足要求且最接近 n 的空闲块,将其中的一部分 ( 即所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点</li>
<li>回收时:只要将释放的空闲块插入到可利用空间链表的合适位置</li>
<li>为了使分配时不需要扫描整个可利用空间链表,链表组织 ( 包括块回收时 ) 成按从小到大排序 ( 升序 )</li>
<li>优点:适用于请求分配的内存块大小范围较广的系统</li>
<li>缺点:系统容易产生无法分配的内存碎片;无论分配与回收,都需要查找空闲链表,最费时</li>
</ul>
<h3 id="最差拟合法-Worst-fit"><a href="#最差拟合法-Worst-fit" class="headerlink" title="最差拟合法 (Worst fit)"></a>最差拟合法 (Worst fit)</h3><ul>
<li>分配时:扫描整个可利用空间链表,找到一个大小最大的空闲块,将其中的一部分 ( 所需要大小 ) 分配给用户,剩下部分仍然是一个空闲块结点</li>
<li>回收时:只要将释放的空闲块插入到链表的合适位置</li>
<li>为了使分配时不需要扫描整个可利用空间链表,链表组织 ( 块回收时 ) 成按从大到小排序 (降序 )</li>
<li>特点:适用于请求分配的内存块的大小范围较窄的系统;分配无需查找,回收需要查找适当的位置</li>
</ul>
<h3 id="边界标识法-Boundary-Tag-Method"><a href="#边界标识法-Boundary-Tag-Method" class="headerlink" title="边界标识法 (Boundary Tag Method)"></a>边界标识法 (Boundary Tag Method)</h3><ul>
<li>操作系统中常用的动态存储管理方法</li>
<li>将所有的空闲块链接成一个双重循环链表</li>
<li>每个内存区域的头部和底部两个边界上分别设置标识,以标识该区域为占用块或空闲块</li>
<li>在回收块时易于判别在物理位置上与其相邻的内存区域是否为空闲块,以便于将所有地址连续的空闲存储区合并成一个尽可能大的空闲块</li>
</ul>
<p>可利用空间表的节点结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> word &#123;</div><div class="line"><span class="keyword">union</span> &#123;</div><div class="line"><span class="comment">// 头部域,指向前驱结点</span></div><div class="line">  <span class="keyword">struct</span> word *llink;</div><div class="line"><span class="comment">// 尾部域,指向本结点的头部</span></div><div class="line">  <span class="keyword">struct</span> word *uplink;</div><div class="line">&#125;;</div><div class="line">  <span class="keyword">int</span> tag; <span class="comment">//0 :空闲; 1 :占用</span></div><div class="line">  <span class="keyword">int</span> size;</div><div class="line"><span class="comment">// 头部域,指向后继结点</span></div><div class="line">  <span class="keyword">struct</span> word *rlink;</div><div class="line"><span class="comment">//OtherType other;</span></div><div class="line">&#125;WORD, head, foot, *Space;</div><div class="line"><span class="comment">// 指向 p 所指结点的底部</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FootLoc(p) (p+p-&gt;size-1)</span></div><div class="line"><span class="function">Space <span class="title">FootLoc</span><span class="params">(Space p)</span> </span>&#123;</div><div class="line">  <span class="keyword">char</span> *q; Space f;</div><div class="line">  q=(<span class="keyword">char</span> *)p;</div><div class="line">  f=(Space)(q+<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*p-&gt;size-<span class="keyword">sizeof</span>(foot));</div><div class="line">  <span class="keyword">return</span> f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分配算法：两个约定"><a href="#分配算法：两个约定" class="headerlink" title="分配算法：两个约定"></a>分配算法：两个约定</h3><h4 id="分配约定"><a href="#分配约定" class="headerlink" title="分配约定"></a>分配约定</h4><ul>
<li>选定适当常量 e ,设待分配空闲块、请求分配空间的大小分别为 m 、 n</li>
<li>当 m-n&lt;=e 时:将整个空闲块分配给用户;</li>
<li>当 m-n&gt;e 时:则只分配请求的大小 n 给用户;</li>
<li>尽量减少空闲块链表中出现小碎片 ( 容量 ≤ e) ,提高分配效率;减少对空闲块链表的维护工作量</li>
<li>为了避免修改指针,约定将高地址部分分配给用户</li>
</ul>
<h4 id="查找约定"><a href="#查找约定" class="headerlink" title="查找约定"></a>查找约定</h4><ul>
<li>每次需要查找空闲块时,从上次刚分配结点的后继结点开始查找空闲块</li>
<li>作用:提高查找空闲块的速度,防止小容量结点聚集</li>
</ul>
<h3 id="分配算法：首次拟合法"><a href="#分配算法：首次拟合法" class="headerlink" title="分配算法：首次拟合法"></a>分配算法：首次拟合法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> e = <span class="number">16</span>; <span class="comment">// 不保留小于等于 e 的剩余量</span></div><div class="line"><span class="comment">// 若有不小于 n 的空闲块,则分配相应的存储块,并返</span></div><div class="line">回其首地址, 否则返回 <span class="function"><span class="literal">NULL</span></span></div><div class="line">Space <span class="title">AllocBoundTag</span><span class="params">(Space pav, <span class="keyword">int</span> n)</span> &#123;</div><div class="line">  Space p;</div><div class="line"><span class="comment">// 查找不小于 n 的空闲块</span></div><div class="line">  <span class="keyword">for</span> (p=pav; p &amp;&amp; p-&gt;size&lt;n &amp;&amp; p-&gt;rlink!=pav; p=p-&gt;rlink);</div><div class="line">  <span class="keyword">if</span> (!p || p-&gt;size&lt;n) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 找不到,返回空指针</span></div><div class="line">  <span class="keyword">else</span> &#123; <span class="comment">// p 指向找到的空闲块</span></div><div class="line">    Space f = FootLoc(p); <span class="comment">// f 指向底部</span></div><div class="line">    pav = p-&gt;rlink;</div><div class="line"><span class="comment">// pav 指向 *p 结点的后继结点</span></div><div class="line">    <span class="keyword">if</span> (p-&gt;size-n &lt;= e) &#123; <span class="comment">// 整块分配,不保留小于等于 e 的剩余量</span></div><div class="line">      <span class="keyword">if</span> (pav==p) pav = <span class="literal">NULL</span>; <span class="comment">// 可利用空间表变为空表</span></div><div class="line">      <span class="keyword">else</span> &#123; <span class="comment">// 在表中删除分配的结点</span></div><div class="line">        pav-&gt;llink = p-&gt;llink; p-&gt;llink-&gt;rlink = pav;</div><div class="line">      &#125;</div><div class="line">      p-&gt;tag = f-&gt;tag = <span class="number">1</span>; <span class="comment">// 修改分配结点的头部和底部标志</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 分配该块的后 n 个字</span></div><div class="line">      f-&gt;tag = <span class="number">1</span>; <span class="comment">// 修改分配块的底部标志</span></div><div class="line">      p-&gt;size -= n; <span class="comment">// 置剩余块大小</span></div><div class="line">      f = FootLoc(p); <span class="comment">// 指向剩余块底部</span></div><div class="line">      f-&gt;tag = <span class="number">0</span>; f-&gt;uplink = p; <span class="comment">// 设置剩余块底部</span></div><div class="line">      p = f+<span class="number">1</span>; <span class="comment">// 指向分配块头部</span></div><div class="line">      p-&gt;tag = <span class="number">1</span>; p-&gt;size = n; <span class="comment">// 设置分配块头部</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回分配块首地址</span></div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">// AllocBoundTag</span></div></pre></td></tr></table></figure>
<h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><ul>
<li>释放块的左、右邻块均为占用块:将被释放块简单地插入到空闲块链表中即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">p-&gt;tag=<span class="number">0</span> ; FootLoc(p)-&gt;uplink=p;</div><div class="line">FootLoc(p)-&gt;tag=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> ( !pav )</div><div class="line">pav=p-&gt;llink=p-&gt;rlink=p; <span class="comment">// 第一个空闲块</span></div><div class="line"><span class="keyword">else</span> &#123;<span class="comment">// 刚释放的空闲结点是插在 pav 之前,并成为 pav</span></div><div class="line">q=pav-&gt;llink; p-&gt;rlink=pav ;</div><div class="line">p-&gt;llink=q ; q-&gt;rlink=pav-&gt;llink=p ;</div><div class="line">pav=p ; <span class="comment">//pav 指向刚释放的空闲结点</span></div><div class="line"><span class="comment">// 成为下次分配最先查询的结点</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="情况2、3"><a href="#情况2、3" class="headerlink" title="情况2、3"></a>情况2、3</h4><ul>
<li>释放块的左邻块空闲而右邻块为占用:和左邻块合并成一个大的空闲块结点,改变左邻块的 size 域及重新设置 ( 合并后 ) 结点的底部</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">n=p-&gt;size;</div><div class="line">s=(p<span class="number">-1</span>)-&gt;uplink; s-&gt;size+=n; <span class="comment">// 设置新空闲块大小</span></div><div class="line">f=FootLoc(p); f-&gt;uplink=s; f-&gt;tag=<span class="number">0</span>; <span class="comment">// 设置新空闲块底部</span></div></pre></td></tr></table></figure>
<ul>
<li>释放块的左邻占用而右邻空闲:和右邻块合并成一个大的空闲块结点,改变右邻块的 size 域及重新设置( 合并后 ) 结点的头部</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">t= FootLoc(p)+<span class="number">1</span>; p-&gt;tag=<span class="number">0</span>; q=t-&gt;llink;</div><div class="line">p-&gt;llink=q; q-&gt;rlink=p ; <span class="comment">// 设置空闲块的前驱</span></div><div class="line">q1=t-&gt;rlink ; p-&gt;rlink=q1 ; q1-&gt;llink=p ;</div><div class="line">p-&gt;size+=t-&gt;size; <span class="comment">// 设置新空闲块大小</span></div><div class="line">FootLoc(t)-&gt;uplink=p ; <span class="comment">// 底部指针指向新结点的头部</span></div></pre></td></tr></table></figure>
<h4 id="情况4"><a href="#情况4" class="headerlink" title="情况4"></a>情况4</h4><ul>
<li>释放块的左、右邻块均为空闲块:和左、右邻块合并成一个大的空闲块结点,改变左邻块的 size 域及重新设置 ( 合并后 ) 结点的底部</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">n=p-&gt;size;</div><div class="line">s=(p<span class="number">-1</span>)-&gt;uplink;<span class="comment">//s 指向左邻块</span></div><div class="line">t= FootLoc(p)+<span class="number">1</span>; <span class="comment">//t 指向右邻块 , p+p-&gt;size</span></div><div class="line">s-&gt;size +=n+t-&gt;size; <span class="comment">// 设置新空闲结点的大小</span></div><div class="line"><span class="comment">// 在空闲链表中,删除右邻空闲块</span></div><div class="line">q=t-&gt;llink; q1=t-&gt;rlink; <span class="comment">// 修改右邻原来的关系</span></div><div class="line">q-&gt;rlink=q1; q1-&gt;llink=q ;</div><div class="line">FootLoc(t)-&gt;uplink=s; <span class="comment">// 新结点底部指针指向其头部</span></div></pre></td></tr></table></figure>
<h3 id="伙伴系统-Buddy-System"><a href="#伙伴系统-Buddy-System" class="headerlink" title="伙伴系统 (Buddy System)"></a>伙伴系统 (Buddy System)</h3><ul>
<li>操作系统中常用的动态存储管理方法</li>
<li>与边界标识法类似,所不同是:无论占用块或空闲块,其大小均为 2 的 k 次幂 ,不是以顺序片段来分配内存</li>
<li>伙伴系统的可利用空间表:<ul>
<li>将所有大小相同的空闲块建于一张子表中,每个子表是一个双重链表,这样的链表可能有 m+1 个</li>
<li>再将这 m+1 个表头指针用向量结构组织成一个表</li>
</ul>
</li>
</ul>
<p>可利用空间表的结构:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M 16</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> WORD_b &#123;</div><div class="line">  WORD_b * llink;<span class="comment">// 前驱结点</span></div><div class="line">  <span class="keyword">int</span> tag;<span class="comment">// 块占用标识</span></div><div class="line">  <span class="keyword">int</span> kval;<span class="comment">// 块的大小,是 2 的幂次</span></div><div class="line">  WORD_b *rlink;<span class="comment">// 后继结点</span></div><div class="line">  OtherType other;</div><div class="line">&#125; WORD_b, head;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> HeadNode &#123;</div><div class="line">  <span class="keyword">int</span> nodesize;</div><div class="line">  WORD_b * first;</div><div class="line">&#125; FreeList[M+<span class="number">1</span>];<span class="comment">// 子表个数为 M+1</span></div></pre></td></tr></table></figure>
<h4 id="伙伴系统的分配算法"><a href="#伙伴系统的分配算法" class="headerlink" title="伙伴系统的分配算法"></a>伙伴系统的分配算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function">WORD_b* <span class="title">AllocBuddy</span> <span class="params">(FreeList avail[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"><span class="comment">// avail[0..m] 为可利用空间表, n 为申请分配量,若有不小于n 的空闲块,则分配相应的存储块,并返回其首地址;否则返回 NULL</span></div><div class="line">  WORD_b *pa, *pre, *suc, *pi;</div><div class="line"><span class="comment">// 查找满足分配要求的子表</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=m &amp;&amp; (!avail[k].first ||avail[k].nodesize&lt;n+<span class="number">1</span>);k++) ;</div><div class="line">  <span class="keyword">if</span> (k&gt;m) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 分配失败</span></div><div class="line">  <span class="keyword">else</span> &#123; <span class="comment">// 进行分配</span></div><div class="line">    pa = avail[k].first; <span class="comment">// 指向可分配子表的第一个结点</span></div><div class="line"><span class="comment">// 分别指向前驱和后继</span></div><div class="line">    pre = pa-&gt;llink; suc = pa-&gt;rlink;</div><div class="line">    <span class="keyword">if</span> (pa==suc)</div><div class="line">      avail[k].first = <span class="literal">NULL</span>; <span class="comment">// 分配后该子表变成空表</span></div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 从子表删去 *pa 结点</span></div><div class="line">      pre-&gt;rlink = suc; suc-&gt;llink = pre;</div><div class="line">      avail[k].first = suc;</div><div class="line">    &#125;</div><div class="line"><span class="comment">// 将剩余块插入相应子表</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; avail[k-i].nodesize&gt;=n+<span class="number">1</span>; ++i) &#123;</div><div class="line">      pi = pa+(<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, (k-i)); pi-&gt;rlink = pi;</div><div class="line">      pi-&gt;llink = pi; pi-&gt;tag = <span class="number">0</span>; pi-&gt;kval = k-i;</div><div class="line">      avail[k-i].first = pi; </div><div class="line">    &#125;</div><div class="line">    pa-&gt;tag = <span class="number">1</span>; pa-&gt;kval = k-(--i);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> pa;</div><div class="line">&#125; <span class="comment">// AllocBuddy</span></div></pre></td></tr></table></figure>
<h4 id="回收算法-1"><a href="#回收算法-1" class="headerlink" title="回收算法"></a>回收算法</h4><ul>
<li>释放占用块时,需要将该新的空闲块插入到可利用空闲表中</li>
<li>考虑合并成大块的问题:只有 “ 互为伙伴 ” 的两个子块均空闲时才合并;即使有两个相邻且大小相同的空闲块,如果不是 “ 互为伙伴 ” ( 从同一个大块中分裂出来的 ) 也不合并。</li>
</ul>
<p>设要回收的空闲块的首地址是 p ,其大小为 2^k :<br> (1) 判断其 “ 互为伙伴 ” 的块是否空闲:</p>
<ul>
<li>若不空闲,仅将要回收的空闲块直接插入到相应的子表中;否则转 (2) ;</li>
</ul>
<p>(2) 按以下步骤进行空闲块的合并:</p>
<ul>
<li>在相应子表中找到其伙伴并删除之;</li>
<li>合并两个空闲块;</li>
</ul>
<p>(3) 重复 (2) ,直到合并后的空闲块的伙伴不是空闲块为止</p>
<ul>
<li>特点:算法简单;速度快;但容易产生碎片</li>
</ul>
<h3 id="无用单元收集"><a href="#无用单元收集" class="headerlink" title="无用单元收集"></a>无用单元收集</h3><ul>
<li>无用单元:用户不再使用而系统没有回收的变量和结构</li>
<li>产生原因:程序 Bug</li>
</ul>
<p>– p=malloc(size); … … p=NULL; // 未回收的空间<br>– p=malloc(size); … … q=p;free(p);// 悬挂访问</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Data-Structures/">Data-Structures</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structures/">Data-Structures</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/08/05/Find-and-Search-Part1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          查找和搜索-Part1
        
      </div>
    </a>
  
  
    <a href="/2017/07/28/Stack-Over-Flow-in-Function/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">局部变量的栈溢出</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#存储空间的分配和管理"><span class="nav-number">1.</span> <span class="nav-text">存储空间的分配和管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态存储管理-堆的管理"><span class="nav-number">2.</span> <span class="nav-text">动态存储管理 - 堆的管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分配方式"><span class="nav-number">3.</span> <span class="nav-text">内存分配方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可利用空间表"><span class="nav-number">4.</span> <span class="nav-text">可利用空间表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链式可利用空间表的分配方式"><span class="nav-number">5.</span> <span class="nav-text">链式可利用空间表的分配方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分配方式1：空闲块的大小相同"><span class="nav-number">5.1.</span> <span class="nav-text">分配方式1：空闲块的大小相同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分配方式2：空闲块大小只有几种规格"><span class="nav-number">5.2.</span> <span class="nav-text">分配方式2：空闲块大小只有几种规格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分配方式3：请求分配的块大小不确定"><span class="nav-number">5.3.</span> <span class="nav-text">分配方式3：请求分配的块大小不确定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#首次拟合法-First-fit"><span class="nav-number">6.</span> <span class="nav-text">首次拟合法 (First fit)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最佳拟合法-Best-fit"><span class="nav-number">7.</span> <span class="nav-text">最佳拟合法 (Best fit)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最差拟合法-Worst-fit"><span class="nav-number">8.</span> <span class="nav-text">最差拟合法 (Worst fit)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#边界标识法-Boundary-Tag-Method"><span class="nav-number">9.</span> <span class="nav-text">边界标识法 (Boundary Tag Method)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配算法：两个约定"><span class="nav-number">10.</span> <span class="nav-text">分配算法：两个约定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分配约定"><span class="nav-number">10.1.</span> <span class="nav-text">分配约定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查找约定"><span class="nav-number">10.2.</span> <span class="nav-text">查找约定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配算法：首次拟合法"><span class="nav-number">11.</span> <span class="nav-text">分配算法：首次拟合法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回收算法"><span class="nav-number">12.</span> <span class="nav-text">回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#情况1"><span class="nav-number">12.1.</span> <span class="nav-text">情况1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#情况2、3"><span class="nav-number">12.2.</span> <span class="nav-text">情况2、3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#情况4"><span class="nav-number">12.3.</span> <span class="nav-text">情况4</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伙伴系统-Buddy-System"><span class="nav-number">13.</span> <span class="nav-text">伙伴系统 (Buddy System)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#伙伴系统的分配算法"><span class="nav-number">13.1.</span> <span class="nav-text">伙伴系统的分配算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回收算法-1"><span class="nav-number">13.2.</span> <span class="nav-text">回收算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无用单元收集"><span class="nav-number">14.</span> <span class="nav-text">无用单元收集</span></a></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2017 Cry On My Shoulder All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
      var headerblur = document.getElementById("header-blur");
      headerblur.style.minHeight = window.getComputedStyle(document.getElementById("allheader"), null).height;
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>








	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
